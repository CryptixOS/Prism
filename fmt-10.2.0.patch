diff --color -Naur fmt-original/include/fmt/chrono.h fmt-10.2.0/include/fmt/chrono.h
--- fmt-original/include/fmt/chrono.h	2025-07-16 22:36:59.476005995 +0200
+++ fmt-10.2.0/include/fmt/chrono.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,2240 +0,0 @@
-// Formatting library for C++ - chrono support
-//
-// Copyright (c) 2012 - present, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_CHRONO_H_
-#define FMT_CHRONO_H_
-
-#include <algorithm>
-#include <chrono>
-#include <cmath>    // std::isfinite
-#include <cstring>  // std::memcpy
-#include <ctime>
-#include <iterator>
-#include <locale>
-#include <ostream>
-#include <type_traits>
-
-#include "ostream.h"  // formatbuf
-
-FMT_BEGIN_NAMESPACE
-
-// Check if std::chrono::local_t is available.
-#ifndef FMT_USE_LOCAL_TIME
-#  ifdef __cpp_lib_chrono
-#    define FMT_USE_LOCAL_TIME (__cpp_lib_chrono >= 201907L)
-#  else
-#    define FMT_USE_LOCAL_TIME 0
-#  endif
-#endif
-
-// Check if std::chrono::utc_timestamp is available.
-#ifndef FMT_USE_UTC_TIME
-#  ifdef __cpp_lib_chrono
-#    define FMT_USE_UTC_TIME (__cpp_lib_chrono >= 201907L)
-#  else
-#    define FMT_USE_UTC_TIME 0
-#  endif
-#endif
-
-// Enable tzset.
-#ifndef FMT_USE_TZSET
-// UWP doesn't provide _tzset.
-#  if FMT_HAS_INCLUDE("winapifamily.h")
-#    include <winapifamily.h>
-#  endif
-#  if defined(_WIN32) && (!defined(WINAPI_FAMILY) || \
-                          (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP))
-#    define FMT_USE_TZSET 1
-#  else
-#    define FMT_USE_TZSET 0
-#  endif
-#endif
-
-// Enable safe chrono durations, unless explicitly disabled.
-#ifndef FMT_SAFE_DURATION_CAST
-#  define FMT_SAFE_DURATION_CAST 1
-#endif
-#if FMT_SAFE_DURATION_CAST
-
-// For conversion between std::chrono::durations without undefined
-// behaviour or erroneous results.
-// This is a stripped down version of duration_cast, for inclusion in fmt.
-// See https://github.com/pauldreik/safe_duration_cast
-//
-// Copyright Paul Dreik 2019
-namespace safe_duration_cast {
-
-template <typename To, typename From,
-          FMT_ENABLE_IF(!std::is_same<From, To>::value &&
-                        std::numeric_limits<From>::is_signed ==
-                            std::numeric_limits<To>::is_signed)>
-FMT_CONSTEXPR auto lossless_integral_conversion(const From from, int& ec)
-    -> To {
-  ec = 0;
-  using F = std::numeric_limits<From>;
-  using T = std::numeric_limits<To>;
-  static_assert(F::is_integer, "From must be integral");
-  static_assert(T::is_integer, "To must be integral");
-
-  // A and B are both signed, or both unsigned.
-  if (detail::const_check(F::digits <= T::digits)) {
-    // From fits in To without any problem.
-  } else {
-    // From does not always fit in To, resort to a dynamic check.
-    if (from < (T::min)() || from > (T::max)()) {
-      // outside range.
-      ec = 1;
-      return {};
-    }
-  }
-  return static_cast<To>(from);
-}
-
-/**
- * converts From to To, without loss. If the dynamic value of from
- * can't be converted to To without loss, ec is set.
- */
-template <typename To, typename From,
-          FMT_ENABLE_IF(!std::is_same<From, To>::value &&
-                        std::numeric_limits<From>::is_signed !=
-                            std::numeric_limits<To>::is_signed)>
-FMT_CONSTEXPR auto lossless_integral_conversion(const From from, int& ec)
-    -> To {
-  ec = 0;
-  using F = std::numeric_limits<From>;
-  using T = std::numeric_limits<To>;
-  static_assert(F::is_integer, "From must be integral");
-  static_assert(T::is_integer, "To must be integral");
-
-  if (detail::const_check(F::is_signed && !T::is_signed)) {
-    // From may be negative, not allowed!
-    if (fmt::detail::is_negative(from)) {
-      ec = 1;
-      return {};
-    }
-    // From is positive. Can it always fit in To?
-    if (detail::const_check(F::digits > T::digits) &&
-        from > static_cast<From>(detail::max_value<To>())) {
-      ec = 1;
-      return {};
-    }
-  }
-
-  if (detail::const_check(!F::is_signed && T::is_signed &&
-                          F::digits >= T::digits) &&
-      from > static_cast<From>(detail::max_value<To>())) {
-    ec = 1;
-    return {};
-  }
-  return static_cast<To>(from);  // Lossless conversion.
-}
-
-template <typename To, typename From,
-          FMT_ENABLE_IF(std::is_same<From, To>::value)>
-FMT_CONSTEXPR auto lossless_integral_conversion(const From from, int& ec)
-    -> To {
-  ec = 0;
-  return from;
-}  // function
-
-// clang-format off
-/**
- * converts From to To if possible, otherwise ec is set.
- *
- * input                            |    output
- * ---------------------------------|---------------
- * NaN                              | NaN
- * Inf                              | Inf
- * normal, fits in output           | converted (possibly lossy)
- * normal, does not fit in output   | ec is set
- * subnormal                        | best effort
- * -Inf                             | -Inf
- */
-// clang-format on
-template <typename To, typename From,
-          FMT_ENABLE_IF(!std::is_same<From, To>::value)>
-FMT_CONSTEXPR auto safe_float_conversion(const From from, int& ec) -> To {
-  ec = 0;
-  using T = std::numeric_limits<To>;
-  static_assert(std::is_floating_point<From>::value, "From must be floating");
-  static_assert(std::is_floating_point<To>::value, "To must be floating");
-
-  // catch the only happy case
-  if (std::isfinite(from)) {
-    if (from >= T::lowest() && from <= (T::max)()) {
-      return static_cast<To>(from);
-    }
-    // not within range.
-    ec = 1;
-    return {};
-  }
-
-  // nan and inf will be preserved
-  return static_cast<To>(from);
-}  // function
-
-template <typename To, typename From,
-          FMT_ENABLE_IF(std::is_same<From, To>::value)>
-FMT_CONSTEXPR auto safe_float_conversion(const From from, int& ec) -> To {
-  ec = 0;
-  static_assert(std::is_floating_point<From>::value, "From must be floating");
-  return from;
-}
-
-/**
- * safe duration cast between integral durations
- */
-template <typename To, typename FromRep, typename FromPeriod,
-          FMT_ENABLE_IF(std::is_integral<FromRep>::value),
-          FMT_ENABLE_IF(std::is_integral<typename To::rep>::value)>
-auto safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
-                        int& ec) -> To {
-  using From = std::chrono::duration<FromRep, FromPeriod>;
-  ec = 0;
-  // the basic idea is that we need to convert from count() in the from type
-  // to count() in the To type, by multiplying it with this:
-  struct Factor
-      : std::ratio_divide<typename From::period, typename To::period> {};
-
-  static_assert(Factor::num > 0, "num must be positive");
-  static_assert(Factor::den > 0, "den must be positive");
-
-  // the conversion is like this: multiply from.count() with Factor::num
-  // /Factor::den and convert it to To::rep, all this without
-  // overflow/underflow. let's start by finding a suitable type that can hold
-  // both To, From and Factor::num
-  using IntermediateRep =
-      typename std::common_type<typename From::rep, typename To::rep,
-                                decltype(Factor::num)>::type;
-
-  // safe conversion to IntermediateRep
-  IntermediateRep count =
-      lossless_integral_conversion<IntermediateRep>(from.count(), ec);
-  if (ec) return {};
-  // multiply with Factor::num without overflow or underflow
-  if (detail::const_check(Factor::num != 1)) {
-    const auto max1 = detail::max_value<IntermediateRep>() / Factor::num;
-    if (count > max1) {
-      ec = 1;
-      return {};
-    }
-    const auto min1 =
-        (std::numeric_limits<IntermediateRep>::min)() / Factor::num;
-    if (detail::const_check(!std::is_unsigned<IntermediateRep>::value) &&
-        count < min1) {
-      ec = 1;
-      return {};
-    }
-    count *= Factor::num;
-  }
-
-  if (detail::const_check(Factor::den != 1)) count /= Factor::den;
-  auto tocount = lossless_integral_conversion<typename To::rep>(count, ec);
-  return ec ? To() : To(tocount);
-}
-
-/**
- * safe duration_cast between floating point durations
- */
-template <typename To, typename FromRep, typename FromPeriod,
-          FMT_ENABLE_IF(std::is_floating_point<FromRep>::value),
-          FMT_ENABLE_IF(std::is_floating_point<typename To::rep>::value)>
-auto safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
-                        int& ec) -> To {
-  using From = std::chrono::duration<FromRep, FromPeriod>;
-  ec = 0;
-  if (std::isnan(from.count())) {
-    // nan in, gives nan out. easy.
-    return To{std::numeric_limits<typename To::rep>::quiet_NaN()};
-  }
-  // maybe we should also check if from is denormal, and decide what to do about
-  // it.
-
-  // +-inf should be preserved.
-  if (std::isinf(from.count())) {
-    return To{from.count()};
-  }
-
-  // the basic idea is that we need to convert from count() in the from type
-  // to count() in the To type, by multiplying it with this:
-  struct Factor
-      : std::ratio_divide<typename From::period, typename To::period> {};
-
-  static_assert(Factor::num > 0, "num must be positive");
-  static_assert(Factor::den > 0, "den must be positive");
-
-  // the conversion is like this: multiply from.count() with Factor::num
-  // /Factor::den and convert it to To::rep, all this without
-  // overflow/underflow. let's start by finding a suitable type that can hold
-  // both To, From and Factor::num
-  using IntermediateRep =
-      typename std::common_type<typename From::rep, typename To::rep,
-                                decltype(Factor::num)>::type;
-
-  // force conversion of From::rep -> IntermediateRep to be safe,
-  // even if it will never happen be narrowing in this context.
-  IntermediateRep count =
-      safe_float_conversion<IntermediateRep>(from.count(), ec);
-  if (ec) {
-    return {};
-  }
-
-  // multiply with Factor::num without overflow or underflow
-  if (detail::const_check(Factor::num != 1)) {
-    constexpr auto max1 = detail::max_value<IntermediateRep>() /
-                          static_cast<IntermediateRep>(Factor::num);
-    if (count > max1) {
-      ec = 1;
-      return {};
-    }
-    constexpr auto min1 = std::numeric_limits<IntermediateRep>::lowest() /
-                          static_cast<IntermediateRep>(Factor::num);
-    if (count < min1) {
-      ec = 1;
-      return {};
-    }
-    count *= static_cast<IntermediateRep>(Factor::num);
-  }
-
-  // this can't go wrong, right? den>0 is checked earlier.
-  if (detail::const_check(Factor::den != 1)) {
-    using common_t = typename std::common_type<IntermediateRep, intmax_t>::type;
-    count /= static_cast<common_t>(Factor::den);
-  }
-
-  // convert to the to type, safely
-  using ToRep = typename To::rep;
-
-  const ToRep tocount = safe_float_conversion<ToRep>(count, ec);
-  if (ec) {
-    return {};
-  }
-  return To{tocount};
-}
-}  // namespace safe_duration_cast
-#endif
-
-// Prevents expansion of a preceding token as a function-style macro.
-// Usage: f FMT_NOMACRO()
-#define FMT_NOMACRO
-
-namespace detail {
-template <typename T = void> struct null {};
-inline auto localtime_r FMT_NOMACRO(...) -> null<> { return null<>(); }
-inline auto localtime_s(...) -> null<> { return null<>(); }
-inline auto gmtime_r(...) -> null<> { return null<>(); }
-inline auto gmtime_s(...) -> null<> { return null<>(); }
-
-inline auto get_classic_locale() -> const std::locale& {
-  static const auto& locale = std::locale::classic();
-  return locale;
-}
-
-template <typename CodeUnit> struct codecvt_result {
-  static constexpr const size_t max_size = 32;
-  CodeUnit buf[max_size];
-  CodeUnit* end;
-};
-
-template <typename CodeUnit>
-void write_codecvt(codecvt_result<CodeUnit>& out, string_view in_buf,
-                   const std::locale& loc) {
-#if FMT_CLANG_VERSION
-#  pragma clang diagnostic push
-#  pragma clang diagnostic ignored "-Wdeprecated"
-  auto& f = std::use_facet<std::codecvt<CodeUnit, char, std::mbstate_t>>(loc);
-#  pragma clang diagnostic pop
-#else
-  auto& f = std::use_facet<std::codecvt<CodeUnit, char, std::mbstate_t>>(loc);
-#endif
-  auto mb = std::mbstate_t();
-  const char* from_next = nullptr;
-  auto result = f.in(mb, in_buf.begin(), in_buf.end(), from_next,
-                     std::begin(out.buf), std::end(out.buf), out.end);
-  if (result != std::codecvt_base::ok)
-    FMT_THROW(format_error("failed to format time"));
-}
-
-template <typename OutputIt>
-auto write_encoded_tm_str(OutputIt out, string_view in, const std::locale& loc)
-    -> OutputIt {
-  if (detail::is_utf8() && loc != get_classic_locale()) {
-    // char16_t and char32_t codecvts are broken in MSVC (linkage errors) and
-    // gcc-4.
-#if FMT_MSC_VERSION != 0 || \
-    (defined(__GLIBCXX__) && !defined(_GLIBCXX_USE_DUAL_ABI))
-    // The _GLIBCXX_USE_DUAL_ABI macro is always defined in libstdc++ from gcc-5
-    // and newer.
-    using code_unit = wchar_t;
-#else
-    using code_unit = char32_t;
-#endif
-
-    using unit_t = codecvt_result<code_unit>;
-    unit_t unit;
-    write_codecvt(unit, in, loc);
-    // In UTF-8 is used one to four one-byte code units.
-    auto u =
-        to_utf8<code_unit, basic_memory_buffer<char, unit_t::max_size * 4>>();
-    if (!u.convert({unit.buf, to_unsigned(unit.end - unit.buf)}))
-      FMT_THROW(format_error("failed to format time"));
-    return copy_str<char>(u.c_str(), u.c_str() + u.size(), out);
-  }
-  return copy_str<char>(in.data(), in.data() + in.size(), out);
-}
-
-template <typename Char, typename OutputIt,
-          FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
-auto write_tm_str(OutputIt out, string_view sv, const std::locale& loc)
-    -> OutputIt {
-  codecvt_result<Char> unit;
-  write_codecvt(unit, sv, loc);
-  return copy_str<Char>(unit.buf, unit.end, out);
-}
-
-template <typename Char, typename OutputIt,
-          FMT_ENABLE_IF(std::is_same<Char, char>::value)>
-auto write_tm_str(OutputIt out, string_view sv, const std::locale& loc)
-    -> OutputIt {
-  return write_encoded_tm_str(out, sv, loc);
-}
-
-template <typename Char>
-inline void do_write(buffer<Char>& buf, const std::tm& time,
-                     const std::locale& loc, char format, char modifier) {
-  auto&& format_buf = formatbuf<std::basic_streambuf<Char>>(buf);
-  auto&& os = std::basic_ostream<Char>(&format_buf);
-  os.imbue(loc);
-  const auto& facet = std::use_facet<std::time_put<Char>>(loc);
-  auto end = facet.put(os, os, Char(' '), &time, format, modifier);
-  if (end.failed()) FMT_THROW(format_error("failed to format time"));
-}
-
-template <typename Char, typename OutputIt,
-          FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
-auto write(OutputIt out, const std::tm& time, const std::locale& loc,
-           char format, char modifier = 0) -> OutputIt {
-  auto&& buf = get_buffer<Char>(out);
-  do_write<Char>(buf, time, loc, format, modifier);
-  return get_iterator(buf, out);
-}
-
-template <typename Char, typename OutputIt,
-          FMT_ENABLE_IF(std::is_same<Char, char>::value)>
-auto write(OutputIt out, const std::tm& time, const std::locale& loc,
-           char format, char modifier = 0) -> OutputIt {
-  auto&& buf = basic_memory_buffer<Char>();
-  do_write<char>(buf, time, loc, format, modifier);
-  return write_encoded_tm_str(out, string_view(buf.data(), buf.size()), loc);
-}
-
-template <typename Rep1, typename Rep2>
-struct is_same_arithmetic_type
-    : public std::integral_constant<bool,
-                                    (std::is_integral<Rep1>::value &&
-                                     std::is_integral<Rep2>::value) ||
-                                        (std::is_floating_point<Rep1>::value &&
-                                         std::is_floating_point<Rep2>::value)> {
-};
-
-template <
-    typename To, typename FromRep, typename FromPeriod,
-    FMT_ENABLE_IF(is_same_arithmetic_type<FromRep, typename To::rep>::value)>
-auto fmt_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) -> To {
-#if FMT_SAFE_DURATION_CAST
-  // Throwing version of safe_duration_cast is only available for
-  // integer to integer or float to float casts.
-  int ec;
-  To to = safe_duration_cast::safe_duration_cast<To>(from, ec);
-  if (ec) FMT_THROW(format_error("cannot format duration"));
-  return to;
-#else
-  // Standard duration cast, may overflow.
-  return std::chrono::duration_cast<To>(from);
-#endif
-}
-
-template <
-    typename To, typename FromRep, typename FromPeriod,
-    FMT_ENABLE_IF(!is_same_arithmetic_type<FromRep, typename To::rep>::value)>
-auto fmt_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) -> To {
-  // Mixed integer <-> float cast is not supported by safe_duration_cast.
-  return std::chrono::duration_cast<To>(from);
-}
-
-template <typename Duration>
-auto to_time_t(
-    std::chrono::time_point<std::chrono::system_clock, Duration> time_point)
-    -> std::time_t {
-  // Cannot use std::chrono::system_clock::to_time_t since this would first
-  // require a cast to std::chrono::system_clock::time_point, which could
-  // overflow.
-  return fmt_duration_cast<std::chrono::duration<std::time_t>>(
-             time_point.time_since_epoch())
-      .count();
-}
-}  // namespace detail
-
-FMT_BEGIN_EXPORT
-
-/**
-  Converts given time since epoch as ``std::time_t`` value into calendar time,
-  expressed in local time. Unlike ``std::localtime``, this function is
-  thread-safe on most platforms.
- */
-inline auto localtime(std::time_t time) -> std::tm {
-  struct dispatcher {
-    std::time_t time_;
-    std::tm tm_;
-
-    dispatcher(std::time_t t) : time_(t) {}
-
-    auto run() -> bool {
-      using namespace fmt::detail;
-      return handle(localtime_r(&time_, &tm_));
-    }
-
-    auto handle(std::tm* tm) -> bool { return tm != nullptr; }
-
-    auto handle(detail::null<>) -> bool {
-      using namespace fmt::detail;
-      return fallback(localtime_s(&tm_, &time_));
-    }
-
-    auto fallback(int res) -> bool { return res == 0; }
-
-#if !FMT_MSC_VERSION
-    auto fallback(detail::null<>) -> bool {
-      using namespace fmt::detail;
-      std::tm* tm = std::localtime(&time_);
-      if (tm) tm_ = *tm;
-      return tm != nullptr;
-    }
-#endif
-  };
-  dispatcher lt(time);
-  // Too big time values may be unsupported.
-  if (!lt.run()) FMT_THROW(format_error("time_t value out of range"));
-  return lt.tm_;
-}
-
-#if FMT_USE_LOCAL_TIME
-template <typename Duration>
-inline auto localtime(std::chrono::local_time<Duration> time) -> std::tm {
-  return localtime(
-      detail::to_time_t(std::chrono::current_zone()->to_sys(time)));
-}
-#endif
-
-/**
-  Converts given time since epoch as ``std::time_t`` value into calendar time,
-  expressed in Coordinated Universal Time (UTC). Unlike ``std::gmtime``, this
-  function is thread-safe on most platforms.
- */
-inline auto gmtime(std::time_t time) -> std::tm {
-  struct dispatcher {
-    std::time_t time_;
-    std::tm tm_;
-
-    dispatcher(std::time_t t) : time_(t) {}
-
-    auto run() -> bool {
-      using namespace fmt::detail;
-      return handle(gmtime_r(&time_, &tm_));
-    }
-
-    auto handle(std::tm* tm) -> bool { return tm != nullptr; }
-
-    auto handle(detail::null<>) -> bool {
-      using namespace fmt::detail;
-      return fallback(gmtime_s(&tm_, &time_));
-    }
-
-    auto fallback(int res) -> bool { return res == 0; }
-
-#if !FMT_MSC_VERSION
-    auto fallback(detail::null<>) -> bool {
-      std::tm* tm = std::gmtime(&time_);
-      if (tm) tm_ = *tm;
-      return tm != nullptr;
-    }
-#endif
-  };
-  auto gt = dispatcher(time);
-  // Too big time values may be unsupported.
-  if (!gt.run()) FMT_THROW(format_error("time_t value out of range"));
-  return gt.tm_;
-}
-
-template <typename Duration>
-inline auto gmtime(
-    std::chrono::time_point<std::chrono::system_clock, Duration> time_point)
-    -> std::tm {
-  return gmtime(detail::to_time_t(time_point));
-}
-
-namespace detail {
-
-// Writes two-digit numbers a, b and c separated by sep to buf.
-// The method by Pavel Novikov based on
-// https://johnnylee-sde.github.io/Fast-unsigned-integer-to-time-string/.
-inline void write_digit2_separated(char* buf, unsigned a, unsigned b,
-                                   unsigned c, char sep) {
-  unsigned long long digits =
-      a | (b << 24) | (static_cast<unsigned long long>(c) << 48);
-  // Convert each value to BCD.
-  // We have x = a * 10 + b and we want to convert it to BCD y = a * 16 + b.
-  // The difference is
-  //   y - x = a * 6
-  // a can be found from x:
-  //   a = floor(x / 10)
-  // then
-  //   y = x + a * 6 = x + floor(x / 10) * 6
-  // floor(x / 10) is (x * 205) >> 11 (needs 16 bits).
-  digits += (((digits * 205) >> 11) & 0x000f00000f00000f) * 6;
-  // Put low nibbles to high bytes and high nibbles to low bytes.
-  digits = ((digits & 0x00f00000f00000f0) >> 4) |
-           ((digits & 0x000f00000f00000f) << 8);
-  auto usep = static_cast<unsigned long long>(sep);
-  // Add ASCII '0' to each digit byte and insert separators.
-  digits |= 0x3030003030003030 | (usep << 16) | (usep << 40);
-
-  constexpr const size_t len = 8;
-  if (const_check(is_big_endian())) {
-    char tmp[len];
-    std::memcpy(tmp, &digits, len);
-    std::reverse_copy(tmp, tmp + len, buf);
-  } else {
-    std::memcpy(buf, &digits, len);
-  }
-}
-
-template <typename Period>
-FMT_CONSTEXPR inline auto get_units() -> const char* {
-  if (std::is_same<Period, std::atto>::value) return "as";
-  if (std::is_same<Period, std::femto>::value) return "fs";
-  if (std::is_same<Period, std::pico>::value) return "ps";
-  if (std::is_same<Period, std::nano>::value) return "ns";
-  if (std::is_same<Period, std::micro>::value) return "µs";
-  if (std::is_same<Period, std::milli>::value) return "ms";
-  if (std::is_same<Period, std::centi>::value) return "cs";
-  if (std::is_same<Period, std::deci>::value) return "ds";
-  if (std::is_same<Period, std::ratio<1>>::value) return "s";
-  if (std::is_same<Period, std::deca>::value) return "das";
-  if (std::is_same<Period, std::hecto>::value) return "hs";
-  if (std::is_same<Period, std::kilo>::value) return "ks";
-  if (std::is_same<Period, std::mega>::value) return "Ms";
-  if (std::is_same<Period, std::giga>::value) return "Gs";
-  if (std::is_same<Period, std::tera>::value) return "Ts";
-  if (std::is_same<Period, std::peta>::value) return "Ps";
-  if (std::is_same<Period, std::exa>::value) return "Es";
-  if (std::is_same<Period, std::ratio<60>>::value) return "min";
-  if (std::is_same<Period, std::ratio<3600>>::value) return "h";
-  if (std::is_same<Period, std::ratio<86400>>::value) return "d";
-  return nullptr;
-}
-
-enum class numeric_system {
-  standard,
-  // Alternative numeric system, e.g. 十二 instead of 12 in ja_JP locale.
-  alternative
-};
-
-// Glibc extensions for formatting numeric values.
-enum class pad_type {
-  unspecified,
-  // Do not pad a numeric result string.
-  none,
-  // Pad a numeric result string with zeros even if the conversion specifier
-  // character uses space-padding by default.
-  zero,
-  // Pad a numeric result string with spaces.
-  space,
-};
-
-template <typename OutputIt>
-auto write_padding(OutputIt out, pad_type pad, int width) -> OutputIt {
-  if (pad == pad_type::none) return out;
-  return std::fill_n(out, width, pad == pad_type::space ? ' ' : '0');
-}
-
-template <typename OutputIt>
-auto write_padding(OutputIt out, pad_type pad) -> OutputIt {
-  if (pad != pad_type::none) *out++ = pad == pad_type::space ? ' ' : '0';
-  return out;
-}
-
-// Parses a put_time-like format string and invokes handler actions.
-template <typename Char, typename Handler>
-FMT_CONSTEXPR auto parse_chrono_format(const Char* begin, const Char* end,
-                                       Handler&& handler) -> const Char* {
-  if (begin == end || *begin == '}') return begin;
-  if (*begin != '%') FMT_THROW(format_error("invalid format"));
-  auto ptr = begin;
-  pad_type pad = pad_type::unspecified;
-  while (ptr != end) {
-    auto c = *ptr;
-    if (c == '}') break;
-    if (c != '%') {
-      ++ptr;
-      continue;
-    }
-    if (begin != ptr) handler.on_text(begin, ptr);
-    ++ptr;  // consume '%'
-    if (ptr == end) FMT_THROW(format_error("invalid format"));
-    c = *ptr;
-    switch (c) {
-    case '_':
-      pad = pad_type::space;
-      ++ptr;
-      break;
-    case '-':
-      pad = pad_type::none;
-      ++ptr;
-      break;
-    case '0':
-      pad = pad_type::zero;
-      ++ptr;
-      break;
-    }
-    if (ptr == end) FMT_THROW(format_error("invalid format"));
-    c = *ptr++;
-    switch (c) {
-    case '%':
-      handler.on_text(ptr - 1, ptr);
-      break;
-    case 'n': {
-      const Char newline[] = {'\n'};
-      handler.on_text(newline, newline + 1);
-      break;
-    }
-    case 't': {
-      const Char tab[] = {'\t'};
-      handler.on_text(tab, tab + 1);
-      break;
-    }
-    // Year:
-    case 'Y':
-      handler.on_year(numeric_system::standard);
-      break;
-    case 'y':
-      handler.on_short_year(numeric_system::standard);
-      break;
-    case 'C':
-      handler.on_century(numeric_system::standard);
-      break;
-    case 'G':
-      handler.on_iso_week_based_year();
-      break;
-    case 'g':
-      handler.on_iso_week_based_short_year();
-      break;
-    // Day of the week:
-    case 'a':
-      handler.on_abbr_weekday();
-      break;
-    case 'A':
-      handler.on_full_weekday();
-      break;
-    case 'w':
-      handler.on_dec0_weekday(numeric_system::standard);
-      break;
-    case 'u':
-      handler.on_dec1_weekday(numeric_system::standard);
-      break;
-    // Month:
-    case 'b':
-    case 'h':
-      handler.on_abbr_month();
-      break;
-    case 'B':
-      handler.on_full_month();
-      break;
-    case 'm':
-      handler.on_dec_month(numeric_system::standard);
-      break;
-    // Day of the year/month:
-    case 'U':
-      handler.on_dec0_week_of_year(numeric_system::standard);
-      break;
-    case 'W':
-      handler.on_dec1_week_of_year(numeric_system::standard);
-      break;
-    case 'V':
-      handler.on_iso_week_of_year(numeric_system::standard);
-      break;
-    case 'j':
-      handler.on_day_of_year();
-      break;
-    case 'd':
-      handler.on_day_of_month(numeric_system::standard);
-      break;
-    case 'e':
-      handler.on_day_of_month_space(numeric_system::standard);
-      break;
-    // Hour, minute, second:
-    case 'H':
-      handler.on_24_hour(numeric_system::standard, pad);
-      break;
-    case 'I':
-      handler.on_12_hour(numeric_system::standard, pad);
-      break;
-    case 'M':
-      handler.on_minute(numeric_system::standard, pad);
-      break;
-    case 'S':
-      handler.on_second(numeric_system::standard, pad);
-      break;
-    // Other:
-    case 'c':
-      handler.on_datetime(numeric_system::standard);
-      break;
-    case 'x':
-      handler.on_loc_date(numeric_system::standard);
-      break;
-    case 'X':
-      handler.on_loc_time(numeric_system::standard);
-      break;
-    case 'D':
-      handler.on_us_date();
-      break;
-    case 'F':
-      handler.on_iso_date();
-      break;
-    case 'r':
-      handler.on_12_hour_time();
-      break;
-    case 'R':
-      handler.on_24_hour_time();
-      break;
-    case 'T':
-      handler.on_iso_time();
-      break;
-    case 'p':
-      handler.on_am_pm();
-      break;
-    case 'Q':
-      handler.on_duration_value();
-      break;
-    case 'q':
-      handler.on_duration_unit();
-      break;
-    case 'z':
-      handler.on_utc_offset(numeric_system::standard);
-      break;
-    case 'Z':
-      handler.on_tz_name();
-      break;
-    // Alternative representation:
-    case 'E': {
-      if (ptr == end) FMT_THROW(format_error("invalid format"));
-      c = *ptr++;
-      switch (c) {
-      case 'Y':
-        handler.on_year(numeric_system::alternative);
-        break;
-      case 'y':
-        handler.on_offset_year();
-        break;
-      case 'C':
-        handler.on_century(numeric_system::alternative);
-        break;
-      case 'c':
-        handler.on_datetime(numeric_system::alternative);
-        break;
-      case 'x':
-        handler.on_loc_date(numeric_system::alternative);
-        break;
-      case 'X':
-        handler.on_loc_time(numeric_system::alternative);
-        break;
-      case 'z':
-        handler.on_utc_offset(numeric_system::alternative);
-        break;
-      default:
-        FMT_THROW(format_error("invalid format"));
-      }
-      break;
-    }
-    case 'O':
-      if (ptr == end) FMT_THROW(format_error("invalid format"));
-      c = *ptr++;
-      switch (c) {
-      case 'y':
-        handler.on_short_year(numeric_system::alternative);
-        break;
-      case 'm':
-        handler.on_dec_month(numeric_system::alternative);
-        break;
-      case 'U':
-        handler.on_dec0_week_of_year(numeric_system::alternative);
-        break;
-      case 'W':
-        handler.on_dec1_week_of_year(numeric_system::alternative);
-        break;
-      case 'V':
-        handler.on_iso_week_of_year(numeric_system::alternative);
-        break;
-      case 'd':
-        handler.on_day_of_month(numeric_system::alternative);
-        break;
-      case 'e':
-        handler.on_day_of_month_space(numeric_system::alternative);
-        break;
-      case 'w':
-        handler.on_dec0_weekday(numeric_system::alternative);
-        break;
-      case 'u':
-        handler.on_dec1_weekday(numeric_system::alternative);
-        break;
-      case 'H':
-        handler.on_24_hour(numeric_system::alternative, pad);
-        break;
-      case 'I':
-        handler.on_12_hour(numeric_system::alternative, pad);
-        break;
-      case 'M':
-        handler.on_minute(numeric_system::alternative, pad);
-        break;
-      case 'S':
-        handler.on_second(numeric_system::alternative, pad);
-        break;
-      case 'z':
-        handler.on_utc_offset(numeric_system::alternative);
-        break;
-      default:
-        FMT_THROW(format_error("invalid format"));
-      }
-      break;
-    default:
-      FMT_THROW(format_error("invalid format"));
-    }
-    begin = ptr;
-  }
-  if (begin != ptr) handler.on_text(begin, ptr);
-  return ptr;
-}
-
-template <typename Derived> struct null_chrono_spec_handler {
-  FMT_CONSTEXPR void unsupported() {
-    static_cast<Derived*>(this)->unsupported();
-  }
-  FMT_CONSTEXPR void on_year(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_short_year(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_offset_year() { unsupported(); }
-  FMT_CONSTEXPR void on_century(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_iso_week_based_year() { unsupported(); }
-  FMT_CONSTEXPR void on_iso_week_based_short_year() { unsupported(); }
-  FMT_CONSTEXPR void on_abbr_weekday() { unsupported(); }
-  FMT_CONSTEXPR void on_full_weekday() { unsupported(); }
-  FMT_CONSTEXPR void on_dec0_weekday(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_dec1_weekday(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_abbr_month() { unsupported(); }
-  FMT_CONSTEXPR void on_full_month() { unsupported(); }
-  FMT_CONSTEXPR void on_dec_month(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_dec0_week_of_year(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_dec1_week_of_year(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_iso_week_of_year(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_day_of_year() { unsupported(); }
-  FMT_CONSTEXPR void on_day_of_month(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_day_of_month_space(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_24_hour(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_12_hour(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_minute(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_second(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_datetime(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_loc_date(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_loc_time(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_us_date() { unsupported(); }
-  FMT_CONSTEXPR void on_iso_date() { unsupported(); }
-  FMT_CONSTEXPR void on_12_hour_time() { unsupported(); }
-  FMT_CONSTEXPR void on_24_hour_time() { unsupported(); }
-  FMT_CONSTEXPR void on_iso_time() { unsupported(); }
-  FMT_CONSTEXPR void on_am_pm() { unsupported(); }
-  FMT_CONSTEXPR void on_duration_value() { unsupported(); }
-  FMT_CONSTEXPR void on_duration_unit() { unsupported(); }
-  FMT_CONSTEXPR void on_utc_offset(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_tz_name() { unsupported(); }
-};
-
-struct tm_format_checker : null_chrono_spec_handler<tm_format_checker> {
-  FMT_NORETURN void unsupported() { FMT_THROW(format_error("no format")); }
-
-  template <typename Char>
-  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
-  FMT_CONSTEXPR void on_year(numeric_system) {}
-  FMT_CONSTEXPR void on_short_year(numeric_system) {}
-  FMT_CONSTEXPR void on_offset_year() {}
-  FMT_CONSTEXPR void on_century(numeric_system) {}
-  FMT_CONSTEXPR void on_iso_week_based_year() {}
-  FMT_CONSTEXPR void on_iso_week_based_short_year() {}
-  FMT_CONSTEXPR void on_abbr_weekday() {}
-  FMT_CONSTEXPR void on_full_weekday() {}
-  FMT_CONSTEXPR void on_dec0_weekday(numeric_system) {}
-  FMT_CONSTEXPR void on_dec1_weekday(numeric_system) {}
-  FMT_CONSTEXPR void on_abbr_month() {}
-  FMT_CONSTEXPR void on_full_month() {}
-  FMT_CONSTEXPR void on_dec_month(numeric_system) {}
-  FMT_CONSTEXPR void on_dec0_week_of_year(numeric_system) {}
-  FMT_CONSTEXPR void on_dec1_week_of_year(numeric_system) {}
-  FMT_CONSTEXPR void on_iso_week_of_year(numeric_system) {}
-  FMT_CONSTEXPR void on_day_of_year() {}
-  FMT_CONSTEXPR void on_day_of_month(numeric_system) {}
-  FMT_CONSTEXPR void on_day_of_month_space(numeric_system) {}
-  FMT_CONSTEXPR void on_24_hour(numeric_system, pad_type) {}
-  FMT_CONSTEXPR void on_12_hour(numeric_system, pad_type) {}
-  FMT_CONSTEXPR void on_minute(numeric_system, pad_type) {}
-  FMT_CONSTEXPR void on_second(numeric_system, pad_type) {}
-  FMT_CONSTEXPR void on_datetime(numeric_system) {}
-  FMT_CONSTEXPR void on_loc_date(numeric_system) {}
-  FMT_CONSTEXPR void on_loc_time(numeric_system) {}
-  FMT_CONSTEXPR void on_us_date() {}
-  FMT_CONSTEXPR void on_iso_date() {}
-  FMT_CONSTEXPR void on_12_hour_time() {}
-  FMT_CONSTEXPR void on_24_hour_time() {}
-  FMT_CONSTEXPR void on_iso_time() {}
-  FMT_CONSTEXPR void on_am_pm() {}
-  FMT_CONSTEXPR void on_utc_offset(numeric_system) {}
-  FMT_CONSTEXPR void on_tz_name() {}
-};
-
-inline auto tm_wday_full_name(int wday) -> const char* {
-  static constexpr const char* full_name_list[] = {
-      "Sunday",   "Monday", "Tuesday", "Wednesday",
-      "Thursday", "Friday", "Saturday"};
-  return wday >= 0 && wday <= 6 ? full_name_list[wday] : "?";
-}
-inline auto tm_wday_short_name(int wday) -> const char* {
-  static constexpr const char* short_name_list[] = {"Sun", "Mon", "Tue", "Wed",
-                                                    "Thu", "Fri", "Sat"};
-  return wday >= 0 && wday <= 6 ? short_name_list[wday] : "???";
-}
-
-inline auto tm_mon_full_name(int mon) -> const char* {
-  static constexpr const char* full_name_list[] = {
-      "January", "February", "March",     "April",   "May",      "June",
-      "July",    "August",   "September", "October", "November", "December"};
-  return mon >= 0 && mon <= 11 ? full_name_list[mon] : "?";
-}
-inline auto tm_mon_short_name(int mon) -> const char* {
-  static constexpr const char* short_name_list[] = {
-      "Jan", "Feb", "Mar", "Apr", "May", "Jun",
-      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
-  };
-  return mon >= 0 && mon <= 11 ? short_name_list[mon] : "???";
-}
-
-template <typename T, typename = void>
-struct has_member_data_tm_gmtoff : std::false_type {};
-template <typename T>
-struct has_member_data_tm_gmtoff<T, void_t<decltype(T::tm_gmtoff)>>
-    : std::true_type {};
-
-template <typename T, typename = void>
-struct has_member_data_tm_zone : std::false_type {};
-template <typename T>
-struct has_member_data_tm_zone<T, void_t<decltype(T::tm_zone)>>
-    : std::true_type {};
-
-#if FMT_USE_TZSET
-inline void tzset_once() {
-  static bool init = []() -> bool {
-    _tzset();
-    return true;
-  }();
-  ignore_unused(init);
-}
-#endif
-
-// Converts value to Int and checks that it's in the range [0, upper).
-template <typename T, typename Int, FMT_ENABLE_IF(std::is_integral<T>::value)>
-inline auto to_nonnegative_int(T value, Int upper) -> Int {
-  if (!std::is_unsigned<Int>::value &&
-      (value < 0 || to_unsigned(value) > to_unsigned(upper))) {
-    FMT_THROW(fmt::format_error("chrono value is out of range"));
-  }
-  return static_cast<Int>(value);
-}
-template <typename T, typename Int, FMT_ENABLE_IF(!std::is_integral<T>::value)>
-inline auto to_nonnegative_int(T value, Int upper) -> Int {
-  if (value < 0 || value > static_cast<T>(upper))
-    FMT_THROW(format_error("invalid value"));
-  return static_cast<Int>(value);
-}
-
-constexpr auto pow10(std::uint32_t n) -> long long {
-  return n == 0 ? 1 : 10 * pow10(n - 1);
-}
-
-// Counts the number of fractional digits in the range [0, 18] according to the
-// C++20 spec. If more than 18 fractional digits are required then returns 6 for
-// microseconds precision.
-template <long long Num, long long Den, int N = 0,
-          bool Enabled = (N < 19) && (Num <= max_value<long long>() / 10)>
-struct count_fractional_digits {
-  static constexpr int value =
-      Num % Den == 0 ? N : count_fractional_digits<Num * 10, Den, N + 1>::value;
-};
-
-// Base case that doesn't instantiate any more templates
-// in order to avoid overflow.
-template <long long Num, long long Den, int N>
-struct count_fractional_digits<Num, Den, N, false> {
-  static constexpr int value = (Num % Den == 0) ? N : 6;
-};
-
-// Format subseconds which are given as an integer type with an appropriate
-// number of digits.
-template <typename Char, typename OutputIt, typename Duration>
-void write_fractional_seconds(OutputIt& out, Duration d, int precision = -1) {
-  constexpr auto num_fractional_digits =
-      count_fractional_digits<Duration::period::num,
-                              Duration::period::den>::value;
-
-  using subsecond_precision = std::chrono::duration<
-      typename std::common_type<typename Duration::rep,
-                                std::chrono::seconds::rep>::type,
-      std::ratio<1, detail::pow10(num_fractional_digits)>>;
-
-  const auto fractional = d - fmt_duration_cast<std::chrono::seconds>(d);
-  const auto subseconds =
-      std::chrono::treat_as_floating_point<
-          typename subsecond_precision::rep>::value
-          ? fractional.count()
-          : fmt_duration_cast<subsecond_precision>(fractional).count();
-  auto n = static_cast<uint32_or_64_or_128_t<long long>>(subseconds);
-  const int num_digits = detail::count_digits(n);
-
-  int leading_zeroes = (std::max)(0, num_fractional_digits - num_digits);
-  if (precision < 0) {
-    FMT_ASSERT(!std::is_floating_point<typename Duration::rep>::value, "");
-    if (std::ratio_less<typename subsecond_precision::period,
-                        std::chrono::seconds::period>::value) {
-      *out++ = '.';
-      out = std::fill_n(out, leading_zeroes, '0');
-      out = format_decimal<Char>(out, n, num_digits).end;
-    }
-  } else {
-    *out++ = '.';
-    leading_zeroes = (std::min)(leading_zeroes, precision);
-    out = std::fill_n(out, leading_zeroes, '0');
-    int remaining = precision - leading_zeroes;
-    if (remaining != 0 && remaining < num_digits) {
-      n /= to_unsigned(detail::pow10(to_unsigned(num_digits - remaining)));
-      out = format_decimal<Char>(out, n, remaining).end;
-      return;
-    }
-    out = format_decimal<Char>(out, n, num_digits).end;
-    remaining -= num_digits;
-    out = std::fill_n(out, remaining, '0');
-  }
-}
-
-// Format subseconds which are given as a floating point type with an
-// appropriate number of digits. We cannot pass the Duration here, as we
-// explicitly need to pass the Rep value in the chrono_formatter.
-template <typename Duration>
-void write_floating_seconds(memory_buffer& buf, Duration duration,
-                            int num_fractional_digits = -1) {
-  using rep = typename Duration::rep;
-  FMT_ASSERT(std::is_floating_point<rep>::value, "");
-
-  auto val = duration.count();
-
-  if (num_fractional_digits < 0) {
-    // For `std::round` with fallback to `round`:
-    // On some toolchains `std::round` is not available (e.g. GCC 6).
-    using namespace std;
-    num_fractional_digits =
-        count_fractional_digits<Duration::period::num,
-                                Duration::period::den>::value;
-    if (num_fractional_digits < 6 && static_cast<rep>(round(val)) != val)
-      num_fractional_digits = 6;
-  }
-
-  fmt::format_to(std::back_inserter(buf), FMT_STRING("{:.{}f}"),
-                 std::fmod(val * static_cast<rep>(Duration::period::num) /
-                               static_cast<rep>(Duration::period::den),
-                           static_cast<rep>(60)),
-                 num_fractional_digits);
-}
-
-template <typename OutputIt, typename Char,
-          typename Duration = std::chrono::seconds>
-class tm_writer {
- private:
-  static constexpr int days_per_week = 7;
-
-  const std::locale& loc_;
-  const bool is_classic_;
-  OutputIt out_;
-  const Duration* subsecs_;
-  const std::tm& tm_;
-
-  auto tm_sec() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_sec >= 0 && tm_.tm_sec <= 61, "");
-    return tm_.tm_sec;
-  }
-  auto tm_min() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_min >= 0 && tm_.tm_min <= 59, "");
-    return tm_.tm_min;
-  }
-  auto tm_hour() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_hour >= 0 && tm_.tm_hour <= 23, "");
-    return tm_.tm_hour;
-  }
-  auto tm_mday() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_mday >= 1 && tm_.tm_mday <= 31, "");
-    return tm_.tm_mday;
-  }
-  auto tm_mon() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_mon >= 0 && tm_.tm_mon <= 11, "");
-    return tm_.tm_mon;
-  }
-  auto tm_year() const noexcept -> long long { return 1900ll + tm_.tm_year; }
-  auto tm_wday() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_wday >= 0 && tm_.tm_wday <= 6, "");
-    return tm_.tm_wday;
-  }
-  auto tm_yday() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_yday >= 0 && tm_.tm_yday <= 365, "");
-    return tm_.tm_yday;
-  }
-
-  auto tm_hour12() const noexcept -> int {
-    const auto h = tm_hour();
-    const auto z = h < 12 ? h : h - 12;
-    return z == 0 ? 12 : z;
-  }
-
-  // POSIX and the C Standard are unclear or inconsistent about what %C and %y
-  // do if the year is negative or exceeds 9999. Use the convention that %C
-  // concatenated with %y yields the same output as %Y, and that %Y contains at
-  // least 4 characters, with more only if necessary.
-  auto split_year_lower(long long year) const noexcept -> int {
-    auto l = year % 100;
-    if (l < 0) l = -l;  // l in [0, 99]
-    return static_cast<int>(l);
-  }
-
-  // Algorithm: https://en.wikipedia.org/wiki/ISO_week_date.
-  auto iso_year_weeks(long long curr_year) const noexcept -> int {
-    const auto prev_year = curr_year - 1;
-    const auto curr_p =
-        (curr_year + curr_year / 4 - curr_year / 100 + curr_year / 400) %
-        days_per_week;
-    const auto prev_p =
-        (prev_year + prev_year / 4 - prev_year / 100 + prev_year / 400) %
-        days_per_week;
-    return 52 + ((curr_p == 4 || prev_p == 3) ? 1 : 0);
-  }
-  auto iso_week_num(int tm_yday, int tm_wday) const noexcept -> int {
-    return (tm_yday + 11 - (tm_wday == 0 ? days_per_week : tm_wday)) /
-           days_per_week;
-  }
-  auto tm_iso_week_year() const noexcept -> long long {
-    const auto year = tm_year();
-    const auto w = iso_week_num(tm_yday(), tm_wday());
-    if (w < 1) return year - 1;
-    if (w > iso_year_weeks(year)) return year + 1;
-    return year;
-  }
-  auto tm_iso_week_of_year() const noexcept -> int {
-    const auto year = tm_year();
-    const auto w = iso_week_num(tm_yday(), tm_wday());
-    if (w < 1) return iso_year_weeks(year - 1);
-    if (w > iso_year_weeks(year)) return 1;
-    return w;
-  }
-
-  void write1(int value) {
-    *out_++ = static_cast<char>('0' + to_unsigned(value) % 10);
-  }
-  void write2(int value) {
-    const char* d = digits2(to_unsigned(value) % 100);
-    *out_++ = *d++;
-    *out_++ = *d;
-  }
-  void write2(int value, pad_type pad) {
-    unsigned int v = to_unsigned(value) % 100;
-    if (v >= 10) {
-      const char* d = digits2(v);
-      *out_++ = *d++;
-      *out_++ = *d;
-    } else {
-      out_ = detail::write_padding(out_, pad);
-      *out_++ = static_cast<char>('0' + v);
-    }
-  }
-
-  void write_year_extended(long long year) {
-    // At least 4 characters.
-    int width = 4;
-    if (year < 0) {
-      *out_++ = '-';
-      year = 0 - year;
-      --width;
-    }
-    uint32_or_64_or_128_t<long long> n = to_unsigned(year);
-    const int num_digits = count_digits(n);
-    if (width > num_digits) out_ = std::fill_n(out_, width - num_digits, '0');
-    out_ = format_decimal<Char>(out_, n, num_digits).end;
-  }
-  void write_year(long long year) {
-    if (year >= 0 && year < 10000) {
-      write2(static_cast<int>(year / 100));
-      write2(static_cast<int>(year % 100));
-    } else {
-      write_year_extended(year);
-    }
-  }
-
-  void write_utc_offset(long offset, numeric_system ns) {
-    if (offset < 0) {
-      *out_++ = '-';
-      offset = -offset;
-    } else {
-      *out_++ = '+';
-    }
-    offset /= 60;
-    write2(static_cast<int>(offset / 60));
-    if (ns != numeric_system::standard) *out_++ = ':';
-    write2(static_cast<int>(offset % 60));
-  }
-  template <typename T, FMT_ENABLE_IF(has_member_data_tm_gmtoff<T>::value)>
-  void format_utc_offset_impl(const T& tm, numeric_system ns) {
-    write_utc_offset(tm.tm_gmtoff, ns);
-  }
-  template <typename T, FMT_ENABLE_IF(!has_member_data_tm_gmtoff<T>::value)>
-  void format_utc_offset_impl(const T& tm, numeric_system ns) {
-#if defined(_WIN32) && defined(_UCRT)
-#  if FMT_USE_TZSET
-    tzset_once();
-#  endif
-    long offset = 0;
-    _get_timezone(&offset);
-    if (tm.tm_isdst) {
-      long dstbias = 0;
-      _get_dstbias(&dstbias);
-      offset += dstbias;
-    }
-    write_utc_offset(-offset, ns);
-#else
-    if (ns == numeric_system::standard) return format_localized('z');
-
-    // Extract timezone offset from timezone conversion functions.
-    std::tm gtm = tm;
-    std::time_t gt = std::mktime(&gtm);
-    std::tm ltm = gmtime(gt);
-    std::time_t lt = std::mktime(&ltm);
-    long offset = gt - lt;
-    write_utc_offset(offset, ns);
-#endif
-  }
-
-  template <typename T, FMT_ENABLE_IF(has_member_data_tm_zone<T>::value)>
-  void format_tz_name_impl(const T& tm) {
-    if (is_classic_)
-      out_ = write_tm_str<Char>(out_, tm.tm_zone, loc_);
-    else
-      format_localized('Z');
-  }
-  template <typename T, FMT_ENABLE_IF(!has_member_data_tm_zone<T>::value)>
-  void format_tz_name_impl(const T&) {
-    format_localized('Z');
-  }
-
-  void format_localized(char format, char modifier = 0) {
-    out_ = write<Char>(out_, tm_, loc_, format, modifier);
-  }
-
- public:
-  tm_writer(const std::locale& loc, OutputIt out, const std::tm& tm,
-            const Duration* subsecs = nullptr)
-      : loc_(loc),
-        is_classic_(loc_ == get_classic_locale()),
-        out_(out),
-        subsecs_(subsecs),
-        tm_(tm) {}
-
-  auto out() const -> OutputIt { return out_; }
-
-  FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {
-    out_ = copy_str<Char>(begin, end, out_);
-  }
-
-  void on_abbr_weekday() {
-    if (is_classic_)
-      out_ = write(out_, tm_wday_short_name(tm_wday()));
-    else
-      format_localized('a');
-  }
-  void on_full_weekday() {
-    if (is_classic_)
-      out_ = write(out_, tm_wday_full_name(tm_wday()));
-    else
-      format_localized('A');
-  }
-  void on_dec0_weekday(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) return write1(tm_wday());
-    format_localized('w', 'O');
-  }
-  void on_dec1_weekday(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) {
-      auto wday = tm_wday();
-      write1(wday == 0 ? days_per_week : wday);
-    } else {
-      format_localized('u', 'O');
-    }
-  }
-
-  void on_abbr_month() {
-    if (is_classic_)
-      out_ = write(out_, tm_mon_short_name(tm_mon()));
-    else
-      format_localized('b');
-  }
-  void on_full_month() {
-    if (is_classic_)
-      out_ = write(out_, tm_mon_full_name(tm_mon()));
-    else
-      format_localized('B');
-  }
-
-  void on_datetime(numeric_system ns) {
-    if (is_classic_) {
-      on_abbr_weekday();
-      *out_++ = ' ';
-      on_abbr_month();
-      *out_++ = ' ';
-      on_day_of_month_space(numeric_system::standard);
-      *out_++ = ' ';
-      on_iso_time();
-      *out_++ = ' ';
-      on_year(numeric_system::standard);
-    } else {
-      format_localized('c', ns == numeric_system::standard ? '\0' : 'E');
-    }
-  }
-  void on_loc_date(numeric_system ns) {
-    if (is_classic_)
-      on_us_date();
-    else
-      format_localized('x', ns == numeric_system::standard ? '\0' : 'E');
-  }
-  void on_loc_time(numeric_system ns) {
-    if (is_classic_)
-      on_iso_time();
-    else
-      format_localized('X', ns == numeric_system::standard ? '\0' : 'E');
-  }
-  void on_us_date() {
-    char buf[8];
-    write_digit2_separated(buf, to_unsigned(tm_mon() + 1),
-                           to_unsigned(tm_mday()),
-                           to_unsigned(split_year_lower(tm_year())), '/');
-    out_ = copy_str<Char>(std::begin(buf), std::end(buf), out_);
-  }
-  void on_iso_date() {
-    auto year = tm_year();
-    char buf[10];
-    size_t offset = 0;
-    if (year >= 0 && year < 10000) {
-      copy2(buf, digits2(static_cast<size_t>(year / 100)));
-    } else {
-      offset = 4;
-      write_year_extended(year);
-      year = 0;
-    }
-    write_digit2_separated(buf + 2, static_cast<unsigned>(year % 100),
-                           to_unsigned(tm_mon() + 1), to_unsigned(tm_mday()),
-                           '-');
-    out_ = copy_str<Char>(std::begin(buf) + offset, std::end(buf), out_);
-  }
-
-  void on_utc_offset(numeric_system ns) { format_utc_offset_impl(tm_, ns); }
-  void on_tz_name() { format_tz_name_impl(tm_); }
-
-  void on_year(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write_year(tm_year());
-    format_localized('Y', 'E');
-  }
-  void on_short_year(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write2(split_year_lower(tm_year()));
-    format_localized('y', 'O');
-  }
-  void on_offset_year() {
-    if (is_classic_) return write2(split_year_lower(tm_year()));
-    format_localized('y', 'E');
-  }
-
-  void on_century(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) {
-      auto year = tm_year();
-      auto upper = year / 100;
-      if (year >= -99 && year < 0) {
-        // Zero upper on negative year.
-        *out_++ = '-';
-        *out_++ = '0';
-      } else if (upper >= 0 && upper < 100) {
-        write2(static_cast<int>(upper));
-      } else {
-        out_ = write<Char>(out_, upper);
-      }
-    } else {
-      format_localized('C', 'E');
-    }
-  }
-
-  void on_dec_month(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write2(tm_mon() + 1);
-    format_localized('m', 'O');
-  }
-
-  void on_dec0_week_of_year(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write2((tm_yday() + days_per_week - tm_wday()) / days_per_week);
-    format_localized('U', 'O');
-  }
-  void on_dec1_week_of_year(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) {
-      auto wday = tm_wday();
-      write2((tm_yday() + days_per_week -
-              (wday == 0 ? (days_per_week - 1) : (wday - 1))) /
-             days_per_week);
-    } else {
-      format_localized('W', 'O');
-    }
-  }
-  void on_iso_week_of_year(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write2(tm_iso_week_of_year());
-    format_localized('V', 'O');
-  }
-
-  void on_iso_week_based_year() { write_year(tm_iso_week_year()); }
-  void on_iso_week_based_short_year() {
-    write2(split_year_lower(tm_iso_week_year()));
-  }
-
-  void on_day_of_year() {
-    auto yday = tm_yday() + 1;
-    write1(yday / 100);
-    write2(yday % 100);
-  }
-  void on_day_of_month(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) return write2(tm_mday());
-    format_localized('d', 'O');
-  }
-  void on_day_of_month_space(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) {
-      auto mday = to_unsigned(tm_mday()) % 100;
-      const char* d2 = digits2(mday);
-      *out_++ = mday < 10 ? ' ' : d2[0];
-      *out_++ = d2[1];
-    } else {
-      format_localized('e', 'O');
-    }
-  }
-
-  void on_24_hour(numeric_system ns, pad_type pad) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write2(tm_hour(), pad);
-    format_localized('H', 'O');
-  }
-  void on_12_hour(numeric_system ns, pad_type pad) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write2(tm_hour12(), pad);
-    format_localized('I', 'O');
-  }
-  void on_minute(numeric_system ns, pad_type pad) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write2(tm_min(), pad);
-    format_localized('M', 'O');
-  }
-
-  void on_second(numeric_system ns, pad_type pad) {
-    if (is_classic_ || ns == numeric_system::standard) {
-      write2(tm_sec(), pad);
-      if (subsecs_) {
-        if (std::is_floating_point<typename Duration::rep>::value) {
-          auto buf = memory_buffer();
-          write_floating_seconds(buf, *subsecs_);
-          if (buf.size() > 1) {
-            // Remove the leading "0", write something like ".123".
-            out_ = std::copy(buf.begin() + 1, buf.end(), out_);
-          }
-        } else {
-          write_fractional_seconds<Char>(out_, *subsecs_);
-        }
-      }
-    } else {
-      // Currently no formatting of subseconds when a locale is set.
-      format_localized('S', 'O');
-    }
-  }
-
-  void on_12_hour_time() {
-    if (is_classic_) {
-      char buf[8];
-      write_digit2_separated(buf, to_unsigned(tm_hour12()),
-                             to_unsigned(tm_min()), to_unsigned(tm_sec()), ':');
-      out_ = copy_str<Char>(std::begin(buf), std::end(buf), out_);
-      *out_++ = ' ';
-      on_am_pm();
-    } else {
-      format_localized('r');
-    }
-  }
-  void on_24_hour_time() {
-    write2(tm_hour());
-    *out_++ = ':';
-    write2(tm_min());
-  }
-  void on_iso_time() {
-    on_24_hour_time();
-    *out_++ = ':';
-    on_second(numeric_system::standard, pad_type::unspecified);
-  }
-
-  void on_am_pm() {
-    if (is_classic_) {
-      *out_++ = tm_hour() < 12 ? 'A' : 'P';
-      *out_++ = 'M';
-    } else {
-      format_localized('p');
-    }
-  }
-
-  // These apply to chrono durations but not tm.
-  void on_duration_value() {}
-  void on_duration_unit() {}
-};
-
-struct chrono_format_checker : null_chrono_spec_handler<chrono_format_checker> {
-  bool has_precision_integral = false;
-
-  FMT_NORETURN void unsupported() { FMT_THROW(format_error("no date")); }
-
-  template <typename Char>
-  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
-  FMT_CONSTEXPR void on_day_of_year() {}
-  FMT_CONSTEXPR void on_24_hour(numeric_system, pad_type) {}
-  FMT_CONSTEXPR void on_12_hour(numeric_system, pad_type) {}
-  FMT_CONSTEXPR void on_minute(numeric_system, pad_type) {}
-  FMT_CONSTEXPR void on_second(numeric_system, pad_type) {}
-  FMT_CONSTEXPR void on_12_hour_time() {}
-  FMT_CONSTEXPR void on_24_hour_time() {}
-  FMT_CONSTEXPR void on_iso_time() {}
-  FMT_CONSTEXPR void on_am_pm() {}
-  FMT_CONSTEXPR void on_duration_value() const {
-    if (has_precision_integral) {
-      FMT_THROW(format_error("precision not allowed for this argument type"));
-    }
-  }
-  FMT_CONSTEXPR void on_duration_unit() {}
-};
-
-template <typename T,
-          FMT_ENABLE_IF(std::is_integral<T>::value&& has_isfinite<T>::value)>
-inline auto isfinite(T) -> bool {
-  return true;
-}
-
-template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-inline auto mod(T x, int y) -> T {
-  return x % static_cast<T>(y);
-}
-template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
-inline auto mod(T x, int y) -> T {
-  return std::fmod(x, static_cast<T>(y));
-}
-
-// If T is an integral type, maps T to its unsigned counterpart, otherwise
-// leaves it unchanged (unlike std::make_unsigned).
-template <typename T, bool INTEGRAL = std::is_integral<T>::value>
-struct make_unsigned_or_unchanged {
-  using type = T;
-};
-
-template <typename T> struct make_unsigned_or_unchanged<T, true> {
-  using type = typename std::make_unsigned<T>::type;
-};
-
-template <typename Rep, typename Period,
-          FMT_ENABLE_IF(std::is_integral<Rep>::value)>
-inline auto get_milliseconds(std::chrono::duration<Rep, Period> d)
-    -> std::chrono::duration<Rep, std::milli> {
-  // this may overflow and/or the result may not fit in the
-  // target type.
-#if FMT_SAFE_DURATION_CAST
-  using CommonSecondsType =
-      typename std::common_type<decltype(d), std::chrono::seconds>::type;
-  const auto d_as_common = fmt_duration_cast<CommonSecondsType>(d);
-  const auto d_as_whole_seconds =
-      fmt_duration_cast<std::chrono::seconds>(d_as_common);
-  // this conversion should be nonproblematic
-  const auto diff = d_as_common - d_as_whole_seconds;
-  const auto ms =
-      fmt_duration_cast<std::chrono::duration<Rep, std::milli>>(diff);
-  return ms;
-#else
-  auto s = fmt_duration_cast<std::chrono::seconds>(d);
-  return fmt_duration_cast<std::chrono::milliseconds>(d - s);
-#endif
-}
-
-template <typename Char, typename Rep, typename OutputIt,
-          FMT_ENABLE_IF(std::is_integral<Rep>::value)>
-auto format_duration_value(OutputIt out, Rep val, int) -> OutputIt {
-  return write<Char>(out, val);
-}
-
-template <typename Char, typename Rep, typename OutputIt,
-          FMT_ENABLE_IF(std::is_floating_point<Rep>::value)>
-auto format_duration_value(OutputIt out, Rep val, int precision) -> OutputIt {
-  auto specs = format_specs<Char>();
-  specs.precision = precision;
-  specs.type = precision >= 0 ? presentation_type::fixed_lower
-                              : presentation_type::general_lower;
-  return write<Char>(out, val, specs);
-}
-
-template <typename Char, typename OutputIt>
-auto copy_unit(string_view unit, OutputIt out, Char) -> OutputIt {
-  return std::copy(unit.begin(), unit.end(), out);
-}
-
-template <typename OutputIt>
-auto copy_unit(string_view unit, OutputIt out, wchar_t) -> OutputIt {
-  // This works when wchar_t is UTF-32 because units only contain characters
-  // that have the same representation in UTF-16 and UTF-32.
-  utf8_to_utf16 u(unit);
-  return std::copy(u.c_str(), u.c_str() + u.size(), out);
-}
-
-template <typename Char, typename Period, typename OutputIt>
-auto format_duration_unit(OutputIt out) -> OutputIt {
-  if (const char* unit = get_units<Period>())
-    return copy_unit(string_view(unit), out, Char());
-  *out++ = '[';
-  out = write<Char>(out, Period::num);
-  if (const_check(Period::den != 1)) {
-    *out++ = '/';
-    out = write<Char>(out, Period::den);
-  }
-  *out++ = ']';
-  *out++ = 's';
-  return out;
-}
-
-class get_locale {
- private:
-  union {
-    std::locale locale_;
-  };
-  bool has_locale_ = false;
-
- public:
-  get_locale(bool localized, locale_ref loc) : has_locale_(localized) {
-    if (localized)
-      ::new (&locale_) std::locale(loc.template get<std::locale>());
-  }
-  ~get_locale() {
-    if (has_locale_) locale_.~locale();
-  }
-  operator const std::locale&() const {
-    return has_locale_ ? locale_ : get_classic_locale();
-  }
-};
-
-template <typename FormatContext, typename OutputIt, typename Rep,
-          typename Period>
-struct chrono_formatter {
-  FormatContext& context;
-  OutputIt out;
-  int precision;
-  bool localized = false;
-  // rep is unsigned to avoid overflow.
-  using rep =
-      conditional_t<std::is_integral<Rep>::value && sizeof(Rep) < sizeof(int),
-                    unsigned, typename make_unsigned_or_unchanged<Rep>::type>;
-  rep val;
-  using seconds = std::chrono::duration<rep>;
-  seconds s;
-  using milliseconds = std::chrono::duration<rep, std::milli>;
-  bool negative;
-
-  using char_type = typename FormatContext::char_type;
-  using tm_writer_type = tm_writer<OutputIt, char_type>;
-
-  chrono_formatter(FormatContext& ctx, OutputIt o,
-                   std::chrono::duration<Rep, Period> d)
-      : context(ctx),
-        out(o),
-        val(static_cast<rep>(d.count())),
-        negative(false) {
-    if (d.count() < 0) {
-      val = 0 - val;
-      negative = true;
-    }
-
-    // this may overflow and/or the result may not fit in the
-    // target type.
-    // might need checked conversion (rep!=Rep)
-    s = fmt_duration_cast<seconds>(std::chrono::duration<rep, Period>(val));
-  }
-
-  // returns true if nan or inf, writes to out.
-  auto handle_nan_inf() -> bool {
-    if (isfinite(val)) {
-      return false;
-    }
-    if (isnan(val)) {
-      write_nan();
-      return true;
-    }
-    // must be +-inf
-    if (val > 0) {
-      write_pinf();
-    } else {
-      write_ninf();
-    }
-    return true;
-  }
-
-  auto days() const -> Rep { return static_cast<Rep>(s.count() / 86400); }
-  auto hour() const -> Rep {
-    return static_cast<Rep>(mod((s.count() / 3600), 24));
-  }
-
-  auto hour12() const -> Rep {
-    Rep hour = static_cast<Rep>(mod((s.count() / 3600), 12));
-    return hour <= 0 ? 12 : hour;
-  }
-
-  auto minute() const -> Rep {
-    return static_cast<Rep>(mod((s.count() / 60), 60));
-  }
-  auto second() const -> Rep { return static_cast<Rep>(mod(s.count(), 60)); }
-
-  auto time() const -> std::tm {
-    auto time = std::tm();
-    time.tm_hour = to_nonnegative_int(hour(), 24);
-    time.tm_min = to_nonnegative_int(minute(), 60);
-    time.tm_sec = to_nonnegative_int(second(), 60);
-    return time;
-  }
-
-  void write_sign() {
-    if (negative) {
-      *out++ = '-';
-      negative = false;
-    }
-  }
-
-  void write(Rep value, int width, pad_type pad = pad_type::unspecified) {
-    write_sign();
-    if (isnan(value)) return write_nan();
-    uint32_or_64_or_128_t<int> n =
-        to_unsigned(to_nonnegative_int(value, max_value<int>()));
-    int num_digits = detail::count_digits(n);
-    if (width > num_digits) {
-      out = detail::write_padding(out, pad, width - num_digits);
-    }
-    out = format_decimal<char_type>(out, n, num_digits).end;
-  }
-
-  void write_nan() { std::copy_n("nan", 3, out); }
-  void write_pinf() { std::copy_n("inf", 3, out); }
-  void write_ninf() { std::copy_n("-inf", 4, out); }
-
-  template <typename Callback, typename... Args>
-  void format_tm(const tm& time, Callback cb, Args... args) {
-    if (isnan(val)) return write_nan();
-    get_locale loc(localized, context.locale());
-    auto w = tm_writer_type(loc, out, time);
-    (w.*cb)(args...);
-    out = w.out();
-  }
-
-  void on_text(const char_type* begin, const char_type* end) {
-    std::copy(begin, end, out);
-  }
-
-  // These are not implemented because durations don't have date information.
-  void on_abbr_weekday() {}
-  void on_full_weekday() {}
-  void on_dec0_weekday(numeric_system) {}
-  void on_dec1_weekday(numeric_system) {}
-  void on_abbr_month() {}
-  void on_full_month() {}
-  void on_datetime(numeric_system) {}
-  void on_loc_date(numeric_system) {}
-  void on_loc_time(numeric_system) {}
-  void on_us_date() {}
-  void on_iso_date() {}
-  void on_utc_offset(numeric_system) {}
-  void on_tz_name() {}
-  void on_year(numeric_system) {}
-  void on_short_year(numeric_system) {}
-  void on_offset_year() {}
-  void on_century(numeric_system) {}
-  void on_iso_week_based_year() {}
-  void on_iso_week_based_short_year() {}
-  void on_dec_month(numeric_system) {}
-  void on_dec0_week_of_year(numeric_system) {}
-  void on_dec1_week_of_year(numeric_system) {}
-  void on_iso_week_of_year(numeric_system) {}
-  void on_day_of_month(numeric_system) {}
-  void on_day_of_month_space(numeric_system) {}
-
-  void on_day_of_year() {
-    if (handle_nan_inf()) return;
-    write(days(), 0);
-  }
-
-  void on_24_hour(numeric_system ns, pad_type pad) {
-    if (handle_nan_inf()) return;
-
-    if (ns == numeric_system::standard) return write(hour(), 2, pad);
-    auto time = tm();
-    time.tm_hour = to_nonnegative_int(hour(), 24);
-    format_tm(time, &tm_writer_type::on_24_hour, ns, pad);
-  }
-
-  void on_12_hour(numeric_system ns, pad_type pad) {
-    if (handle_nan_inf()) return;
-
-    if (ns == numeric_system::standard) return write(hour12(), 2, pad);
-    auto time = tm();
-    time.tm_hour = to_nonnegative_int(hour12(), 12);
-    format_tm(time, &tm_writer_type::on_12_hour, ns, pad);
-  }
-
-  void on_minute(numeric_system ns, pad_type pad) {
-    if (handle_nan_inf()) return;
-
-    if (ns == numeric_system::standard) return write(minute(), 2, pad);
-    auto time = tm();
-    time.tm_min = to_nonnegative_int(minute(), 60);
-    format_tm(time, &tm_writer_type::on_minute, ns, pad);
-  }
-
-  void on_second(numeric_system ns, pad_type pad) {
-    if (handle_nan_inf()) return;
-
-    if (ns == numeric_system::standard) {
-      if (std::is_floating_point<rep>::value) {
-        auto buf = memory_buffer();
-        write_floating_seconds(buf, std::chrono::duration<rep, Period>(val),
-                               precision);
-        if (negative) *out++ = '-';
-        if (buf.size() < 2 || buf[1] == '.') {
-          out = detail::write_padding(out, pad);
-        }
-        out = std::copy(buf.begin(), buf.end(), out);
-      } else {
-        write(second(), 2, pad);
-        write_fractional_seconds<char_type>(
-            out, std::chrono::duration<rep, Period>(val), precision);
-      }
-      return;
-    }
-    auto time = tm();
-    time.tm_sec = to_nonnegative_int(second(), 60);
-    format_tm(time, &tm_writer_type::on_second, ns, pad);
-  }
-
-  void on_12_hour_time() {
-    if (handle_nan_inf()) return;
-    format_tm(time(), &tm_writer_type::on_12_hour_time);
-  }
-
-  void on_24_hour_time() {
-    if (handle_nan_inf()) {
-      *out++ = ':';
-      handle_nan_inf();
-      return;
-    }
-
-    write(hour(), 2);
-    *out++ = ':';
-    write(minute(), 2);
-  }
-
-  void on_iso_time() {
-    on_24_hour_time();
-    *out++ = ':';
-    if (handle_nan_inf()) return;
-    on_second(numeric_system::standard, pad_type::unspecified);
-  }
-
-  void on_am_pm() {
-    if (handle_nan_inf()) return;
-    format_tm(time(), &tm_writer_type::on_am_pm);
-  }
-
-  void on_duration_value() {
-    if (handle_nan_inf()) return;
-    write_sign();
-    out = format_duration_value<char_type>(out, val, precision);
-  }
-
-  void on_duration_unit() {
-    out = format_duration_unit<char_type, Period>(out);
-  }
-};
-
-}  // namespace detail
-
-#if defined(__cpp_lib_chrono) && __cpp_lib_chrono >= 201907
-using weekday = std::chrono::weekday;
-#else
-// A fallback version of weekday.
-class weekday {
- private:
-  unsigned char value;
-
- public:
-  weekday() = default;
-  explicit constexpr weekday(unsigned wd) noexcept
-      : value(static_cast<unsigned char>(wd != 7 ? wd : 0)) {}
-  constexpr auto c_encoding() const noexcept -> unsigned { return value; }
-};
-
-class year_month_day {};
-#endif
-
-// A rudimentary weekday formatter.
-template <typename Char> struct formatter<weekday, Char> {
- private:
-  bool localized = false;
-
- public:
-  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
-      -> decltype(ctx.begin()) {
-    auto begin = ctx.begin(), end = ctx.end();
-    if (begin != end && *begin == 'L') {
-      ++begin;
-      localized = true;
-    }
-    return begin;
-  }
-
-  template <typename FormatContext>
-  auto format(weekday wd, FormatContext& ctx) const -> decltype(ctx.out()) {
-    auto time = std::tm();
-    time.tm_wday = static_cast<int>(wd.c_encoding());
-    detail::get_locale loc(localized, ctx.locale());
-    auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);
-    w.on_abbr_weekday();
-    return w.out();
-  }
-};
-
-template <typename Rep, typename Period, typename Char>
-struct formatter<std::chrono::duration<Rep, Period>, Char> {
- private:
-  format_specs<Char> specs_;
-  detail::arg_ref<Char> width_ref_;
-  detail::arg_ref<Char> precision_ref_;
-  bool localized_ = false;
-  basic_string_view<Char> format_str_;
-
- public:
-  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
-      -> decltype(ctx.begin()) {
-    auto it = ctx.begin(), end = ctx.end();
-    if (it == end || *it == '}') return it;
-
-    it = detail::parse_align(it, end, specs_);
-    if (it == end) return it;
-
-    it = detail::parse_dynamic_spec(it, end, specs_.width, width_ref_, ctx);
-    if (it == end) return it;
-
-    auto checker = detail::chrono_format_checker();
-    if (*it == '.') {
-      checker.has_precision_integral = !std::is_floating_point<Rep>::value;
-      it = detail::parse_precision(it, end, specs_.precision, precision_ref_,
-                                   ctx);
-    }
-    if (it != end && *it == 'L') {
-      localized_ = true;
-      ++it;
-    }
-    end = detail::parse_chrono_format(it, end, checker);
-    format_str_ = {it, detail::to_unsigned(end - it)};
-    return end;
-  }
-
-  template <typename FormatContext>
-  auto format(std::chrono::duration<Rep, Period> d, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    auto specs = specs_;
-    auto precision = specs.precision;
-    specs.precision = -1;
-    auto begin = format_str_.begin(), end = format_str_.end();
-    // As a possible future optimization, we could avoid extra copying if width
-    // is not specified.
-    auto buf = basic_memory_buffer<Char>();
-    auto out = std::back_inserter(buf);
-    detail::handle_dynamic_spec<detail::width_checker>(specs.width, width_ref_,
-                                                       ctx);
-    detail::handle_dynamic_spec<detail::precision_checker>(precision,
-                                                           precision_ref_, ctx);
-    if (begin == end || *begin == '}') {
-      out = detail::format_duration_value<Char>(out, d.count(), precision);
-      detail::format_duration_unit<Char, Period>(out);
-    } else {
-      using chrono_formatter =
-          detail::chrono_formatter<FormatContext, decltype(out), Rep, Period>;
-      auto f = chrono_formatter(ctx, out, d);
-      f.precision = precision;
-      f.localized = localized_;
-      detail::parse_chrono_format(begin, end, f);
-    }
-    return detail::write(
-        ctx.out(), basic_string_view<Char>(buf.data(), buf.size()), specs);
-  }
-};
-
-template <typename Char, typename Duration>
-struct formatter<std::chrono::time_point<std::chrono::system_clock, Duration>,
-                 Char> : formatter<std::tm, Char> {
-  FMT_CONSTEXPR formatter() {
-    this->format_str_ = detail::string_literal<Char, '%', 'F', ' ', '%', 'T'>{};
-  }
-
-  template <typename FormatContext>
-  auto format(std::chrono::time_point<std::chrono::system_clock, Duration> val,
-              FormatContext& ctx) const -> decltype(ctx.out()) {
-    using period = typename Duration::period;
-    if (detail::const_check(
-            period::num != 1 || period::den != 1 ||
-            std::is_floating_point<typename Duration::rep>::value)) {
-      const auto epoch = val.time_since_epoch();
-      auto subsecs = detail::fmt_duration_cast<Duration>(
-          epoch - detail::fmt_duration_cast<std::chrono::seconds>(epoch));
-
-      if (subsecs.count() < 0) {
-        auto second =
-            detail::fmt_duration_cast<Duration>(std::chrono::seconds(1));
-        if (epoch.count() < ((Duration::min)() + second).count())
-          FMT_THROW(format_error("duration is too small"));
-        subsecs += second;
-        val -= second;
-      }
-
-      return formatter<std::tm, Char>::do_format(gmtime(val), ctx, &subsecs);
-    }
-
-    return formatter<std::tm, Char>::format(gmtime(val), ctx);
-  }
-};
-
-#if FMT_USE_LOCAL_TIME
-template <typename Char, typename Duration>
-struct formatter<std::chrono::local_time<Duration>, Char>
-    : formatter<std::tm, Char> {
-  FMT_CONSTEXPR formatter() {
-    this->format_str_ = detail::string_literal<Char, '%', 'F', ' ', '%', 'T'>{};
-  }
-
-  template <typename FormatContext>
-  auto format(std::chrono::local_time<Duration> val, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    using period = typename Duration::period;
-    if (period::num != 1 || period::den != 1 ||
-        std::is_floating_point<typename Duration::rep>::value) {
-      const auto epoch = val.time_since_epoch();
-      const auto subsecs = detail::fmt_duration_cast<Duration>(
-          epoch - detail::fmt_duration_cast<std::chrono::seconds>(epoch));
-
-      return formatter<std::tm, Char>::do_format(localtime(val), ctx, &subsecs);
-    }
-
-    return formatter<std::tm, Char>::format(localtime(val), ctx);
-  }
-};
-#endif
-
-#if FMT_USE_UTC_TIME
-template <typename Char, typename Duration>
-struct formatter<std::chrono::time_point<std::chrono::utc_clock, Duration>,
-                 Char>
-    : formatter<std::chrono::time_point<std::chrono::system_clock, Duration>,
-                Char> {
-  template <typename FormatContext>
-  auto format(std::chrono::time_point<std::chrono::utc_clock, Duration> val,
-              FormatContext& ctx) const -> decltype(ctx.out()) {
-    return formatter<
-        std::chrono::time_point<std::chrono::system_clock, Duration>,
-        Char>::format(std::chrono::utc_clock::to_sys(val), ctx);
-  }
-};
-#endif
-
-template <typename Char> struct formatter<std::tm, Char> {
- private:
-  format_specs<Char> specs_;
-  detail::arg_ref<Char> width_ref_;
-
- protected:
-  basic_string_view<Char> format_str_;
-
-  template <typename FormatContext, typename Duration>
-  auto do_format(const std::tm& tm, FormatContext& ctx,
-                 const Duration* subsecs) const -> decltype(ctx.out()) {
-    auto specs = specs_;
-    auto buf = basic_memory_buffer<Char>();
-    auto out = std::back_inserter(buf);
-    detail::handle_dynamic_spec<detail::width_checker>(specs.width, width_ref_,
-                                                       ctx);
-
-    auto loc_ref = ctx.locale();
-    detail::get_locale loc(static_cast<bool>(loc_ref), loc_ref);
-    auto w =
-        detail::tm_writer<decltype(out), Char, Duration>(loc, out, tm, subsecs);
-    detail::parse_chrono_format(format_str_.begin(), format_str_.end(), w);
-    return detail::write(
-        ctx.out(), basic_string_view<Char>(buf.data(), buf.size()), specs);
-  }
-
- public:
-  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
-      -> decltype(ctx.begin()) {
-    auto it = ctx.begin(), end = ctx.end();
-    if (it == end || *it == '}') return it;
-
-    it = detail::parse_align(it, end, specs_);
-    if (it == end) return it;
-
-    it = detail::parse_dynamic_spec(it, end, specs_.width, width_ref_, ctx);
-    if (it == end) return it;
-
-    end = detail::parse_chrono_format(it, end, detail::tm_format_checker());
-    // Replace the default format_str only if the new spec is not empty.
-    if (end != it) format_str_ = {it, detail::to_unsigned(end - it)};
-    return end;
-  }
-
-  template <typename FormatContext>
-  auto format(const std::tm& tm, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    return do_format<FormatContext, std::chrono::seconds>(tm, ctx, nullptr);
-  }
-};
-
-FMT_END_EXPORT
-FMT_END_NAMESPACE
-
-#endif  // FMT_CHRONO_H_
diff --color -Naur fmt-original/include/fmt/color.h fmt-10.2.0/include/fmt/color.h
--- fmt-original/include/fmt/color.h	2025-07-16 22:36:59.476480925 +0200
+++ fmt-10.2.0/include/fmt/color.h	2025-07-16 22:36:52.875895041 +0200
@@ -155,7 +155,7 @@
   white_smoke = 0xF5F5F5,              // rgb(245,245,245)
   yellow = 0xFFFF00,                   // rgb(255,255,0)
   yellow_green = 0x9ACD32              // rgb(154,205,50)
-};                                     // enum class color
+};  // enum class color
 
 enum class terminal_color : uint8_t {
   black = 30,
@@ -466,40 +466,6 @@
 
 }  // namespace detail
 
-inline void vprint(std::FILE* f, const text_style& ts, string_view fmt,
-                   format_args args) {
-  // Legacy wide streams are not supported.
-  auto buf = memory_buffer();
-  detail::vformat_to(buf, ts, fmt, args);
-  if (detail::is_utf8()) {
-    detail::print(f, string_view(buf.begin(), buf.size()));
-    return;
-  }
-  buf.push_back('\0');
-  int result = std::fputs(buf.data(), f);
-  if (result < 0)
-    FMT_THROW(system_error(errno, FMT_STRING("cannot write to file")));
-}
-
-/**
-  \rst
-  Formats a string and prints it to the specified file stream using ANSI
-  escape sequences to specify text formatting.
-
-  **Example**::
-
-    fmt::print(fmt::emphasis::bold | fg(fmt::color::red),
-               "Elapsed time: {0:.2f} seconds", 1.23);
-  \endrst
- */
-template <typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_string<S>::value)>
-void print(std::FILE* f, const text_style& ts, const S& format_str,
-           const Args&... args) {
-  vprint(f, ts, format_str,
-         fmt::make_format_args<buffer_context<char_t<S>>>(args...));
-}
-
 /**
   \rst
   Formats a string and prints it to stdout using ANSI escape sequences to
@@ -517,16 +483,6 @@
   return print(stdout, ts, format_str, args...);
 }
 
-template <typename S, typename Char = char_t<S>>
-inline auto vformat(
-    const text_style& ts, const S& format_str,
-    basic_format_args<buffer_context<type_identity_t<Char>>> args)
-    -> std::basic_string<Char> {
-  basic_memory_buffer<Char> buf;
-  detail::vformat_to(buf, ts, detail::to_string_view(format_str), args);
-  return fmt::to_string(buf);
-}
-
 /**
   \rst
   Formats arguments and returns the result as a string using ANSI
diff --color -Naur fmt-original/include/fmt/compile.h fmt-10.2.0/include/fmt/compile.h
--- fmt-original/include/fmt/compile.h	2025-07-16 22:36:59.476818474 +0200
+++ fmt-10.2.0/include/fmt/compile.h	2025-07-16 22:36:52.874240330 +0200
@@ -510,7 +510,6 @@
 void print(std::FILE* f, const S& format_str, const Args&... args) {
   memory_buffer buffer;
   fmt::format_to(std::back_inserter(buffer), format_str, args...);
-  detail::print(f, {buffer.data(), buffer.size()});
 }
 
 template <typename S, typename... Args,
diff --color -Naur fmt-original/include/fmt/core.h fmt-10.2.0/include/fmt/core.h
--- fmt-original/include/fmt/core.h	2025-07-16 22:36:59.477450620 +0200
+++ fmt-10.2.0/include/fmt/core.h	2025-07-16 22:36:52.874903136 +0200
@@ -9,7 +9,6 @@
 #define FMT_CORE_H_
 
 #include <cstddef>  // std::byte
-#include <cstdio>   // std::FILE
 #include <cstring>  // std::strlen
 #include <iterator>
 #include <limits>
@@ -33,42 +32,20 @@
 #  define FMT_GCC_VERSION 0
 #endif
 
-#ifndef FMT_GCC_PRAGMA
-// Workaround _Pragma bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59884.
-#  if FMT_GCC_VERSION >= 504
-#    define FMT_GCC_PRAGMA(arg) _Pragma(arg)
-#  else
-#    define FMT_GCC_PRAGMA(arg)
-#  endif
-#endif
+#define FMT_GCC_PRAGMA(arg) _Pragma(arg)
 
 #ifdef __ICL
 #  define FMT_ICC_VERSION __ICL
-#elif defined(__INTEL_COMPILER)
-#  define FMT_ICC_VERSION __INTEL_COMPILER
 #else
 #  define FMT_ICC_VERSION 0
 #endif
 
-#ifdef _MSC_VER
-#  define FMT_MSC_VERSION _MSC_VER
-#  define FMT_MSC_WARNING(...) __pragma(warning(__VA_ARGS__))
-#else
-#  define FMT_MSC_VERSION 0
-#  define FMT_MSC_WARNING(...)
-#endif
+#define FMT_MSC_VERSION 0
+#define FMT_MSC_WARNING(...)
 
-#ifdef _MSVC_LANG
-#  define FMT_CPLUSPLUS _MSVC_LANG
-#else
-#  define FMT_CPLUSPLUS __cplusplus
-#endif
+#define FMT_CPLUSPLUS __cplusplus
 
-#ifdef __has_feature
-#  define FMT_HAS_FEATURE(x) __has_feature(x)
-#else
-#  define FMT_HAS_FEATURE(x) 0
-#endif
+#define FMT_HAS_FEATURE(x) __has_feature(x)
 
 #if defined(__has_include) || FMT_ICC_VERSION >= 1600 || FMT_MSC_VERSION > 1900
 #  define FMT_HAS_INCLUDE(x) __has_include(x)
@@ -76,11 +53,7 @@
 #  define FMT_HAS_INCLUDE(x) 0
 #endif
 
-#ifdef __has_cpp_attribute
-#  define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
-#else
-#  define FMT_HAS_CPP_ATTRIBUTE(x) 0
-#endif
+#define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
 
 #define FMT_HAS_CPP14_ATTRIBUTE(attribute) \
   (FMT_CPLUSPLUS >= 201402L && FMT_HAS_CPP_ATTRIBUTE(attribute))
@@ -90,88 +63,17 @@
 
 // Check if relaxed C++14 constexpr is supported.
 // GCC doesn't allow throw in constexpr until version 6 (bug 67371).
-#ifndef FMT_USE_CONSTEXPR
-#  if (FMT_HAS_FEATURE(cxx_relaxed_constexpr) || FMT_MSC_VERSION >= 1912 || \
-       (FMT_GCC_VERSION >= 600 && FMT_CPLUSPLUS >= 201402L)) &&             \
-      !FMT_ICC_VERSION && (!defined(__NVCC__) || FMT_CPLUSPLUS >= 202002L)
-#    define FMT_USE_CONSTEXPR 1
-#  else
-#    define FMT_USE_CONSTEXPR 0
-#  endif
-#endif
-#if FMT_USE_CONSTEXPR
-#  define FMT_CONSTEXPR constexpr
-#else
-#  define FMT_CONSTEXPR
-#endif
-
-#if (FMT_CPLUSPLUS >= 202002L ||                                \
-     (FMT_CPLUSPLUS >= 201709L && FMT_GCC_VERSION >= 1002)) &&  \
-    ((!defined(_GLIBCXX_RELEASE) || _GLIBCXX_RELEASE >= 10) &&  \
-     (!defined(_LIBCPP_VERSION) || _LIBCPP_VERSION >= 10000) && \
-     (!FMT_MSC_VERSION || FMT_MSC_VERSION >= 1928)) &&          \
-    defined(__cpp_lib_is_constant_evaluated)
-#  define FMT_CONSTEXPR20 constexpr
-#else
-#  define FMT_CONSTEXPR20
-#endif
-
+#define FMT_USE_CONSTEXPR 1
+#define FMT_CONSTEXPR constexpr
+#define FMT_CONSTEXPR20 constexpr
 // Check if constexpr std::char_traits<>::{compare,length} are supported.
-#if defined(__GLIBCXX__)
-#  if FMT_CPLUSPLUS >= 201703L && defined(_GLIBCXX_RELEASE) && \
-      _GLIBCXX_RELEASE >= 7  // GCC 7+ libstdc++ has _GLIBCXX_RELEASE.
-#    define FMT_CONSTEXPR_CHAR_TRAITS constexpr
-#  endif
-#elif defined(_LIBCPP_VERSION) && FMT_CPLUSPLUS >= 201703L && \
-    _LIBCPP_VERSION >= 4000
-#  define FMT_CONSTEXPR_CHAR_TRAITS constexpr
-#elif FMT_MSC_VERSION >= 1914 && FMT_CPLUSPLUS >= 201703L
-#  define FMT_CONSTEXPR_CHAR_TRAITS constexpr
-#endif
-#ifndef FMT_CONSTEXPR_CHAR_TRAITS
-#  define FMT_CONSTEXPR_CHAR_TRAITS
-#endif
-
+#define FMT_CONSTEXPR_CHAR_TRAITS constexpr
 // Check if exceptions are disabled.
-#ifndef FMT_EXCEPTIONS
-#  if (defined(__GNUC__) && !defined(__EXCEPTIONS)) || \
-      (FMT_MSC_VERSION && !_HAS_EXCEPTIONS)
-#    define FMT_EXCEPTIONS 0
-#  else
-#    define FMT_EXCEPTIONS 1
-#  endif
-#endif
-
-// Disable [[noreturn]] on MSVC/NVCC because of bogus unreachable code warnings.
-#if FMT_EXCEPTIONS && FMT_HAS_CPP_ATTRIBUTE(noreturn) && !FMT_MSC_VERSION && \
-    !defined(__NVCC__)
-#  define FMT_NORETURN [[noreturn]]
-#else
-#  define FMT_NORETURN
-#endif
-
-#ifndef FMT_NODISCARD
-#  if FMT_HAS_CPP17_ATTRIBUTE(nodiscard)
-#    define FMT_NODISCARD [[nodiscard]]
-#  else
-#    define FMT_NODISCARD
-#  endif
-#endif
-
-#ifndef FMT_INLINE
-#  if FMT_GCC_VERSION || FMT_CLANG_VERSION
-#    define FMT_INLINE inline __attribute__((always_inline))
-#  else
-#    define FMT_INLINE inline
-#  endif
-#endif
-
-#ifdef _MSC_VER
-#  define FMT_UNCHECKED_ITERATOR(It) \
-    using _Unchecked_type = It  // Mark iterator as checked.
-#else
-#  define FMT_UNCHECKED_ITERATOR(It) using unchecked_type = It
-#endif
+#define FMT_EXCEPTIONS 0
+#define FMT_NORETURN
+#define FMT_NODISCARD [[nodiscard]]
+#define FMT_INLINE inline __attribute__((always_inline))
+#define FMT_UNCHECKED_ITERATOR(It) using unchecked_type = It
 
 #ifndef FMT_BEGIN_NAMESPACE
 #  define FMT_BEGIN_NAMESPACE \
@@ -182,27 +84,12 @@
     }
 #endif
 
-#ifndef FMT_EXPORT
-#  define FMT_EXPORT
-#  define FMT_BEGIN_EXPORT
-#  define FMT_END_EXPORT
-#endif
+#define FMT_EXPORT
+#define FMT_BEGIN_EXPORT
+#define FMT_END_EXPORT
 
-#if FMT_GCC_VERSION || FMT_CLANG_VERSION
-#  define FMT_VISIBILITY(value) __attribute__((visibility(value)))
-#else
-#  define FMT_VISIBILITY(value)
-#endif
+#define FMT_VISIBILITY(value)
 
-#if !defined(FMT_HEADER_ONLY) && defined(_WIN32)
-#  if defined(FMT_LIB_EXPORT)
-#    define FMT_API __declspec(dllexport)
-#  elif defined(FMT_SHARED)
-#    define FMT_API __declspec(dllimport)
-#  endif
-#elif defined(FMT_LIB_EXPORT) || defined(FMT_SHARED)
-#  define FMT_API FMT_VISIBILITY("default")
-#endif
 #ifndef FMT_API
 #  define FMT_API
 #endif
@@ -221,21 +108,8 @@
 #  define FMT_UNICODE !FMT_MSC_VERSION
 #endif
 
-#ifndef FMT_CONSTEVAL
-#  if ((FMT_GCC_VERSION >= 1000 || FMT_CLANG_VERSION >= 1101) && \
-       (!defined(__apple_build_version__) ||                     \
-        __apple_build_version__ >= 14000029L) &&                 \
-       FMT_CPLUSPLUS >= 202002L) ||                              \
-      (defined(__cpp_consteval) &&                               \
-       (!FMT_MSC_VERSION || FMT_MSC_VERSION >= 1929))
-// consteval is broken in MSVC before VS2019 version 16.10 and Apple clang
-// before 14.
-#    define FMT_CONSTEVAL consteval
-#    define FMT_HAS_CONSTEVAL
-#  else
-#    define FMT_CONSTEVAL
-#  endif
-#endif
+// #define FMT_CONSTEVAL consteval
+#define FMT_CONSTEVAL
 
 #ifndef FMT_USE_NONTYPE_TEMPLATE_ARGS
 #  if defined(__cpp_nontype_template_args) &&                  \
@@ -257,13 +131,6 @@
 #  endif
 #endif
 
-// Enable minimal optimizations for more compact code in debug mode.
-FMT_GCC_PRAGMA("GCC push_options")
-#if !defined(__OPTIMIZE__) && !defined(__NVCOMPILER) && !defined(__LCC__) && \
-    !defined(__CUDACC__)
-FMT_GCC_PRAGMA("GCC optimize(\"Og\")")
-#endif
-
 FMT_BEGIN_NAMESPACE
 
 // Implementations of enable_if_t and other metafunctions for older systems.
@@ -297,11 +164,7 @@
 // An enable_if helper to be used in template parameters which results in much
 // shorter symbols: https://godbolt.org/z/sWw4vP. Extra parentheses are needed
 // to workaround a bug in MSVC 2019 (see #1140 and #1186).
-#ifdef FMT_DOC
-#  define FMT_ENABLE_IF(...)
-#else
-#  define FMT_ENABLE_IF(...) fmt::enable_if_t<(__VA_ARGS__), int> = 0
-#endif
+#define FMT_ENABLE_IF(...) fmt::enable_if_t<(__VA_ARGS__), int> = 0
 
 // This is defined in core.h instead of format.h to avoid injecting in std.
 // It is a template to avoid undesirable implicit conversions to std::byte.
@@ -345,16 +208,10 @@
                                       const char* message);
 
 #ifndef FMT_ASSERT
-#  ifdef NDEBUG
-// FMT_ASSERT is not empty to avoid -Wempty-body.
-#    define FMT_ASSERT(condition, message) \
-      fmt::detail::ignore_unused((condition), (message))
-#  else
-#    define FMT_ASSERT(condition, message)                                    \
-      ((condition) /* void() fails with -Winvalid-constexpr on clang 4.0.1 */ \
-           ? (void)0                                                          \
-           : fmt::detail::assert_fail(__FILE__, __LINE__, (message)))
-#  endif
+#  define FMT_ASSERT(condition, message)                                    \
+    ((condition) /* void() fails with -Winvalid-constexpr on clang 4.0.1 */ \
+         ? (void)0                                                          \
+         : fmt::detail::assert_fail(__FILE__, __LINE__, (message)))
 #endif
 
 #if defined(FMT_USE_STRING_VIEW)
@@ -366,25 +223,11 @@
 template <typename T> struct std_string_view {};
 #endif
 
-#ifdef FMT_USE_INT128
-// Do nothing.
-#elif defined(__SIZEOF_INT128__) && !defined(__NVCC__) && \
-    !(FMT_CLANG_VERSION && FMT_MSC_VERSION)
-#  define FMT_USE_INT128 1
-using int128_opt = __int128_t;  // An optional native 128-bit integer.
-using uint128_opt = __uint128_t;
-template <typename T> inline auto convert_for_visit(T value) -> T {
-  return value;
-}
-#else
-#  define FMT_USE_INT128 0
-#endif
-#if !FMT_USE_INT128
+#define FMT_USE_INT128 0
 enum class int128_opt {};
 enum class uint128_opt {};
 // Reduce template instantiations.
 template <typename T> auto convert_for_visit(T) -> monostate { return {}; }
-#endif
 
 // Casts a nonnegative integer to unsigned.
 template <typename Int>
@@ -577,16 +420,9 @@
   uint_type,
   long_long_type,
   ulong_long_type,
-  int128_type,
-  uint128_type,
   bool_type,
   char_type,
   last_integer_type = char_type,
-  // followed by floating-point types.
-  float_type,
-  double_type,
-  long_double_type,
-  last_numeric_type = long_double_type,
   cstring_type,
   string_type,
   pointer_type,
@@ -606,13 +442,8 @@
 FMT_TYPE_CONSTANT(unsigned, uint_type);
 FMT_TYPE_CONSTANT(long long, long_long_type);
 FMT_TYPE_CONSTANT(unsigned long long, ulong_long_type);
-FMT_TYPE_CONSTANT(int128_opt, int128_type);
-FMT_TYPE_CONSTANT(uint128_opt, uint128_type);
 FMT_TYPE_CONSTANT(bool, bool_type);
 FMT_TYPE_CONSTANT(Char, char_type);
-FMT_TYPE_CONSTANT(float, float_type);
-FMT_TYPE_CONSTANT(double, double_type);
-FMT_TYPE_CONSTANT(long double, long_double_type);
 FMT_TYPE_CONSTANT(const Char*, cstring_type);
 FMT_TYPE_CONSTANT(basic_string_view<Char>, string_type);
 FMT_TYPE_CONSTANT(const void*, pointer_type);
@@ -621,7 +452,7 @@
   return t > type::none_type && t <= type::last_integer_type;
 }
 constexpr auto is_arithmetic_type(type t) -> bool {
-  return t > type::none_type && t <= type::last_numeric_type;
+  return t > type::none_type && t <= type::last_integer_type;
 }
 
 constexpr auto set(type rhs) -> int { return 1 << static_cast<int>(rhs); }
@@ -631,35 +462,23 @@
 
 // Bitsets of types.
 enum {
-  sint_set =
-      set(type::int_type) | set(type::long_long_type) | set(type::int128_type),
-  uint_set = set(type::uint_type) | set(type::ulong_long_type) |
-             set(type::uint128_type),
+  sint_set = set(type::int_type) | set(type::long_long_type),
+  uint_set = set(type::uint_type) | set(type::ulong_long_type),
   bool_set = set(type::bool_type),
   char_set = set(type::char_type),
-  float_set = set(type::float_type) | set(type::double_type) |
-              set(type::long_double_type),
   string_set = set(type::string_type),
   cstring_set = set(type::cstring_type),
   pointer_set = set(type::pointer_type)
 };
 
-// DEPRECATED!
-FMT_NORETURN FMT_API void throw_format_error(const char* message);
-
 struct error_handler {
   constexpr error_handler() = default;
 
   // This function is intentionally not constexpr to give a compile-time error.
-  FMT_NORETURN void on_error(const char* message) {
-    throw_format_error(message);
-  }
+  FMT_NORETURN void on_error(const char* message) { (void)(message); }
 };
 }  // namespace detail
 
-/** Throws ``format_error`` with a given message. */
-using detail::throw_format_error;
-
 /** String's character type. */
 template <typename S> using char_t = typename detail::char_t_impl<S>::type;
 
@@ -710,8 +529,7 @@
    */
   FMT_CONSTEXPR auto next_arg_id() -> int {
     if (next_arg_id_ < 0) {
-      detail::throw_format_error(
-          "cannot switch from manual to automatic argument indexing");
+      (void)("cannot switch from manual to automatic argument indexing");
       return 0;
     }
     int id = next_arg_id_++;
@@ -725,8 +543,7 @@
    */
   FMT_CONSTEXPR void check_arg_id(int id) {
     if (next_arg_id_ > 0) {
-      detail::throw_format_error(
-          "cannot switch from automatic to manual argument indexing");
+      (void)("cannot switch from automatic to manual argument indexing");
       return;
     }
     next_arg_id_ = -1;
@@ -759,13 +576,13 @@
 
   FMT_CONSTEXPR auto next_arg_id() -> int {
     int id = base::next_arg_id();
-    if (id >= num_args_) throw_format_error("argument not found");
+    if (id >= num_args_) (void)("argument not found");
     return id;
   }
 
   FMT_CONSTEXPR void check_arg_id(int id) {
     base::check_arg_id(id);
-    if (id >= num_args_) throw_format_error("argument not found");
+    if (id >= num_args_) (void)("argument not found");
   }
   using base::check_arg_id;
 
@@ -773,7 +590,7 @@
     detail::ignore_unused(arg_id);
 #if !defined(__LCC__)
     if (arg_id < num_args_ && types_ && !is_integral_type(types_[arg_id]))
-      throw_format_error("width/precision is not integer");
+      (void)("width/precision is not integer");
 #endif
   }
 };
@@ -1063,7 +880,7 @@
       (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200)) {
     using context = detail::compile_parse_context<Char>;
     if (id >= static_cast<context*>(this)->num_args())
-      detail::throw_format_error("argument not found");
+      (void)("argument not found");
   }
 }
 
@@ -1708,20 +1525,10 @@
     return vis(arg.value_.long_long_value);
   case detail::type::ulong_long_type:
     return vis(arg.value_.ulong_long_value);
-  case detail::type::int128_type:
-    return vis(detail::convert_for_visit(arg.value_.int128_value));
-  case detail::type::uint128_type:
-    return vis(detail::convert_for_visit(arg.value_.uint128_value));
   case detail::type::bool_type:
     return vis(arg.value_.bool_value);
   case detail::type::char_type:
     return vis(arg.value_.char_value);
-  case detail::type::float_type:
-    return vis(arg.value_.float_value);
-  case detail::type::double_type:
-    return vis(arg.value_.double_value);
-  case detail::type::long_double_type:
-    return vis(arg.value_.long_double_value);
   case detail::type::cstring_type:
     return vis(arg.value_.string.data);
   case detail::type::string_type:
@@ -2008,18 +1815,19 @@
 // in namespaces instead (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414).
 // Additionally, if an underlying type is specified, older gcc incorrectly warns
 // that the type is too small. Both bugs are fixed in gcc 9.3.
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 903
-#  define FMT_ENUM_UNDERLYING_TYPE(type)
-#else
-#  define FMT_ENUM_UNDERLYING_TYPE(type) : type
-#endif
+#define FMT_ENUM_UNDERLYING_TYPE(type) : type
 namespace align {
-enum type FMT_ENUM_UNDERLYING_TYPE(unsigned char){none, left, right, center,
-                                                  numeric};
+enum type FMT_ENUM_UNDERLYING_TYPE(unsigned char) {
+  none,
+  left,
+  right,
+  center,
+  numeric
+};
 }
 using align_t = align::type;
 namespace sign {
-enum type FMT_ENUM_UNDERLYING_TYPE(unsigned char){none, minus, plus, space};
+enum type FMT_ENUM_UNDERLYING_TYPE(unsigned char) { none, minus, plus, space };
 }
 using sign_t = sign::type;
 
@@ -2219,13 +2027,13 @@
     else
       ++begin;
     if (begin == end || (*begin != '}' && *begin != ':'))
-      throw_format_error("invalid format string");
+      (void)("invalid format string");
     else
       handler.on_index(index);
     return begin;
   }
   if (!is_name_start(c)) {
-    throw_format_error("invalid format string");
+    (void)("invalid format string");
     return begin;
   }
   auto it = begin;
@@ -2278,13 +2086,13 @@
     if (val != -1)
       value = val;
     else
-      throw_format_error("number is too big");
+      (void)("number is too big");
   } else if (*begin == '{') {
     ++begin;
     auto handler = dynamic_spec_id_handler<Char>{ctx, ref};
     if (begin != end) begin = parse_arg_id(begin, end, handler);
     if (begin != end && *begin == '}') return ++begin;
-    throw_format_error("invalid format string");
+    (void)("invalid format string");
   }
   return begin;
 }
@@ -2296,7 +2104,7 @@
     -> const Char* {
   ++begin;
   if (begin == end || *begin == '}') {
-    throw_format_error("invalid precision");
+    (void)("invalid precision");
     return begin;
   }
   return parse_dynamic_spec(begin, end, value, ref, ctx);
@@ -2321,8 +2129,7 @@
   struct {
     state current_state = state::start;
     FMT_CONSTEXPR void operator()(state s, bool valid = true) {
-      if (current_state >= s || !valid)
-        throw_format_error("invalid format specifier");
+      if (current_state >= s || !valid) (void)("invalid format specifier");
       current_state = s;
     }
   } enter_state;
@@ -2337,7 +2144,7 @@
     FMT_CONSTEXPR auto operator()(pres pres_type, int set) -> const Char* {
       if (!in(arg_type, set)) {
         if (arg_type == type::none_type) return begin;
-        throw_format_error("invalid format specifier");
+        (void)("invalid format specifier");
       }
       specs.type = pres_type;
       return begin + 1;
@@ -2357,7 +2164,7 @@
     case '-':
     case ' ':
       if (arg_type == type::none_type) return begin;
-      enter_state(state::sign, in(arg_type, sint_set | float_set));
+      enter_state(state::sign, in(arg_type, sint_set));
       switch (c) {
       case '+':
         specs.sign = sign::plus;
@@ -2381,7 +2188,7 @@
       enter_state(state::zero);
       if (!is_arithmetic_type(arg_type)) {
         if (arg_type == type::none_type) return begin;
-        throw_format_error("format specifier requires numeric argument");
+        (void)("format specifier requires numeric argument");
       }
       if (specs.align == align::none) {
         // Ignore 0 if align is specified for compatibility with std::format.
@@ -2405,8 +2212,7 @@
       break;
     case '.':
       if (arg_type == type::none_type) return begin;
-      enter_state(state::precision,
-                  in(arg_type, float_set | string_set | cstring_set));
+      enter_state(state::precision, in(arg_type, string_set | cstring_set));
       begin = parse_precision(begin, end, specs.precision, specs.precision_ref,
                               ctx);
       break;
@@ -2428,25 +2234,8 @@
       return parse_presentation_type(pres::bin_lower, integral_set);
     case 'B':
       return parse_presentation_type(pres::bin_upper, integral_set);
-    case 'a':
-      return parse_presentation_type(pres::hexfloat_lower, float_set);
-    case 'A':
-      return parse_presentation_type(pres::hexfloat_upper, float_set);
-    case 'e':
-      return parse_presentation_type(pres::exp_lower, float_set);
-    case 'E':
-      return parse_presentation_type(pres::exp_upper, float_set);
-    case 'f':
-      return parse_presentation_type(pres::fixed_lower, float_set);
-    case 'F':
-      return parse_presentation_type(pres::fixed_upper, float_set);
-    case 'g':
-      return parse_presentation_type(pres::general_lower, float_set);
-    case 'G':
-      return parse_presentation_type(pres::general_upper, float_set);
     case 'c':
-      if (arg_type == type::bool_type)
-        throw_format_error("invalid format specifier");
+      if (arg_type == type::bool_type) (void)("invalid format specifier");
       return parse_presentation_type(pres::chr, integral_set);
     case 's':
       return parse_presentation_type(pres::string,
@@ -2463,11 +2252,11 @@
       // Parse fill and alignment.
       auto fill_end = begin + code_point_length(begin);
       if (end - fill_end <= 0) {
-        throw_format_error("invalid format specifier");
+        (void)("invalid format specifier");
         return begin;
       }
       if (*begin == '{') {
-        throw_format_error("invalid fill character '{'");
+        (void)("invalid fill character '{'");
         return begin;
       }
       auto align = parse_align(to_ascii(*fill_end));
@@ -2607,7 +2396,7 @@
     return false;
   }
   if (specs.align == align::numeric || specs.sign != sign::none || specs.alt)
-    throw_format_error("invalid format specifier for char");
+    (void)("invalid format specifier for char");
   return true;
 }
 
@@ -2684,9 +2473,7 @@
     return id >= 0 && id < num_args ? parse_funcs_[id](context_) : begin;
   }
 
-  FMT_CONSTEXPR void on_error(const char* message) {
-    throw_format_error(message);
-  }
+  FMT_CONSTEXPR void on_error(const char* message) { (void)(message); }
 };
 
 // Reports a compile-time error if S is not a valid format string.
@@ -2720,11 +2507,6 @@
 template <typename Char>
 void vformat_to(buffer<Char>& buf, basic_string_view<Char> fmt,
                 typename vformat_args<Char>::type args, locale_ref loc = {});
-
-FMT_API void vprint_mojibake(std::FILE*, string_view, format_args);
-#ifndef _WIN32
-inline void vprint_mojibake(std::FILE*, string_view, format_args) {}
-#endif
 }  // namespace detail
 
 FMT_BEGIN_EXPORT
@@ -2905,49 +2687,10 @@
 }
 
 FMT_API void vprint(string_view fmt, format_args args);
-FMT_API void vprint(std::FILE* f, string_view fmt, format_args args);
-
-/**
-  \rst
-  Formats ``args`` according to specifications in ``fmt`` and writes the output
-  to ``stdout``.
-
-  **Example**::
-
-    fmt::print("Elapsed time: {0:.2f} seconds", 1.23);
-  \endrst
- */
 template <typename... T>
 FMT_INLINE void print(format_string<T...> fmt, T&&... args) {
   const auto& vargs = fmt::make_format_args(args...);
-  return detail::is_utf8() ? vprint(fmt, vargs)
-                           : detail::vprint_mojibake(stdout, fmt, vargs);
-}
-
-/**
-  \rst
-  Formats ``args`` according to specifications in ``fmt`` and writes the
-  output to the file ``f``.
-
-  **Example**::
-
-    fmt::print(stderr, "Don't {}!", "panic");
-  \endrst
- */
-template <typename... T>
-FMT_INLINE void print(std::FILE* f, format_string<T...> fmt, T&&... args) {
-  const auto& vargs = fmt::make_format_args(args...);
-  return detail::is_utf8() ? vprint(f, fmt, vargs)
-                           : detail::vprint_mojibake(f, fmt, vargs);
-}
-
-/**
-  Formats ``args`` according to specifications in ``fmt`` and writes the
-  output to the file ``f`` followed by a newline.
- */
-template <typename... T>
-FMT_INLINE void println(std::FILE* f, format_string<T...> fmt, T&&... args) {
-  return fmt::print(f, "{}\n", fmt::format(fmt, std::forward<T>(args)...));
+  vprint(fmt, vargs);
 }
 
 /**
@@ -2960,7 +2703,6 @@
 }
 
 FMT_END_EXPORT
-FMT_GCC_PRAGMA("GCC pop_options")
 FMT_END_NAMESPACE
 
 #ifdef FMT_HEADER_ONLY
diff --color -Naur fmt-original/include/fmt/format.h fmt-10.2.0/include/fmt/format.h
--- fmt-original/include/fmt/format.h	2025-07-16 22:36:59.478481567 +0200
+++ fmt-10.2.0/include/fmt/format.h	2025-07-16 22:38:03.064889675 +0200
@@ -33,14 +33,11 @@
 #ifndef FMT_FORMAT_H_
 #define FMT_FORMAT_H_
 
-#include <cmath>             // std::signbit
 #include <cstdint>           // uint32_t
 #include <cstring>           // std::memcpy
 #include <initializer_list>  // std::initializer_list
 #include <limits>            // std::numeric_limits
 #include <memory>            // std::uninitialized_copy
-#include <stdexcept>         // std::runtime_error
-#include <system_error>      // std::system_error
 
 #ifdef __cpp_lib_bit_cast
 #  include <bit>  // std::bit_cast
@@ -83,9 +80,6 @@
 #  if FMT_CPLUSPLUS >= 202002L
 #    if FMT_HAS_CPP_ATTRIBUTE(no_unique_address)
 #      define FMT_NO_UNIQUE_ADDRESS [[no_unique_address]]
-// VS2019 v16.10 and later except clang-cl (https://reviews.llvm.org/D110485)
-#    elif (FMT_MSC_VERSION >= 1929) && !FMT_CLANG_VERSION
-#      define FMT_NO_UNIQUE_ADDRESS [[msvc::no_unique_address]]
 #    endif
 #  endif
 #endif
@@ -106,49 +100,18 @@
 #  define FMT_HAS_BUILTIN(x) 0
 #endif
 
-#if FMT_GCC_VERSION || FMT_CLANG_VERSION
 #  define FMT_NOINLINE __attribute__((noinline))
-#else
-#  define FMT_NOINLINE
-#endif
 
 #ifndef FMT_THROW
-#  if FMT_EXCEPTIONS
-#    if FMT_MSC_VERSION || defined(__NVCC__)
-FMT_BEGIN_NAMESPACE
-namespace detail {
-template <typename Exception> inline void do_throw(const Exception& x) {
-  // Silence unreachable code warnings in MSVC and NVCC because these
-  // are nearly impossible to fix in a generic code.
-  volatile bool b = true;
-  if (b) throw x;
-}
-}  // namespace detail
-FMT_END_NAMESPACE
-#      define FMT_THROW(x) detail::do_throw(x)
-#    else
-#      define FMT_THROW(x) throw x
-#    endif
-#  else
 #    define FMT_THROW(x) \
-      ::fmt::detail::assert_fail(__FILE__, __LINE__, (x).what())
-#  endif
+      ::fmt::detail::assert_fail(__FILE__, __LINE__, (x))
 #endif
 
-#if FMT_EXCEPTIONS
-#  define FMT_TRY try
-#  define FMT_CATCH(x) catch (x)
-#else
 #  define FMT_TRY if (true)
 #  define FMT_CATCH(x) if (false)
-#endif
 
 #ifndef FMT_MAYBE_UNUSED
-#  if FMT_HAS_CPP17_ATTRIBUTE(maybe_unused)
 #    define FMT_MAYBE_UNUSED [[maybe_unused]]
-#  else
-#    define FMT_MAYBE_UNUSED
-#  endif
 #endif
 
 #ifndef FMT_USE_USER_DEFINED_LITERALS
@@ -156,13 +119,7 @@
 //
 // GCC before 4.9 requires a space in `operator"" _a` which is invalid in later
 // compiler versions.
-#  if (FMT_HAS_FEATURE(cxx_user_literals) || FMT_GCC_VERSION >= 409 || \
-       FMT_MSC_VERSION >= 1900) &&                                     \
-      (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= /* UDL feature */ 480)
 #    define FMT_USE_USER_DEFINED_LITERALS 1
-#  else
-#    define FMT_USE_USER_DEFINED_LITERALS 0
-#  endif
 #endif
 
 // Defining FMT_REDUCE_INT_INSTANTIATIONS to 1, will reduce the number of
@@ -201,81 +158,6 @@
 #  include <intrin.h>  // _BitScanReverse[64], _BitScanForward[64], _umul128
 #endif
 
-// Some compilers masquerade as both MSVC and GCC-likes or otherwise support
-// __builtin_clz and __builtin_clzll, so only define FMT_BUILTIN_CLZ using the
-// MSVC intrinsics if the clz and clzll builtins are not available.
-#if FMT_MSC_VERSION && !defined(FMT_BUILTIN_CLZLL) && \
-    !defined(FMT_BUILTIN_CTZLL)
-FMT_BEGIN_NAMESPACE
-namespace detail {
-// Avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning.
-#  if !defined(__clang__)
-#    pragma intrinsic(_BitScanForward)
-#    pragma intrinsic(_BitScanReverse)
-#    if defined(_WIN64)
-#      pragma intrinsic(_BitScanForward64)
-#      pragma intrinsic(_BitScanReverse64)
-#    endif
-#  endif
-
-inline auto clz(uint32_t x) -> int {
-  unsigned long r = 0;
-  _BitScanReverse(&r, x);
-  FMT_ASSERT(x != 0, "");
-  // Static analysis complains about using uninitialized data
-  // "r", but the only way that can happen is if "x" is 0,
-  // which the callers guarantee to not happen.
-  FMT_MSC_WARNING(suppress : 6102)
-  return 31 ^ static_cast<int>(r);
-}
-#  define FMT_BUILTIN_CLZ(n) detail::clz(n)
-
-inline auto clzll(uint64_t x) -> int {
-  unsigned long r = 0;
-#  ifdef _WIN64
-  _BitScanReverse64(&r, x);
-#  else
-  // Scan the high 32 bits.
-  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32)))
-    return 63 ^ static_cast<int>(r + 32);
-  // Scan the low 32 bits.
-  _BitScanReverse(&r, static_cast<uint32_t>(x));
-#  endif
-  FMT_ASSERT(x != 0, "");
-  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
-  return 63 ^ static_cast<int>(r);
-}
-#  define FMT_BUILTIN_CLZLL(n) detail::clzll(n)
-
-inline auto ctz(uint32_t x) -> int {
-  unsigned long r = 0;
-  _BitScanForward(&r, x);
-  FMT_ASSERT(x != 0, "");
-  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
-  return static_cast<int>(r);
-}
-#  define FMT_BUILTIN_CTZ(n) detail::ctz(n)
-
-inline auto ctzll(uint64_t x) -> int {
-  unsigned long r = 0;
-  FMT_ASSERT(x != 0, "");
-  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
-#  ifdef _WIN64
-  _BitScanForward64(&r, x);
-#  else
-  // Scan the low 32 bits.
-  if (_BitScanForward(&r, static_cast<uint32_t>(x))) return static_cast<int>(r);
-  // Scan the high 32 bits.
-  _BitScanForward(&r, static_cast<uint32_t>(x >> 32));
-  r += 32;
-#  endif
-  return static_cast<int>(r);
-}
-#  define FMT_BUILTIN_CTZLL(n) detail::ctzll(n)
-}  // namespace detail
-FMT_END_NAMESPACE
-#endif
-
 FMT_BEGIN_NAMESPACE
 namespace detail {
 
@@ -293,11 +175,6 @@
   }
 };
 
-#if FMT_CPLUSPLUS < 201703L
-template <typename CharT, CharT... C>
-constexpr CharT string_literal<CharT, C...>::value[sizeof...(C)];
-#endif
-
 // Implementation of std::bit_cast for pre-C++20.
 template <typename To, typename From, FMT_ENABLE_IF(sizeof(To) == sizeof(From))>
 FMT_CONSTEXPR20 auto bit_cast(const From& from) -> To {
@@ -781,38 +658,12 @@
                   !std::is_same<T, char>::value &&
                   !std::is_same<T, wchar_t>::value>;
 
-#ifndef FMT_USE_FLOAT
-#  define FMT_USE_FLOAT 1
-#endif
-#ifndef FMT_USE_DOUBLE
-#  define FMT_USE_DOUBLE 1
-#endif
-#ifndef FMT_USE_LONG_DOUBLE
-#  define FMT_USE_LONG_DOUBLE 1
-#endif
-
 #ifndef FMT_USE_FLOAT128
-#  ifdef __clang__
-// Clang emulates GCC, so it has to appear early.
-#    if FMT_HAS_INCLUDE(<quadmath.h>)
-#      define FMT_USE_FLOAT128 1
-#    endif
-#  elif defined(__GNUC__)
 // GNU C++:
-#    if defined(_GLIBCXX_USE_FLOAT128) && !defined(__STRICT_ANSI__)
-#      define FMT_USE_FLOAT128 1
-#    endif
-#  endif
-#  ifndef FMT_USE_FLOAT128
 #    define FMT_USE_FLOAT128 0
-#  endif
 #endif
 
-#if FMT_USE_FLOAT128
-using float128 = __float128;
-#else
 using float128 = void;
-#endif
 template <typename T> using is_float128 = std::is_same<T, float128>;
 
 template <typename T>
@@ -996,25 +847,11 @@
 struct is_contiguous<basic_memory_buffer<T, SIZE, Allocator>> : std::true_type {
 };
 
-FMT_END_EXPORT
-namespace detail {
-FMT_API auto write_console(int fd, string_view text) -> bool;
-FMT_API void print(std::FILE*, string_view);
-}  // namespace detail
-
-FMT_BEGIN_EXPORT
-
 // Suppress a misleading warning in older versions of clang.
 #if FMT_CLANG_VERSION
 #  pragma clang diagnostic ignored "-Wweak-vtables"
 #endif
 
-/** An error reported from a formatting function. */
-class FMT_SO_VISIBILITY("default") format_error : public std::runtime_error {
- public:
-  using std::runtime_error::runtime_error;
-};
-
 namespace detail_exported {
 #if FMT_USE_NONTYPE_TEMPLATE_ARGS
 template <typename Char, size_t N> struct fixed_string {
@@ -1041,51 +878,6 @@
 }
 }  // namespace detail_exported
 
-class loc_value {
- private:
-  basic_format_arg<format_context> value_;
-
- public:
-  template <typename T, FMT_ENABLE_IF(!detail::is_float128<T>::value)>
-  loc_value(T value) : value_(detail::make_arg<format_context>(value)) {}
-
-  template <typename T, FMT_ENABLE_IF(detail::is_float128<T>::value)>
-  loc_value(T) {}
-
-  template <typename Visitor> auto visit(Visitor&& vis) -> decltype(vis(0)) {
-    return visit_format_arg(vis, value_);
-  }
-};
-
-// A locale facet that formats values in UTF-8.
-// It is parameterized on the locale to avoid the heavy <locale> include.
-template <typename Locale> class format_facet : public Locale::facet {
- private:
-  std::string separator_;
-  std::string grouping_;
-  std::string decimal_point_;
-
- protected:
-  virtual auto do_put(appender out, loc_value val,
-                      const format_specs<>& specs) const -> bool;
-
- public:
-  static FMT_API typename Locale::id id;
-
-  explicit format_facet(Locale& loc);
-  explicit format_facet(string_view sep = "",
-                        std::initializer_list<unsigned char> g = {3},
-                        std::string decimal_point = ".")
-      : separator_(sep.data(), sep.size()),
-        grouping_(g.begin(), g.end()),
-        decimal_point_(decimal_point) {}
-
-  auto put(appender out, loc_value val, const format_specs<>& specs) const
-      -> bool {
-    return do_put(out, val, specs);
-  }
-};
-
 namespace detail {
 
 // Returns true if value is negative, false otherwise.
@@ -1101,10 +893,7 @@
 
 template <typename T>
 FMT_CONSTEXPR auto is_supported_floating_point(T) -> bool {
-  if (std::is_same<T, float>()) return FMT_USE_FLOAT;
-  if (std::is_same<T, double>()) return FMT_USE_DOUBLE;
-  if (std::is_same<T, long double>()) return FMT_USE_LONG_DOUBLE;
-  return true;
+  return false;
 }
 
 // Smallest of uint32_t, uint64_t, uint128_t that is large enough to
@@ -1250,23 +1039,6 @@
 template <> constexpr auto digits10<int128_opt>() noexcept -> int { return 38; }
 template <> constexpr auto digits10<uint128_t>() noexcept -> int { return 38; }
 
-template <typename Char> struct thousands_sep_result {
-  std::string grouping;
-  Char thousands_sep;
-};
-
-template <typename Char>
-FMT_API auto thousands_sep_impl(locale_ref loc) -> thousands_sep_result<Char>;
-template <typename Char>
-inline auto thousands_sep(locale_ref loc) -> thousands_sep_result<Char> {
-  auto result = thousands_sep_impl<char>(loc);
-  return {result.grouping, Char(result.thousands_sep)};
-}
-template <>
-inline auto thousands_sep(locale_ref loc) -> thousands_sep_result<wchar_t> {
-  return thousands_sep_impl<wchar_t>(loc);
-}
-
 template <typename Char>
 FMT_API auto decimal_point_impl(locale_ref loc) -> Char;
 template <typename Char> inline auto decimal_point(locale_ref loc) -> Char {
@@ -1390,8 +1162,8 @@
     static_assert(sizeof(WChar) == 2 || sizeof(WChar) == 4,
                   "Expect utf16 or utf32");
     if (!convert(s, policy))
-      FMT_THROW(std::runtime_error(sizeof(WChar) == 2 ? "invalid utf16"
-                                                      : "invalid utf32"));
+      FMT_THROW(sizeof(WChar) == 2 ? "invalid utf16"
+                                                      : "invalid utf32");
   }
   operator string_view() const { return string_view(&buffer_[0], size()); }
   auto size() const -> size_t { return buffer_.size() - 1; }
@@ -1445,123 +1217,6 @@
   }
 };
 
-// Computes 128-bit result of multiplication of two 64-bit unsigned integers.
-inline auto umul128(uint64_t x, uint64_t y) noexcept -> uint128_fallback {
-#if FMT_USE_INT128
-  auto p = static_cast<uint128_opt>(x) * static_cast<uint128_opt>(y);
-  return {static_cast<uint64_t>(p >> 64), static_cast<uint64_t>(p)};
-#elif defined(_MSC_VER) && defined(_M_X64)
-  auto hi = uint64_t();
-  auto lo = _umul128(x, y, &hi);
-  return {hi, lo};
-#else
-  const uint64_t mask = static_cast<uint64_t>(max_value<uint32_t>());
-
-  uint64_t a = x >> 32;
-  uint64_t b = x & mask;
-  uint64_t c = y >> 32;
-  uint64_t d = y & mask;
-
-  uint64_t ac = a * c;
-  uint64_t bc = b * c;
-  uint64_t ad = a * d;
-  uint64_t bd = b * d;
-
-  uint64_t intermediate = (bd >> 32) + (ad & mask) + (bc & mask);
-
-  return {ac + (intermediate >> 32) + (ad >> 32) + (bc >> 32),
-          (intermediate << 32) + (bd & mask)};
-#endif
-}
-
-namespace dragonbox {
-// Computes floor(log10(pow(2, e))) for e in [-2620, 2620] using the method from
-// https://fmt.dev/papers/Dragonbox.pdf#page=28, section 6.1.
-inline auto floor_log10_pow2(int e) noexcept -> int {
-  FMT_ASSERT(e <= 2620 && e >= -2620, "too large exponent");
-  static_assert((-1 >> 1) == -1, "right shift is not arithmetic");
-  return (e * 315653) >> 20;
-}
-
-inline auto floor_log2_pow10(int e) noexcept -> int {
-  FMT_ASSERT(e <= 1233 && e >= -1233, "too large exponent");
-  return (e * 1741647) >> 19;
-}
-
-// Computes upper 64 bits of multiplication of two 64-bit unsigned integers.
-inline auto umul128_upper64(uint64_t x, uint64_t y) noexcept -> uint64_t {
-#if FMT_USE_INT128
-  auto p = static_cast<uint128_opt>(x) * static_cast<uint128_opt>(y);
-  return static_cast<uint64_t>(p >> 64);
-#elif defined(_MSC_VER) && defined(_M_X64)
-  return __umulh(x, y);
-#else
-  return umul128(x, y).high();
-#endif
-}
-
-// Computes upper 128 bits of multiplication of a 64-bit unsigned integer and a
-// 128-bit unsigned integer.
-inline auto umul192_upper128(uint64_t x, uint128_fallback y) noexcept
-    -> uint128_fallback {
-  uint128_fallback r = umul128(x, y.high());
-  r += umul128_upper64(x, y.low());
-  return r;
-}
-
-FMT_API auto get_cached_power(int k) noexcept -> uint128_fallback;
-
-// Type-specific information that Dragonbox uses.
-template <typename T, typename Enable = void> struct float_info;
-
-template <> struct float_info<float> {
-  using carrier_uint = uint32_t;
-  static const int exponent_bits = 8;
-  static const int kappa = 1;
-  static const int big_divisor = 100;
-  static const int small_divisor = 10;
-  static const int min_k = -31;
-  static const int max_k = 46;
-  static const int shorter_interval_tie_lower_threshold = -35;
-  static const int shorter_interval_tie_upper_threshold = -35;
-};
-
-template <> struct float_info<double> {
-  using carrier_uint = uint64_t;
-  static const int exponent_bits = 11;
-  static const int kappa = 2;
-  static const int big_divisor = 1000;
-  static const int small_divisor = 100;
-  static const int min_k = -292;
-  static const int max_k = 341;
-  static const int shorter_interval_tie_lower_threshold = -77;
-  static const int shorter_interval_tie_upper_threshold = -77;
-};
-
-// An 80- or 128-bit floating point number.
-template <typename T>
-struct float_info<T, enable_if_t<std::numeric_limits<T>::digits == 64 ||
-                                 std::numeric_limits<T>::digits == 113 ||
-                                 is_float128<T>::value>> {
-  using carrier_uint = detail::uint128_t;
-  static const int exponent_bits = 15;
-};
-
-// A double-double floating point number.
-template <typename T>
-struct float_info<T, enable_if_t<is_double_double<T>::value>> {
-  using carrier_uint = detail::uint128_t;
-};
-
-template <typename T> struct decimal_fp {
-  using significand_type = typename float_info<T>::carrier_uint;
-  significand_type significand;
-  int exponent;
-};
-
-template <typename T> FMT_API auto to_decimal(T x) noexcept -> decimal_fp<T>;
-}  // namespace dragonbox
-
 // Returns true iff Float has the implicit bit which is not stored.
 template <typename Float> constexpr auto has_implicit_bit() -> bool {
   // An 80-bit FP number has a 64-bit significand an no implicit bit.
@@ -1577,19 +1232,6 @@
                                  (has_implicit_bit<Float>() ? 1 : 0));
 }
 
-template <typename Float>
-constexpr auto exponent_mask() ->
-    typename dragonbox::float_info<Float>::carrier_uint {
-  using float_uint = typename dragonbox::float_info<Float>::carrier_uint;
-  return ((float_uint(1) << dragonbox::float_info<Float>::exponent_bits) - 1)
-         << num_significand_bits<Float>();
-}
-template <typename Float> constexpr auto exponent_bias() -> int {
-  // std::numeric_limits may not support __float128.
-  return is_float128<Float>() ? 16383
-                              : std::numeric_limits<Float>::max_exponent - 1;
-}
-
 // Writes the exponent exp in the form "[+-]d{2,3}" to buffer.
 template <typename Char, typename It>
 FMT_CONSTEXPR auto write_exponent(int exp, It it) -> It {
@@ -1612,73 +1254,6 @@
   return it;
 }
 
-// A floating-point number f * pow(2, e) where F is an unsigned type.
-template <typename F> struct basic_fp {
-  F f;
-  int e;
-
-  static constexpr const int num_significand_bits =
-      static_cast<int>(sizeof(F) * num_bits<unsigned char>());
-
-  constexpr basic_fp() : f(0), e(0) {}
-  constexpr basic_fp(uint64_t f_val, int e_val) : f(f_val), e(e_val) {}
-
-  // Constructs fp from an IEEE754 floating-point number.
-  template <typename Float> FMT_CONSTEXPR basic_fp(Float n) { assign(n); }
-
-  // Assigns n to this and return true iff predecessor is closer than successor.
-  template <typename Float, FMT_ENABLE_IF(!is_double_double<Float>::value)>
-  FMT_CONSTEXPR auto assign(Float n) -> bool {
-    static_assert(std::numeric_limits<Float>::digits <= 113, "unsupported FP");
-    // Assume Float is in the format [sign][exponent][significand].
-    using carrier_uint = typename dragonbox::float_info<Float>::carrier_uint;
-    const auto num_float_significand_bits =
-        detail::num_significand_bits<Float>();
-    const auto implicit_bit = carrier_uint(1) << num_float_significand_bits;
-    const auto significand_mask = implicit_bit - 1;
-    auto u = bit_cast<carrier_uint>(n);
-    f = static_cast<F>(u & significand_mask);
-    auto biased_e = static_cast<int>((u & exponent_mask<Float>()) >>
-                                     num_float_significand_bits);
-    // The predecessor is closer if n is a normalized power of 2 (f == 0)
-    // other than the smallest normalized number (biased_e > 1).
-    auto is_predecessor_closer = f == 0 && biased_e > 1;
-    if (biased_e == 0)
-      biased_e = 1;  // Subnormals use biased exponent 1 (min exponent).
-    else if (has_implicit_bit<Float>())
-      f += static_cast<F>(implicit_bit);
-    e = biased_e - exponent_bias<Float>() - num_float_significand_bits;
-    if (!has_implicit_bit<Float>()) ++e;
-    return is_predecessor_closer;
-  }
-
-  template <typename Float, FMT_ENABLE_IF(is_double_double<Float>::value)>
-  FMT_CONSTEXPR auto assign(Float n) -> bool {
-    static_assert(std::numeric_limits<double>::is_iec559, "unsupported FP");
-    return assign(static_cast<double>(n));
-  }
-};
-
-using fp = basic_fp<unsigned long long>;
-
-// Normalizes the value converted from double and multiplied by (1 << SHIFT).
-template <int SHIFT = 0, typename F>
-FMT_CONSTEXPR auto normalize(basic_fp<F> value) -> basic_fp<F> {
-  // Handle subnormals.
-  const auto implicit_bit = F(1) << num_significand_bits<double>();
-  const auto shifted_implicit_bit = implicit_bit << SHIFT;
-  while ((value.f & shifted_implicit_bit) == 0) {
-    value.f <<= 1;
-    --value.e;
-  }
-  // Subtract 1 to account for hidden bit.
-  const auto offset = basic_fp<F>::num_significand_bits -
-                      num_significand_bits<double>() - SHIFT - 1;
-  value.f <<= offset;
-  value.e -= offset;
-  return value;
-}
-
 // Computes lhs * rhs / pow(2, 64) rounded to nearest with half-up tie breaking.
 FMT_CONSTEXPR inline auto multiply(uint64_t lhs, uint64_t rhs) -> uint64_t {
 #if FMT_USE_INT128
@@ -1697,19 +1272,10 @@
 #endif
 }
 
-FMT_CONSTEXPR inline auto operator*(fp x, fp y) -> fp {
-  return {multiply(x.f, y.f), x.e + y.e + 64};
-}
-
 template <typename T, bool doublish = num_bits<T>() == num_bits<double>()>
 using convert_float_result =
     conditional_t<std::is_same<T, float>::value || doublish, double, T>;
 
-template <typename T>
-constexpr auto convert_float(T value) -> convert_float_result<T> {
-  return static_cast<convert_float_result<T>>(value);
-}
-
 template <typename OutputIt, typename Char>
 FMT_NOINLINE FMT_CONSTEXPR auto fill(OutputIt it, size_t n,
                                      const fill_t<Char>& fill) -> OutputIt {
@@ -2120,7 +1686,7 @@
   case presentation_type::chr:
     return write_char(out, static_cast<Char>(value), specs);
   default:
-    throw_format_error("invalid format specifier");
+    (void)("invalid format specifier");
   }
 
   unsigned size = (prefix != 0 ? prefix >> 24 : 0) + to_unsigned(num_digits) +
@@ -2133,15 +1699,6 @@
       });
 }
 
-// Writes a localized value.
-FMT_API auto write_loc(appender out, loc_value value,
-                       const format_specs<>& specs, locale_ref loc) -> bool;
-template <typename OutputIt, typename Char>
-inline auto write_loc(OutputIt, loc_value, const format_specs<Char>&,
-                      locale_ref) -> bool {
-  return false;
-}
-
 template <typename UInt> struct write_int_arg {
   UInt abs_value;
   unsigned prefix;
@@ -2236,7 +1793,7 @@
   case presentation_type::chr:
     return write_char(out, static_cast<Char>(abs_value), specs);
   default:
-    throw_format_error("invalid format specifier");
+    (void)("invalid format specifier");
   }
   return out;
 }
@@ -2253,7 +1810,6 @@
 FMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,
                                     const format_specs<Char>& specs,
                                     locale_ref loc) -> OutputIt {
-  if (specs.localized && write_loc(out, value, specs, loc)) return out;
   return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
                             loc);
 }
@@ -2265,7 +1821,6 @@
 FMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,
                                     const format_specs<Char>& specs,
                                     locale_ref loc) -> OutputIt {
-  if (specs.localized && write_loc(out, value, specs, loc)) return out;
   return write_int(out, make_write_int_arg(value, specs.sign), specs, loc);
 }
 
@@ -2343,7 +1898,7 @@
     -> OutputIt {
   if (specs.type == presentation_type::pointer)
     return write_ptr<Char>(out, bit_cast<uintptr_t>(s), &specs);
-  if (!s) throw_format_error("string pointer is null");
+  if (!s) (void)("string pointer is null");
   return write(out, basic_string_view<Char>(s), specs, {});
 }
 
@@ -2394,7 +1949,7 @@
         auto c = *begin;
         if (c == '}') return begin;
         if (c == '{') {
-          throw_format_error("invalid fill character '{'");
+          (void)("invalid fill character '{'");
           return begin;
         }
         specs.fill = {begin, to_unsigned(p - begin)};
@@ -2430,49 +1985,6 @@
   bool showpoint : 1;
 };
 
-template <typename Char>
-FMT_CONSTEXPR auto parse_float_type_spec(const format_specs<Char>& specs)
-    -> float_specs {
-  auto result = float_specs();
-  result.showpoint = specs.alt;
-  result.locale = specs.localized;
-  switch (specs.type) {
-  case presentation_type::none:
-    result.format = float_format::general;
-    break;
-  case presentation_type::general_upper:
-    result.upper = true;
-    FMT_FALLTHROUGH;
-  case presentation_type::general_lower:
-    result.format = float_format::general;
-    break;
-  case presentation_type::exp_upper:
-    result.upper = true;
-    FMT_FALLTHROUGH;
-  case presentation_type::exp_lower:
-    result.format = float_format::exp;
-    result.showpoint |= specs.precision != 0;
-    break;
-  case presentation_type::fixed_upper:
-    result.upper = true;
-    FMT_FALLTHROUGH;
-  case presentation_type::fixed_lower:
-    result.format = float_format::fixed;
-    result.showpoint |= specs.precision != 0;
-    break;
-  case presentation_type::hexfloat_upper:
-    result.upper = true;
-    FMT_FALLTHROUGH;
-  case presentation_type::hexfloat_lower:
-    result.format = float_format::hex;
-    break;
-  default:
-    throw_format_error("invalid format specifier");
-    break;
-  }
-  return result;
-}
-
 template <typename Char, typename OutputIt>
 FMT_CONSTEXPR20 auto write_nonfinite(OutputIt out, bool isnan,
                                      format_specs<Char> specs,
@@ -2502,11 +2014,6 @@
 constexpr auto get_significand_size(const big_decimal_fp& f) -> int {
   return f.significand_size;
 }
-template <typename T>
-inline auto get_significand_size(const dragonbox::decimal_fp<T>& f) -> int {
-  return count_digits(f.significand);
-}
-
 template <typename Char, typename OutputIt>
 constexpr auto write_significand(OutputIt out, const char* significand,
                                  int significand_size) -> OutputIt {
@@ -2596,112 +2103,6 @@
                                          buffer.end(), out);
 }
 
-template <typename OutputIt, typename DecimalFP, typename Char,
-          typename Grouping = digit_grouping<Char>>
-FMT_CONSTEXPR20 auto do_write_float(OutputIt out, const DecimalFP& f,
-                                    const format_specs<Char>& specs,
-                                    float_specs fspecs, locale_ref loc)
-    -> OutputIt {
-  auto significand = f.significand;
-  int significand_size = get_significand_size(f);
-  const Char zero = static_cast<Char>('0');
-  auto sign = fspecs.sign;
-  size_t size = to_unsigned(significand_size) + (sign ? 1 : 0);
-  using iterator = reserve_iterator<OutputIt>;
-
-  Char decimal_point =
-      fspecs.locale ? detail::decimal_point<Char>(loc) : static_cast<Char>('.');
-
-  int output_exp = f.exponent + significand_size - 1;
-  auto use_exp_format = [=]() {
-    if (fspecs.format == float_format::exp) return true;
-    if (fspecs.format != float_format::general) return false;
-    // Use the fixed notation if the exponent is in [exp_lower, exp_upper),
-    // e.g. 0.0001 instead of 1e-04. Otherwise use the exponent notation.
-    const int exp_lower = -4, exp_upper = 16;
-    return output_exp < exp_lower ||
-           output_exp >= (fspecs.precision > 0 ? fspecs.precision : exp_upper);
-  };
-  if (use_exp_format()) {
-    int num_zeros = 0;
-    if (fspecs.showpoint) {
-      num_zeros = fspecs.precision - significand_size;
-      if (num_zeros < 0) num_zeros = 0;
-      size += to_unsigned(num_zeros);
-    } else if (significand_size == 1) {
-      decimal_point = Char();
-    }
-    auto abs_output_exp = output_exp >= 0 ? output_exp : -output_exp;
-    int exp_digits = 2;
-    if (abs_output_exp >= 100) exp_digits = abs_output_exp >= 1000 ? 4 : 3;
-
-    size += to_unsigned((decimal_point ? 1 : 0) + 2 + exp_digits);
-    char exp_char = fspecs.upper ? 'E' : 'e';
-    auto write = [=](iterator it) {
-      if (sign) *it++ = detail::sign<Char>(sign);
-      // Insert a decimal point after the first digit and add an exponent.
-      it = write_significand(it, significand, significand_size, 1,
-                             decimal_point);
-      if (num_zeros > 0) it = detail::fill_n(it, num_zeros, zero);
-      *it++ = static_cast<Char>(exp_char);
-      return write_exponent<Char>(output_exp, it);
-    };
-    return specs.width > 0 ? write_padded<align::right>(out, specs, size, write)
-                           : base_iterator(out, write(reserve(out, size)));
-  }
-
-  int exp = f.exponent + significand_size;
-  if (f.exponent >= 0) {
-    // 1234e5 -> 123400000[.0+]
-    size += to_unsigned(f.exponent);
-    int num_zeros = fspecs.precision - exp;
-    abort_fuzzing_if(num_zeros > 5000);
-    if (fspecs.showpoint) {
-      ++size;
-      if (num_zeros <= 0 && fspecs.format != float_format::fixed) num_zeros = 0;
-      if (num_zeros > 0) size += to_unsigned(num_zeros);
-    }
-    auto grouping = Grouping(loc, fspecs.locale);
-    size += to_unsigned(grouping.count_separators(exp));
-    return write_padded<align::right>(out, specs, size, [&](iterator it) {
-      if (sign) *it++ = detail::sign<Char>(sign);
-      it = write_significand<Char>(it, significand, significand_size,
-                                   f.exponent, grouping);
-      if (!fspecs.showpoint) return it;
-      *it++ = decimal_point;
-      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
-    });
-  } else if (exp > 0) {
-    // 1234e-2 -> 12.34[0+]
-    int num_zeros = fspecs.showpoint ? fspecs.precision - significand_size : 0;
-    size += 1 + to_unsigned(num_zeros > 0 ? num_zeros : 0);
-    auto grouping = Grouping(loc, fspecs.locale);
-    size += to_unsigned(grouping.count_separators(exp));
-    return write_padded<align::right>(out, specs, size, [&](iterator it) {
-      if (sign) *it++ = detail::sign<Char>(sign);
-      it = write_significand(it, significand, significand_size, exp,
-                             decimal_point, grouping);
-      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
-    });
-  }
-  // 1234e-6 -> 0.001234
-  int num_zeros = -exp;
-  if (significand_size == 0 && fspecs.precision >= 0 &&
-      fspecs.precision < num_zeros) {
-    num_zeros = fspecs.precision;
-  }
-  bool pointy = num_zeros != 0 || significand_size != 0 || fspecs.showpoint;
-  size += 1 + (pointy ? 1 : 0) + to_unsigned(num_zeros);
-  return write_padded<align::right>(out, specs, size, [&](iterator it) {
-    if (sign) *it++ = detail::sign<Char>(sign);
-    *it++ = zero;
-    if (!pointy) return it;
-    *it++ = decimal_point;
-    it = detail::fill_n(it, num_zeros, zero);
-    return write_significand<Char>(it, significand, significand_size);
-  });
-}
-
 template <typename Char> class fallback_digit_grouping {
  public:
   constexpr fallback_digit_grouping(locale_ref, bool) {}
@@ -2716,29 +2117,15 @@
   }
 };
 
-template <typename OutputIt, typename DecimalFP, typename Char>
-FMT_CONSTEXPR20 auto write_float(OutputIt out, const DecimalFP& f,
-                                 const format_specs<Char>& specs,
-                                 float_specs fspecs, locale_ref loc)
-    -> OutputIt {
-  if (is_constant_evaluated()) {
-    return do_write_float<OutputIt, DecimalFP, Char,
-                          fallback_digit_grouping<Char>>(out, f, specs, fspecs,
-                                                         loc);
-  } else {
-    return do_write_float(out, f, specs, fspecs, loc);
-  }
-}
-
 template <typename T> constexpr auto isnan(T value) -> bool {
-  return !(value >= value);  // std::isnan doesn't support __float128.
+  return !(value >= value);  // __builtin_isnan doesn't support __float128.
 }
 
 template <typename T, typename Enable = void>
 struct has_isfinite : std::false_type {};
 
 template <typename T>
-struct has_isfinite<T, enable_if_t<sizeof(std::isfinite(T())) != 0>>
+struct has_isfinite<T, enable_if_t<sizeof(__builtin_isfinite(T())) != 0>>
     : std::true_type {};
 
 template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value&&
@@ -2747,12 +2134,12 @@
   constexpr T inf = T(std::numeric_limits<double>::infinity());
   if (is_constant_evaluated())
     return !detail::isnan(value) && value < inf && value > -inf;
-  return std::isfinite(value);
+  return __builtin_isfinite(value);
 }
 template <typename T, FMT_ENABLE_IF(!has_isfinite<T>::value)>
 FMT_CONSTEXPR auto isfinite(T value) -> bool {
   T inf = T(std::numeric_limits<double>::infinity());
-  // std::isfinite doesn't support __float128.
+  // __builtin_isfinite doesn't support __float128.
   return !detail::isnan(value) && value < inf && value > -inf;
 }
 
@@ -2766,14 +2153,14 @@
     }
 #endif
   }
-  return std::signbit(static_cast<double>(value));
+  return __builtin_signbit(static_cast<double>(value));
 }
 
 inline FMT_CONSTEXPR20 void adjust_precision(int& precision, int exp10) {
   // Adjust fixed precision by exponent because it is relative to decimal
   // point.
   if (exp10 > 0 && precision > max_value<int>() - exp10)
-    FMT_THROW(format_error("number is too big"));
+    FMT_THROW("number is too big");
   precision += exp10;
 }
 
@@ -3040,227 +2427,6 @@
   fixed = 4,
 };
 
-// Formats a floating-point number using a variation of the Fixed-Precision
-// Positive Floating-Point Printout ((FPP)^2) algorithm by Steele & White:
-// https://fmt.dev/papers/p372-steele.pdf.
-FMT_CONSTEXPR20 inline void format_dragon(basic_fp<uint128_t> value,
-                                          unsigned flags, int num_digits,
-                                          buffer<char>& buf, int& exp10) {
-  bigint numerator;    // 2 * R in (FPP)^2.
-  bigint denominator;  // 2 * S in (FPP)^2.
-  // lower and upper are differences between value and corresponding boundaries.
-  bigint lower;             // (M^- in (FPP)^2).
-  bigint upper_store;       // upper's value if different from lower.
-  bigint* upper = nullptr;  // (M^+ in (FPP)^2).
-  // Shift numerator and denominator by an extra bit or two (if lower boundary
-  // is closer) to make lower and upper integers. This eliminates multiplication
-  // by 2 during later computations.
-  bool is_predecessor_closer = (flags & dragon::predecessor_closer) != 0;
-  int shift = is_predecessor_closer ? 2 : 1;
-  if (value.e >= 0) {
-    numerator = value.f;
-    numerator <<= value.e + shift;
-    lower = 1;
-    lower <<= value.e;
-    if (is_predecessor_closer) {
-      upper_store = 1;
-      upper_store <<= value.e + 1;
-      upper = &upper_store;
-    }
-    denominator.assign_pow10(exp10);
-    denominator <<= shift;
-  } else if (exp10 < 0) {
-    numerator.assign_pow10(-exp10);
-    lower.assign(numerator);
-    if (is_predecessor_closer) {
-      upper_store.assign(numerator);
-      upper_store <<= 1;
-      upper = &upper_store;
-    }
-    numerator *= value.f;
-    numerator <<= shift;
-    denominator = 1;
-    denominator <<= shift - value.e;
-  } else {
-    numerator = value.f;
-    numerator <<= shift;
-    denominator.assign_pow10(exp10);
-    denominator <<= shift - value.e;
-    lower = 1;
-    if (is_predecessor_closer) {
-      upper_store = 1ULL << 1;
-      upper = &upper_store;
-    }
-  }
-  int even = static_cast<int>((value.f & 1) == 0);
-  if (!upper) upper = &lower;
-  bool shortest = num_digits < 0;
-  if ((flags & dragon::fixup) != 0) {
-    if (add_compare(numerator, *upper, denominator) + even <= 0) {
-      --exp10;
-      numerator *= 10;
-      if (num_digits < 0) {
-        lower *= 10;
-        if (upper != &lower) *upper *= 10;
-      }
-    }
-    if ((flags & dragon::fixed) != 0) adjust_precision(num_digits, exp10 + 1);
-  }
-  // Invariant: value == (numerator / denominator) * pow(10, exp10).
-  if (shortest) {
-    // Generate the shortest representation.
-    num_digits = 0;
-    char* data = buf.data();
-    for (;;) {
-      int digit = numerator.divmod_assign(denominator);
-      bool low = compare(numerator, lower) - even < 0;  // numerator <[=] lower.
-      // numerator + upper >[=] pow10:
-      bool high = add_compare(numerator, *upper, denominator) + even > 0;
-      data[num_digits++] = static_cast<char>('0' + digit);
-      if (low || high) {
-        if (!low) {
-          ++data[num_digits - 1];
-        } else if (high) {
-          int result = add_compare(numerator, numerator, denominator);
-          // Round half to even.
-          if (result > 0 || (result == 0 && (digit % 2) != 0))
-            ++data[num_digits - 1];
-        }
-        buf.try_resize(to_unsigned(num_digits));
-        exp10 -= num_digits - 1;
-        return;
-      }
-      numerator *= 10;
-      lower *= 10;
-      if (upper != &lower) *upper *= 10;
-    }
-  }
-  // Generate the given number of digits.
-  exp10 -= num_digits - 1;
-  if (num_digits <= 0) {
-    denominator *= 10;
-    auto digit = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';
-    buf.push_back(digit);
-    return;
-  }
-  buf.try_resize(to_unsigned(num_digits));
-  for (int i = 0; i < num_digits - 1; ++i) {
-    int digit = numerator.divmod_assign(denominator);
-    buf[i] = static_cast<char>('0' + digit);
-    numerator *= 10;
-  }
-  int digit = numerator.divmod_assign(denominator);
-  auto result = add_compare(numerator, numerator, denominator);
-  if (result > 0 || (result == 0 && (digit % 2) != 0)) {
-    if (digit == 9) {
-      const auto overflow = '0' + 10;
-      buf[num_digits - 1] = overflow;
-      // Propagate the carry.
-      for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {
-        buf[i] = '0';
-        ++buf[i - 1];
-      }
-      if (buf[0] == overflow) {
-        buf[0] = '1';
-        if ((flags & dragon::fixed) != 0)
-          buf.push_back('0');
-        else
-          ++exp10;
-      }
-      return;
-    }
-    ++digit;
-  }
-  buf[num_digits - 1] = static_cast<char>('0' + digit);
-}
-
-// Formats a floating-point number using the hexfloat format.
-template <typename Float, FMT_ENABLE_IF(!is_double_double<Float>::value)>
-FMT_CONSTEXPR20 void format_hexfloat(Float value, int precision,
-                                     float_specs specs, buffer<char>& buf) {
-  // float is passed as double to reduce the number of instantiations and to
-  // simplify implementation.
-  static_assert(!std::is_same<Float, float>::value, "");
-
-  using info = dragonbox::float_info<Float>;
-
-  // Assume Float is in the format [sign][exponent][significand].
-  using carrier_uint = typename info::carrier_uint;
-
-  constexpr auto num_float_significand_bits =
-      detail::num_significand_bits<Float>();
-
-  basic_fp<carrier_uint> f(value);
-  f.e += num_float_significand_bits;
-  if (!has_implicit_bit<Float>()) --f.e;
-
-  constexpr auto num_fraction_bits =
-      num_float_significand_bits + (has_implicit_bit<Float>() ? 1 : 0);
-  constexpr auto num_xdigits = (num_fraction_bits + 3) / 4;
-
-  constexpr auto leading_shift = ((num_xdigits - 1) * 4);
-  const auto leading_mask = carrier_uint(0xF) << leading_shift;
-  const auto leading_xdigit =
-      static_cast<uint32_t>((f.f & leading_mask) >> leading_shift);
-  if (leading_xdigit > 1) f.e -= (32 - countl_zero(leading_xdigit) - 1);
-
-  int print_xdigits = num_xdigits - 1;
-  if (precision >= 0 && print_xdigits > precision) {
-    const int shift = ((print_xdigits - precision - 1) * 4);
-    const auto mask = carrier_uint(0xF) << shift;
-    const auto v = static_cast<uint32_t>((f.f & mask) >> shift);
-
-    if (v >= 8) {
-      const auto inc = carrier_uint(1) << (shift + 4);
-      f.f += inc;
-      f.f &= ~(inc - 1);
-    }
-
-    // Check long double overflow
-    if (!has_implicit_bit<Float>()) {
-      const auto implicit_bit = carrier_uint(1) << num_float_significand_bits;
-      if ((f.f & implicit_bit) == implicit_bit) {
-        f.f >>= 4;
-        f.e += 4;
-      }
-    }
-
-    print_xdigits = precision;
-  }
-
-  char xdigits[num_bits<carrier_uint>() / 4];
-  detail::fill_n(xdigits, sizeof(xdigits), '0');
-  format_uint<4>(xdigits, f.f, num_xdigits, specs.upper);
-
-  // Remove zero tail
-  while (print_xdigits > 0 && xdigits[print_xdigits] == '0') --print_xdigits;
-
-  buf.push_back('0');
-  buf.push_back(specs.upper ? 'X' : 'x');
-  buf.push_back(xdigits[0]);
-  if (specs.showpoint || print_xdigits > 0 || print_xdigits < precision)
-    buf.push_back('.');
-  buf.append(xdigits + 1, xdigits + 1 + print_xdigits);
-  for (; print_xdigits < precision; ++print_xdigits) buf.push_back('0');
-
-  buf.push_back(specs.upper ? 'P' : 'p');
-
-  uint32_t abs_e;
-  if (f.e < 0) {
-    buf.push_back('-');
-    abs_e = static_cast<uint32_t>(-f.e);
-  } else {
-    buf.push_back('+');
-    abs_e = static_cast<uint32_t>(f.e);
-  }
-  format_decimal<char>(appender(buf), abs_e, detail::count_digits(abs_e));
-}
-
-template <typename Float, FMT_ENABLE_IF(is_double_double<Float>::value)>
-FMT_CONSTEXPR20 void format_hexfloat(Float value, int precision,
-                                     float_specs specs, buffer<char>& buf) {
-  format_hexfloat(static_cast<double>(value), precision, specs, buf);
-}
 
 constexpr auto fractional_part_rounding_thresholds(int index) -> uint32_t {
   // For checking rounding thresholds.
@@ -3273,395 +2439,11 @@
          U"\x800001ae\x8000002b"[index];
 }
 
-template <typename Float>
-FMT_CONSTEXPR20 auto format_float(Float value, int precision, float_specs specs,
-                                  buffer<char>& buf) -> int {
-  // float is passed as double to reduce the number of instantiations.
-  static_assert(!std::is_same<Float, float>::value, "");
-  FMT_ASSERT(value >= 0, "value is negative");
-  auto converted_value = convert_float(value);
-
-  const bool fixed = specs.format == float_format::fixed;
-  if (value <= 0) {  // <= instead of == to silence a warning.
-    if (precision <= 0 || !fixed) {
-      buf.push_back('0');
-      return 0;
-    }
-    buf.try_resize(to_unsigned(precision));
-    fill_n(buf.data(), precision, '0');
-    return -precision;
-  }
-
-  int exp = 0;
-  bool use_dragon = true;
-  unsigned dragon_flags = 0;
-  if (!is_fast_float<Float>() || is_constant_evaluated()) {
-    const auto inv_log2_10 = 0.3010299956639812;  // 1 / log2(10)
-    using info = dragonbox::float_info<decltype(converted_value)>;
-    const auto f = basic_fp<typename info::carrier_uint>(converted_value);
-    // Compute exp, an approximate power of 10, such that
-    //   10^(exp - 1) <= value < 10^exp or 10^exp <= value < 10^(exp + 1).
-    // This is based on log10(value) == log2(value) / log2(10) and approximation
-    // of log2(value) by e + num_fraction_bits idea from double-conversion.
-    auto e = (f.e + count_digits<1>(f.f) - 1) * inv_log2_10 - 1e-10;
-    exp = static_cast<int>(e);
-    if (e > exp) ++exp;  // Compute ceil.
-    dragon_flags = dragon::fixup;
-  } else if (precision < 0) {
-    // Use Dragonbox for the shortest format.
-    if (specs.binary32) {
-      auto dec = dragonbox::to_decimal(static_cast<float>(value));
-      write<char>(buffer_appender<char>(buf), dec.significand);
-      return dec.exponent;
-    }
-    auto dec = dragonbox::to_decimal(static_cast<double>(value));
-    write<char>(buffer_appender<char>(buf), dec.significand);
-    return dec.exponent;
-  } else {
-    // Extract significand bits and exponent bits.
-    using info = dragonbox::float_info<double>;
-    auto br = bit_cast<uint64_t>(static_cast<double>(value));
-
-    const uint64_t significand_mask =
-        (static_cast<uint64_t>(1) << num_significand_bits<double>()) - 1;
-    uint64_t significand = (br & significand_mask);
-    int exponent = static_cast<int>((br & exponent_mask<double>()) >>
-                                    num_significand_bits<double>());
-
-    if (exponent != 0) {  // Check if normal.
-      exponent -= exponent_bias<double>() + num_significand_bits<double>();
-      significand |=
-          (static_cast<uint64_t>(1) << num_significand_bits<double>());
-      significand <<= 1;
-    } else {
-      // Normalize subnormal inputs.
-      FMT_ASSERT(significand != 0, "zeros should not appear here");
-      int shift = countl_zero(significand);
-      FMT_ASSERT(shift >= num_bits<uint64_t>() - num_significand_bits<double>(),
-                 "");
-      shift -= (num_bits<uint64_t>() - num_significand_bits<double>() - 2);
-      exponent = (std::numeric_limits<double>::min_exponent -
-                  num_significand_bits<double>()) -
-                 shift;
-      significand <<= shift;
-    }
-
-    // Compute the first several nonzero decimal significand digits.
-    // We call the number we get the first segment.
-    const int k = info::kappa - dragonbox::floor_log10_pow2(exponent);
-    exp = -k;
-    const int beta = exponent + dragonbox::floor_log2_pow10(k);
-    uint64_t first_segment;
-    bool has_more_segments;
-    int digits_in_the_first_segment;
-    {
-      const auto r = dragonbox::umul192_upper128(
-          significand << beta, dragonbox::get_cached_power(k));
-      first_segment = r.high();
-      has_more_segments = r.low() != 0;
-
-      // The first segment can have 18 ~ 19 digits.
-      if (first_segment >= 1000000000000000000ULL) {
-        digits_in_the_first_segment = 19;
-      } else {
-        // When it is of 18-digits, we align it to 19-digits by adding a bogus
-        // zero at the end.
-        digits_in_the_first_segment = 18;
-        first_segment *= 10;
-      }
-    }
-
-    // Compute the actual number of decimal digits to print.
-    if (fixed) adjust_precision(precision, exp + digits_in_the_first_segment);
-
-    // Use Dragon4 only when there might be not enough digits in the first
-    // segment.
-    if (digits_in_the_first_segment > precision) {
-      use_dragon = false;
-
-      if (precision <= 0) {
-        exp += digits_in_the_first_segment;
-
-        if (precision < 0) {
-          // Nothing to do, since all we have are just leading zeros.
-          buf.try_resize(0);
-        } else {
-          // We may need to round-up.
-          buf.try_resize(1);
-          if ((first_segment | static_cast<uint64_t>(has_more_segments)) >
-              5000000000000000000ULL) {
-            buf[0] = '1';
-          } else {
-            buf[0] = '0';
-          }
-        }
-      }  // precision <= 0
-      else {
-        exp += digits_in_the_first_segment - precision;
-
-        // When precision > 0, we divide the first segment into three
-        // subsegments, each with 9, 9, and 0 ~ 1 digits so that each fits
-        // in 32-bits which usually allows faster calculation than in
-        // 64-bits. Since some compiler (e.g. MSVC) doesn't know how to optimize
-        // division-by-constant for large 64-bit divisors, we do it here
-        // manually. The magic number 7922816251426433760 below is equal to
-        // ceil(2^(64+32) / 10^10).
-        const uint32_t first_subsegment = static_cast<uint32_t>(
-            dragonbox::umul128_upper64(first_segment, 7922816251426433760ULL) >>
-            32);
-        const uint64_t second_third_subsegments =
-            first_segment - first_subsegment * 10000000000ULL;
-
-        uint64_t prod;
-        uint32_t digits;
-        bool should_round_up;
-        int number_of_digits_to_print = precision > 9 ? 9 : precision;
-
-        // Print a 9-digits subsegment, either the first or the second.
-        auto print_subsegment = [&](uint32_t subsegment, char* buffer) {
-          int number_of_digits_printed = 0;
-
-          // If we want to print an odd number of digits from the subsegment,
-          if ((number_of_digits_to_print & 1) != 0) {
-            // Convert to 64-bit fixed-point fractional form with 1-digit
-            // integer part. The magic number 720575941 is a good enough
-            // approximation of 2^(32 + 24) / 10^8; see
-            // https://jk-jeon.github.io/posts/2022/12/fixed-precision-formatting/#fixed-length-case
-            // for details.
-            prod = ((subsegment * static_cast<uint64_t>(720575941)) >> 24) + 1;
-            digits = static_cast<uint32_t>(prod >> 32);
-            *buffer = static_cast<char>('0' + digits);
-            number_of_digits_printed++;
-          }
-          // If we want to print an even number of digits from the
-          // first_subsegment,
-          else {
-            // Convert to 64-bit fixed-point fractional form with 2-digits
-            // integer part. The magic number 450359963 is a good enough
-            // approximation of 2^(32 + 20) / 10^7; see
-            // https://jk-jeon.github.io/posts/2022/12/fixed-precision-formatting/#fixed-length-case
-            // for details.
-            prod = ((subsegment * static_cast<uint64_t>(450359963)) >> 20) + 1;
-            digits = static_cast<uint32_t>(prod >> 32);
-            copy2(buffer, digits2(digits));
-            number_of_digits_printed += 2;
-          }
-
-          // Print all digit pairs.
-          while (number_of_digits_printed < number_of_digits_to_print) {
-            prod = static_cast<uint32_t>(prod) * static_cast<uint64_t>(100);
-            digits = static_cast<uint32_t>(prod >> 32);
-            copy2(buffer + number_of_digits_printed, digits2(digits));
-            number_of_digits_printed += 2;
-          }
-        };
-
-        // Print first subsegment.
-        print_subsegment(first_subsegment, buf.data());
-
-        // Perform rounding if the first subsegment is the last subsegment to
-        // print.
-        if (precision <= 9) {
-          // Rounding inside the subsegment.
-          // We round-up if:
-          //  - either the fractional part is strictly larger than 1/2, or
-          //  - the fractional part is exactly 1/2 and the last digit is odd.
-          // We rely on the following observations:
-          //  - If fractional_part >= threshold, then the fractional part is
-          //    strictly larger than 1/2.
-          //  - If the MSB of fractional_part is set, then the fractional part
-          //    must be at least 1/2.
-          //  - When the MSB of fractional_part is set, either
-          //    second_third_subsegments being nonzero or has_more_segments
-          //    being true means there are further digits not printed, so the
-          //    fractional part is strictly larger than 1/2.
-          if (precision < 9) {
-            uint32_t fractional_part = static_cast<uint32_t>(prod);
-            should_round_up =
-                fractional_part >= fractional_part_rounding_thresholds(
-                                       8 - number_of_digits_to_print) ||
-                ((fractional_part >> 31) &
-                 ((digits & 1) | (second_third_subsegments != 0) |
-                  has_more_segments)) != 0;
-          }
-          // Rounding at the subsegment boundary.
-          // In this case, the fractional part is at least 1/2 if and only if
-          // second_third_subsegments >= 5000000000ULL, and is strictly larger
-          // than 1/2 if we further have either second_third_subsegments >
-          // 5000000000ULL or has_more_segments == true.
-          else {
-            should_round_up = second_third_subsegments > 5000000000ULL ||
-                              (second_third_subsegments == 5000000000ULL &&
-                               ((digits & 1) != 0 || has_more_segments));
-          }
-        }
-        // Otherwise, print the second subsegment.
-        else {
-          // Compilers are not aware of how to leverage the maximum value of
-          // second_third_subsegments to find out a better magic number which
-          // allows us to eliminate an additional shift. 1844674407370955162 =
-          // ceil(2^64/10) < ceil(2^64*(10^9/(10^10 - 1))).
-          const uint32_t second_subsegment =
-              static_cast<uint32_t>(dragonbox::umul128_upper64(
-                  second_third_subsegments, 1844674407370955162ULL));
-          const uint32_t third_subsegment =
-              static_cast<uint32_t>(second_third_subsegments) -
-              second_subsegment * 10;
-
-          number_of_digits_to_print = precision - 9;
-          print_subsegment(second_subsegment, buf.data() + 9);
-
-          // Rounding inside the subsegment.
-          if (precision < 18) {
-            // The condition third_subsegment != 0 implies that the segment was
-            // of 19 digits, so in this case the third segment should be
-            // consisting of a genuine digit from the input.
-            uint32_t fractional_part = static_cast<uint32_t>(prod);
-            should_round_up =
-                fractional_part >= fractional_part_rounding_thresholds(
-                                       8 - number_of_digits_to_print) ||
-                ((fractional_part >> 31) &
-                 ((digits & 1) | (third_subsegment != 0) |
-                  has_more_segments)) != 0;
-          }
-          // Rounding at the subsegment boundary.
-          else {
-            // In this case, the segment must be of 19 digits, thus
-            // the third subsegment should be consisting of a genuine digit from
-            // the input.
-            should_round_up = third_subsegment > 5 ||
-                              (third_subsegment == 5 &&
-                               ((digits & 1) != 0 || has_more_segments));
-          }
-        }
-
-        // Round-up if necessary.
-        if (should_round_up) {
-          ++buf[precision - 1];
-          for (int i = precision - 1; i > 0 && buf[i] > '9'; --i) {
-            buf[i] = '0';
-            ++buf[i - 1];
-          }
-          if (buf[0] > '9') {
-            buf[0] = '1';
-            if (fixed)
-              buf[precision++] = '0';
-            else
-              ++exp;
-          }
-        }
-        buf.try_resize(to_unsigned(precision));
-      }
-    }  // if (digits_in_the_first_segment > precision)
-    else {
-      // Adjust the exponent for its use in Dragon4.
-      exp += digits_in_the_first_segment - 1;
-    }
-  }
-  if (use_dragon) {
-    auto f = basic_fp<uint128_t>();
-    bool is_predecessor_closer = specs.binary32
-                                     ? f.assign(static_cast<float>(value))
-                                     : f.assign(converted_value);
-    if (is_predecessor_closer) dragon_flags |= dragon::predecessor_closer;
-    if (fixed) dragon_flags |= dragon::fixed;
-    // Limit precision to the maximum possible number of significant digits in
-    // an IEEE754 double because we don't need to generate zeros.
-    const int max_double_digits = 767;
-    if (precision > max_double_digits) precision = max_double_digits;
-    format_dragon(f, dragon_flags, precision, buf, exp);
-  }
-  if (!fixed && !specs.showpoint) {
-    // Remove trailing zeros.
-    auto num_digits = buf.size();
-    while (num_digits > 0 && buf[num_digits - 1] == '0') {
-      --num_digits;
-      ++exp;
-    }
-    buf.try_resize(num_digits);
-  }
-  return exp;
-}
-template <typename Char, typename OutputIt, typename T>
-FMT_CONSTEXPR20 auto write_float(OutputIt out, T value,
-                                 format_specs<Char> specs, locale_ref loc)
-    -> OutputIt {
-  float_specs fspecs = parse_float_type_spec(specs);
-  fspecs.sign = specs.sign;
-  if (detail::signbit(value)) {  // value < 0 is false for NaN so use signbit.
-    fspecs.sign = sign::minus;
-    value = -value;
-  } else if (fspecs.sign == sign::minus) {
-    fspecs.sign = sign::none;
-  }
-
-  if (!detail::isfinite(value))
-    return write_nonfinite(out, detail::isnan(value), specs, fspecs);
-
-  if (specs.align == align::numeric && fspecs.sign) {
-    auto it = reserve(out, 1);
-    *it++ = detail::sign<Char>(fspecs.sign);
-    out = base_iterator(out, it);
-    fspecs.sign = sign::none;
-    if (specs.width != 0) --specs.width;
-  }
-
-  memory_buffer buffer;
-  if (fspecs.format == float_format::hex) {
-    if (fspecs.sign) buffer.push_back(detail::sign<char>(fspecs.sign));
-    format_hexfloat(convert_float(value), specs.precision, fspecs, buffer);
-    return write_bytes<align::right>(out, {buffer.data(), buffer.size()},
-                                     specs);
-  }
-  int precision = specs.precision >= 0 || specs.type == presentation_type::none
-                      ? specs.precision
-                      : 6;
-  if (fspecs.format == float_format::exp) {
-    if (precision == max_value<int>())
-      throw_format_error("number is too big");
-    else
-      ++precision;
-  } else if (fspecs.format != float_format::fixed && precision == 0) {
-    precision = 1;
-  }
-  if (const_check(std::is_same<T, float>())) fspecs.binary32 = true;
-  int exp = format_float(convert_float(value), precision, fspecs, buffer);
-  fspecs.precision = precision;
-  auto f = big_decimal_fp{buffer.data(), static_cast<int>(buffer.size()), exp};
-  return write_float(out, f, specs, fspecs, loc);
-}
-
 template <typename Char, typename OutputIt, typename T,
           FMT_ENABLE_IF(is_floating_point<T>::value)>
 FMT_CONSTEXPR20 auto write(OutputIt out, T value, format_specs<Char> specs,
                            locale_ref loc = {}) -> OutputIt {
-  if (const_check(!is_supported_floating_point(value))) return out;
-  return specs.localized && write_loc(out, value, specs, loc)
-             ? out
-             : write_float(out, value, specs, loc);
-}
-
-template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(is_fast_float<T>::value)>
-FMT_CONSTEXPR20 auto write(OutputIt out, T value) -> OutputIt {
-  if (is_constant_evaluated()) return write(out, value, format_specs<Char>());
-  if (const_check(!is_supported_floating_point(value))) return out;
-
-  auto fspecs = float_specs();
-  if (detail::signbit(value)) {
-    fspecs.sign = sign::minus;
-    value = -value;
-  }
-
-  constexpr auto specs = format_specs<Char>();
-  using floaty = conditional_t<std::is_same<T, long double>::value, double, T>;
-  using floaty_uint = typename dragonbox::float_info<floaty>::carrier_uint;
-  floaty_uint mask = exponent_mask<floaty>();
-  if ((bit_cast<floaty_uint>(value) & mask) == mask)
-    return write_nonfinite(out, std::isnan(value), specs, fspecs);
-
-  auto dec = dragonbox::to_decimal(static_cast<floaty>(value));
-  return write_float(out, dec, specs, fspecs, {});
+ return out;
 }
 
 template <typename Char, typename OutputIt, typename T,
@@ -3726,7 +2508,7 @@
 FMT_CONSTEXPR_CHAR_TRAITS auto write(OutputIt out, const Char* value)
     -> OutputIt {
   if (value) return write(out, basic_string_view<Char>(value));
-  throw_format_error("string pointer is null");
+  (void)("string pointer is null");
   return out;
 }
 
@@ -3804,13 +2586,13 @@
 struct width_checker {
   template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
   FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {
-    if (is_negative(value)) throw_format_error("negative width");
+    if (is_negative(value)) (void)("negative width");
     return static_cast<unsigned long long>(value);
   }
 
   template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
   FMT_CONSTEXPR auto operator()(T) -> unsigned long long {
-    throw_format_error("width is not integer");
+    (void)("width is not integer");
     return 0;
   }
 };
@@ -3818,13 +2600,13 @@
 struct precision_checker {
   template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
   FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {
-    if (is_negative(value)) throw_format_error("negative precision");
+    if (is_negative(value)) (void)("negative precision");
     return static_cast<unsigned long long>(value);
   }
 
   template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
   FMT_CONSTEXPR auto operator()(T) -> unsigned long long {
-    throw_format_error("precision is not integer");
+    (void)("precision is not integer");
     return 0;
   }
 };
@@ -3833,7 +2615,7 @@
 FMT_CONSTEXPR auto get_dynamic_spec(FormatArg arg) -> int {
   unsigned long long value = visit_format_arg(Handler(), arg);
   if (value > to_unsigned(max_value<int>()))
-    throw_format_error("number is too big");
+    (void)("number is too big");
   return static_cast<int>(value);
 }
 
@@ -3916,53 +2698,6 @@
                           const char* message) noexcept;
 }  // namespace detail
 
-FMT_API auto vsystem_error(int error_code, string_view format_str,
-                           format_args args) -> std::system_error;
-
-/**
-  \rst
-  Constructs :class:`std::system_error` with a message formatted with
-  ``fmt::format(fmt, args...)``.
-  *error_code* is a system error code as given by ``errno``.
-
-  **Example**::
-
-    // This throws std::system_error with the description
-    //   cannot open file 'madeup': No such file or directory
-    // or similar (system message may vary).
-    const char* filename = "madeup";
-    std::FILE* file = std::fopen(filename, "r");
-    if (!file)
-      throw fmt::system_error(errno, "cannot open file '{}'", filename);
-  \endrst
- */
-template <typename... T>
-auto system_error(int error_code, format_string<T...> fmt, T&&... args)
-    -> std::system_error {
-  return vsystem_error(error_code, fmt, fmt::make_format_args(args...));
-}
-
-/**
-  \rst
-  Formats an error message for an error returned by an operating system or a
-  language runtime, for example a file opening error, and writes it to *out*.
-  The format is the same as the one used by ``std::system_error(ec, message)``
-  where ``ec`` is ``std::error_code(error_code, std::generic_category()})``.
-  It is implementation-defined but normally looks like:
-
-  .. parsed-literal::
-     *<message>*: *<system-message>*
-
-  where *<message>* is the passed message and *<system-message>* is the system
-  message corresponding to the error code.
-  *error_code* is a system error code as given by ``errno``.
-  \endrst
- */
-FMT_API void format_system_error(detail::buffer<char>& out, int error_code,
-                                 const char* message) noexcept;
-
-// Reports a system error without throwing an exception.
-// Can be used to report errors from destructors.
 FMT_API void report_system_error(int error_code, const char* message) noexcept;
 
 /** Fast integer formatter. */
@@ -4067,13 +2802,6 @@
   static_assert(std::is_pointer<T>::value, "");
   return detail::bit_cast<const void*>(p);
 }
-template <typename T, typename Deleter>
-auto ptr(const std::unique_ptr<T, Deleter>& p) -> const void* {
-  return p.get();
-}
-template <typename T> auto ptr(const std::shared_ptr<T>& p) -> const void* {
-  return p.get();
-}
 
 /**
   \rst
@@ -4355,7 +3083,7 @@
   auto out = buffer_appender<Char>(buf);
   if (fmt.size() == 2 && equal2(fmt.data(), "{}")) {
     auto arg = args.get(0);
-    if (!arg) throw_format_error("argument not found");
+    if (!arg) (void)("argument not found");
     visit_format_arg(default_arg_formatter<Char>{out, args, loc}, arg);
     return;
   }
@@ -4382,7 +3110,7 @@
     }
     FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
       int arg_id = context.arg_id(id);
-      if (arg_id < 0) throw_format_error("argument not found");
+      if (arg_id < 0) (void)("argument not found");
       return arg_id;
     }
 
@@ -4407,7 +3135,7 @@
       detail::handle_dynamic_spec<detail::precision_checker>(
           specs.precision, specs.precision_ref, context);
       if (begin == end || *begin != '}')
-        throw_format_error("missing '}' in format string");
+        (void)("missing '}' in format string");
       auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
       context.advance_to(visit_format_arg(f, arg));
       return begin;
@@ -4417,19 +3145,6 @@
 }
 
 FMT_BEGIN_EXPORT
-
-#ifndef FMT_HEADER_ONLY
-extern template FMT_API void vformat_to(buffer<char>&, string_view,
-                                        typename vformat_args<>::type,
-                                        locale_ref);
-extern template FMT_API auto thousands_sep_impl<char>(locale_ref)
-    -> thousands_sep_result<char>;
-extern template FMT_API auto thousands_sep_impl<wchar_t>(locale_ref)
-    -> thousands_sep_result<wchar_t>;
-extern template FMT_API auto decimal_point_impl(locale_ref) -> char;
-extern template FMT_API auto decimal_point_impl(locale_ref) -> wchar_t;
-#endif  // FMT_HEADER_ONLY
-
 }  // namespace detail
 
 #if FMT_USE_USER_DEFINED_LITERALS
@@ -4457,49 +3172,6 @@
 }  // namespace literals
 #endif  // FMT_USE_USER_DEFINED_LITERALS
 
-template <typename Locale, FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
-inline auto vformat(const Locale& loc, string_view fmt, format_args args)
-    -> std::string {
-  return detail::vformat(loc, fmt, args);
-}
-
-template <typename Locale, typename... T,
-          FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
-inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
-    -> std::string {
-  return fmt::vformat(loc, string_view(fmt), fmt::make_format_args(args...));
-}
-
-template <typename OutputIt, typename Locale,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&
-                            detail::is_locale<Locale>::value)>
-auto vformat_to(OutputIt out, const Locale& loc, string_view fmt,
-                format_args args) -> OutputIt {
-  using detail::get_buffer;
-  auto&& buf = get_buffer<char>(out);
-  detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));
-  return detail::get_iterator(buf, out);
-}
-
-template <typename OutputIt, typename Locale, typename... T,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&
-                            detail::is_locale<Locale>::value)>
-FMT_INLINE auto format_to(OutputIt out, const Locale& loc,
-                          format_string<T...> fmt, T&&... args) -> OutputIt {
-  return vformat_to(out, loc, fmt, fmt::make_format_args(args...));
-}
-
-template <typename Locale, typename... T,
-          FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
-FMT_NODISCARD FMT_INLINE auto formatted_size(const Locale& loc,
-                                             format_string<T...> fmt,
-                                             T&&... args) -> size_t {
-  auto buf = detail::counting_buffer<>();
-  detail::vformat_to<char>(buf, fmt, fmt::make_format_args(args...),
-                           detail::locale_ref(loc));
-  return buf.count();
-}
-
 FMT_END_EXPORT
 
 template <typename T, typename Char>
@@ -4524,11 +3196,6 @@
 
 FMT_END_NAMESPACE
 
-#ifdef FMT_HEADER_ONLY
 #  define FMT_FUNC inline
 #  include "format-inl.h"
-#else
-#  define FMT_FUNC
-#endif
-
 #endif  // FMT_FORMAT_H_
diff --color -Naur fmt-original/include/fmt/format-inl.h fmt-10.2.0/include/fmt/format-inl.h
--- fmt-original/include/fmt/format-inl.h	2025-07-16 22:36:59.478009151 +0200
+++ fmt-10.2.0/include/fmt/format-inl.h	2025-07-16 22:36:52.875195846 +0200
@@ -8,19 +8,7 @@
 #ifndef FMT_FORMAT_INL_H_
 #define FMT_FORMAT_INL_H_
 
-#include <algorithm>
-#include <cerrno>  // errno
 #include <climits>
-#include <cmath>
-#include <exception>
-
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
-#  include <locale>
-#endif
-
-#if defined(_WIN32) && !defined(FMT_WINDOWS_NO_WCHAR)
-#  include <io.h>  // _isatty
-#endif
 
 #include "format.h"
 
@@ -36,127 +24,6 @@
   std::terminate();
 }
 
-FMT_FUNC void throw_format_error(const char* message) {
-  FMT_THROW(format_error(message));
-}
-
-FMT_FUNC void format_error_code(detail::buffer<char>& out, int error_code,
-                                string_view message) noexcept {
-  // Report error code making sure that the output fits into
-  // inline_buffer_size to avoid dynamic memory allocation and potential
-  // bad_alloc.
-  out.try_resize(0);
-  static const char SEP[] = ": ";
-  static const char ERROR_STR[] = "error ";
-  // Subtract 2 to account for terminating null characters in SEP and ERROR_STR.
-  size_t error_code_size = sizeof(SEP) + sizeof(ERROR_STR) - 2;
-  auto abs_value = static_cast<uint32_or_64_or_128_t<int>>(error_code);
-  if (detail::is_negative(error_code)) {
-    abs_value = 0 - abs_value;
-    ++error_code_size;
-  }
-  error_code_size += detail::to_unsigned(detail::count_digits(abs_value));
-  auto it = buffer_appender<char>(out);
-  if (message.size() <= inline_buffer_size - error_code_size)
-    fmt::format_to(it, FMT_STRING("{}{}"), message, SEP);
-  fmt::format_to(it, FMT_STRING("{}{}"), ERROR_STR, error_code);
-  FMT_ASSERT(out.size() <= inline_buffer_size, "");
-}
-
-FMT_FUNC void report_error(format_func func, int error_code,
-                           const char* message) noexcept {
-  memory_buffer full_message;
-  func(full_message, error_code, message);
-  // Don't use fwrite_fully because the latter may throw.
-  if (std::fwrite(full_message.data(), full_message.size(), 1, stderr) > 0)
-    std::fputc('\n', stderr);
-}
-
-// A wrapper around fwrite that throws on error.
-inline void fwrite_fully(const void* ptr, size_t count, FILE* stream) {
-  size_t written = std::fwrite(ptr, 1, count, stream);
-  if (written < count)
-    FMT_THROW(system_error(errno, FMT_STRING("cannot write to file")));
-}
-
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
-template <typename Locale>
-locale_ref::locale_ref(const Locale& loc) : locale_(&loc) {
-  static_assert(std::is_same<Locale, std::locale>::value, "");
-}
-
-template <typename Locale> auto locale_ref::get() const -> Locale {
-  static_assert(std::is_same<Locale, std::locale>::value, "");
-  return locale_ ? *static_cast<const std::locale*>(locale_) : std::locale();
-}
-
-template <typename Char>
-FMT_FUNC auto thousands_sep_impl(locale_ref loc) -> thousands_sep_result<Char> {
-  auto& facet = std::use_facet<std::numpunct<Char>>(loc.get<std::locale>());
-  auto grouping = facet.grouping();
-  auto thousands_sep = grouping.empty() ? Char() : facet.thousands_sep();
-  return {std::move(grouping), thousands_sep};
-}
-template <typename Char>
-FMT_FUNC auto decimal_point_impl(locale_ref loc) -> Char {
-  return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())
-      .decimal_point();
-}
-#else
-template <typename Char>
-FMT_FUNC auto thousands_sep_impl(locale_ref) -> thousands_sep_result<Char> {
-  return {"\03", FMT_STATIC_THOUSANDS_SEPARATOR};
-}
-template <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref) {
-  return '.';
-}
-#endif
-
-FMT_FUNC auto write_loc(appender out, loc_value value,
-                        const format_specs<>& specs, locale_ref loc) -> bool {
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
-  auto locale = loc.get<std::locale>();
-  // We cannot use the num_put<char> facet because it may produce output in
-  // a wrong encoding.
-  using facet = format_facet<std::locale>;
-  if (std::has_facet<facet>(locale))
-    return std::use_facet<facet>(locale).put(out, value, specs);
-  return facet(locale).put(out, value, specs);
-#endif
-  return false;
-}
-}  // namespace detail
-
-template <typename Locale> typename Locale::id format_facet<Locale>::id;
-
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
-template <typename Locale> format_facet<Locale>::format_facet(Locale& loc) {
-  auto& numpunct = std::use_facet<std::numpunct<char>>(loc);
-  grouping_ = numpunct.grouping();
-  if (!grouping_.empty()) separator_ = std::string(1, numpunct.thousands_sep());
-}
-
-template <>
-FMT_API FMT_FUNC auto format_facet<std::locale>::do_put(
-    appender out, loc_value val, const format_specs<>& specs) const -> bool {
-  return val.visit(
-      detail::loc_writer<>{out, specs, separator_, grouping_, decimal_point_});
-}
-#endif
-
-FMT_FUNC auto vsystem_error(int error_code, string_view fmt, format_args args)
-    -> std::system_error {
-  auto ec = std::error_code(error_code, std::generic_category());
-  return std::system_error(ec, vformat(fmt, args));
-}
-
-namespace detail {
-
-template <typename F>
-inline auto operator==(basic_fp<F> x, basic_fp<F> y) -> bool {
-  return x.f == y.f && x.e == y.e;
-}
-
 // Compilers should be able to optimize this into the ror instruction.
 FMT_CONSTEXPR inline auto rotr(uint32_t n, uint32_t r) noexcept -> uint32_t {
   r &= 31;
@@ -167,1234 +34,11 @@
   return (n >> r) | (n << (64 - r));
 }
 
-// Implementation of Dragonbox algorithm: https://github.com/jk-jeon/dragonbox.
-namespace dragonbox {
-// Computes upper 64 bits of multiplication of a 32-bit unsigned integer and a
-// 64-bit unsigned integer.
-inline auto umul96_upper64(uint32_t x, uint64_t y) noexcept -> uint64_t {
-  return umul128_upper64(static_cast<uint64_t>(x) << 32, y);
-}
-
-// Computes lower 128 bits of multiplication of a 64-bit unsigned integer and a
-// 128-bit unsigned integer.
-inline auto umul192_lower128(uint64_t x, uint128_fallback y) noexcept
-    -> uint128_fallback {
-  uint64_t high = x * y.high();
-  uint128_fallback high_low = umul128(x, y.low());
-  return {high + high_low.high(), high_low.low()};
-}
-
-// Computes lower 64 bits of multiplication of a 32-bit unsigned integer and a
-// 64-bit unsigned integer.
-inline auto umul96_lower64(uint32_t x, uint64_t y) noexcept -> uint64_t {
-  return x * y;
-}
-
-// Various fast log computations.
-inline auto floor_log10_pow2_minus_log10_4_over_3(int e) noexcept -> int {
-  FMT_ASSERT(e <= 2936 && e >= -2985, "too large exponent");
-  return (e * 631305 - 261663) >> 21;
-}
-
-FMT_INLINE_VARIABLE constexpr struct {
-  uint32_t divisor;
-  int shift_amount;
-} div_small_pow10_infos[] = {{10, 16}, {100, 16}};
-
-// Replaces n by floor(n / pow(10, N)) returning true if and only if n is
-// divisible by pow(10, N).
-// Precondition: n <= pow(10, N + 1).
-template <int N>
-auto check_divisibility_and_divide_by_pow10(uint32_t& n) noexcept -> bool {
-  // The numbers below are chosen such that:
-  //   1. floor(n/d) = floor(nm / 2^k) where d=10 or d=100,
-  //   2. nm mod 2^k < m if and only if n is divisible by d,
-  // where m is magic_number, k is shift_amount
-  // and d is divisor.
-  //
-  // Item 1 is a common technique of replacing division by a constant with
-  // multiplication, see e.g. "Division by Invariant Integers Using
-  // Multiplication" by Granlund and Montgomery (1994). magic_number (m) is set
-  // to ceil(2^k/d) for large enough k.
-  // The idea for item 2 originates from Schubfach.
-  constexpr auto info = div_small_pow10_infos[N - 1];
-  FMT_ASSERT(n <= info.divisor * 10, "n is too large");
-  constexpr uint32_t magic_number =
-      (1u << info.shift_amount) / info.divisor + 1;
-  n *= magic_number;
-  const uint32_t comparison_mask = (1u << info.shift_amount) - 1;
-  bool result = (n & comparison_mask) < magic_number;
-  n >>= info.shift_amount;
-  return result;
-}
-
-// Computes floor(n / pow(10, N)) for small n and N.
-// Precondition: n <= pow(10, N + 1).
-template <int N> auto small_division_by_pow10(uint32_t n) noexcept -> uint32_t {
-  constexpr auto info = div_small_pow10_infos[N - 1];
-  FMT_ASSERT(n <= info.divisor * 10, "n is too large");
-  constexpr uint32_t magic_number =
-      (1u << info.shift_amount) / info.divisor + 1;
-  return (n * magic_number) >> info.shift_amount;
-}
-
-// Computes floor(n / 10^(kappa + 1)) (float)
-inline auto divide_by_10_to_kappa_plus_1(uint32_t n) noexcept -> uint32_t {
-  // 1374389535 = ceil(2^37/100)
-  return static_cast<uint32_t>((static_cast<uint64_t>(n) * 1374389535) >> 37);
-}
-// Computes floor(n / 10^(kappa + 1)) (double)
-inline auto divide_by_10_to_kappa_plus_1(uint64_t n) noexcept -> uint64_t {
-  // 2361183241434822607 = ceil(2^(64+7)/1000)
-  return umul128_upper64(n, 2361183241434822607ull) >> 7;
-}
-
-// Various subroutines using pow10 cache
-template <typename T> struct cache_accessor;
-
-template <> struct cache_accessor<float> {
-  using carrier_uint = float_info<float>::carrier_uint;
-  using cache_entry_type = uint64_t;
-
-  static auto get_cached_power(int k) noexcept -> uint64_t {
-    FMT_ASSERT(k >= float_info<float>::min_k && k <= float_info<float>::max_k,
-               "k is out of range");
-    static constexpr const uint64_t pow10_significands[] = {
-        0x81ceb32c4b43fcf5, 0xa2425ff75e14fc32, 0xcad2f7f5359a3b3f,
-        0xfd87b5f28300ca0e, 0x9e74d1b791e07e49, 0xc612062576589ddb,
-        0xf79687aed3eec552, 0x9abe14cd44753b53, 0xc16d9a0095928a28,
-        0xf1c90080baf72cb2, 0x971da05074da7bef, 0xbce5086492111aeb,
-        0xec1e4a7db69561a6, 0x9392ee8e921d5d08, 0xb877aa3236a4b44a,
-        0xe69594bec44de15c, 0x901d7cf73ab0acda, 0xb424dc35095cd810,
-        0xe12e13424bb40e14, 0x8cbccc096f5088cc, 0xafebff0bcb24aaff,
-        0xdbe6fecebdedd5bf, 0x89705f4136b4a598, 0xabcc77118461cefd,
-        0xd6bf94d5e57a42bd, 0x8637bd05af6c69b6, 0xa7c5ac471b478424,
-        0xd1b71758e219652c, 0x83126e978d4fdf3c, 0xa3d70a3d70a3d70b,
-        0xcccccccccccccccd, 0x8000000000000000, 0xa000000000000000,
-        0xc800000000000000, 0xfa00000000000000, 0x9c40000000000000,
-        0xc350000000000000, 0xf424000000000000, 0x9896800000000000,
-        0xbebc200000000000, 0xee6b280000000000, 0x9502f90000000000,
-        0xba43b74000000000, 0xe8d4a51000000000, 0x9184e72a00000000,
-        0xb5e620f480000000, 0xe35fa931a0000000, 0x8e1bc9bf04000000,
-        0xb1a2bc2ec5000000, 0xde0b6b3a76400000, 0x8ac7230489e80000,
-        0xad78ebc5ac620000, 0xd8d726b7177a8000, 0x878678326eac9000,
-        0xa968163f0a57b400, 0xd3c21bcecceda100, 0x84595161401484a0,
-        0xa56fa5b99019a5c8, 0xcecb8f27f4200f3a, 0x813f3978f8940985,
-        0xa18f07d736b90be6, 0xc9f2c9cd04674edf, 0xfc6f7c4045812297,
-        0x9dc5ada82b70b59e, 0xc5371912364ce306, 0xf684df56c3e01bc7,
-        0x9a130b963a6c115d, 0xc097ce7bc90715b4, 0xf0bdc21abb48db21,
-        0x96769950b50d88f5, 0xbc143fa4e250eb32, 0xeb194f8e1ae525fe,
-        0x92efd1b8d0cf37bf, 0xb7abc627050305ae, 0xe596b7b0c643c71a,
-        0x8f7e32ce7bea5c70, 0xb35dbf821ae4f38c, 0xe0352f62a19e306f};
-    return pow10_significands[k - float_info<float>::min_k];
-  }
-
-  struct compute_mul_result {
-    carrier_uint result;
-    bool is_integer;
-  };
-  struct compute_mul_parity_result {
-    bool parity;
-    bool is_integer;
-  };
-
-  static auto compute_mul(carrier_uint u,
-                          const cache_entry_type& cache) noexcept
-      -> compute_mul_result {
-    auto r = umul96_upper64(u, cache);
-    return {static_cast<carrier_uint>(r >> 32),
-            static_cast<carrier_uint>(r) == 0};
-  }
-
-  static auto compute_delta(const cache_entry_type& cache, int beta) noexcept
-      -> uint32_t {
-    return static_cast<uint32_t>(cache >> (64 - 1 - beta));
-  }
-
-  static auto compute_mul_parity(carrier_uint two_f,
-                                 const cache_entry_type& cache,
-                                 int beta) noexcept
-      -> compute_mul_parity_result {
-    FMT_ASSERT(beta >= 1, "");
-    FMT_ASSERT(beta < 64, "");
-
-    auto r = umul96_lower64(two_f, cache);
-    return {((r >> (64 - beta)) & 1) != 0,
-            static_cast<uint32_t>(r >> (32 - beta)) == 0};
-  }
-
-  static auto compute_left_endpoint_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta) noexcept -> carrier_uint {
-    return static_cast<carrier_uint>(
-        (cache - (cache >> (num_significand_bits<float>() + 2))) >>
-        (64 - num_significand_bits<float>() - 1 - beta));
-  }
-
-  static auto compute_right_endpoint_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta) noexcept -> carrier_uint {
-    return static_cast<carrier_uint>(
-        (cache + (cache >> (num_significand_bits<float>() + 1))) >>
-        (64 - num_significand_bits<float>() - 1 - beta));
-  }
-
-  static auto compute_round_up_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta) noexcept -> carrier_uint {
-    return (static_cast<carrier_uint>(
-                cache >> (64 - num_significand_bits<float>() - 2 - beta)) +
-            1) /
-           2;
-  }
-};
-
-template <> struct cache_accessor<double> {
-  using carrier_uint = float_info<double>::carrier_uint;
-  using cache_entry_type = uint128_fallback;
-
-  static auto get_cached_power(int k) noexcept -> uint128_fallback {
-    FMT_ASSERT(k >= float_info<double>::min_k && k <= float_info<double>::max_k,
-               "k is out of range");
-
-    static constexpr const uint128_fallback pow10_significands[] = {
-#if FMT_USE_FULL_CACHE_DRAGONBOX
-      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
-      {0x9faacf3df73609b1, 0x77b191618c54e9ad},
-      {0xc795830d75038c1d, 0xd59df5b9ef6a2418},
-      {0xf97ae3d0d2446f25, 0x4b0573286b44ad1e},
-      {0x9becce62836ac577, 0x4ee367f9430aec33},
-      {0xc2e801fb244576d5, 0x229c41f793cda740},
-      {0xf3a20279ed56d48a, 0x6b43527578c11110},
-      {0x9845418c345644d6, 0x830a13896b78aaaa},
-      {0xbe5691ef416bd60c, 0x23cc986bc656d554},
-      {0xedec366b11c6cb8f, 0x2cbfbe86b7ec8aa9},
-      {0x94b3a202eb1c3f39, 0x7bf7d71432f3d6aa},
-      {0xb9e08a83a5e34f07, 0xdaf5ccd93fb0cc54},
-      {0xe858ad248f5c22c9, 0xd1b3400f8f9cff69},
-      {0x91376c36d99995be, 0x23100809b9c21fa2},
-      {0xb58547448ffffb2d, 0xabd40a0c2832a78b},
-      {0xe2e69915b3fff9f9, 0x16c90c8f323f516d},
-      {0x8dd01fad907ffc3b, 0xae3da7d97f6792e4},
-      {0xb1442798f49ffb4a, 0x99cd11cfdf41779d},
-      {0xdd95317f31c7fa1d, 0x40405643d711d584},
-      {0x8a7d3eef7f1cfc52, 0x482835ea666b2573},
-      {0xad1c8eab5ee43b66, 0xda3243650005eed0},
-      {0xd863b256369d4a40, 0x90bed43e40076a83},
-      {0x873e4f75e2224e68, 0x5a7744a6e804a292},
-      {0xa90de3535aaae202, 0x711515d0a205cb37},
-      {0xd3515c2831559a83, 0x0d5a5b44ca873e04},
-      {0x8412d9991ed58091, 0xe858790afe9486c3},
-      {0xa5178fff668ae0b6, 0x626e974dbe39a873},
-      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
-      {0x80fa687f881c7f8e, 0x7ce66634bc9d0b9a},
-      {0xa139029f6a239f72, 0x1c1fffc1ebc44e81},
-      {0xc987434744ac874e, 0xa327ffb266b56221},
-      {0xfbe9141915d7a922, 0x4bf1ff9f0062baa9},
-      {0x9d71ac8fada6c9b5, 0x6f773fc3603db4aa},
-      {0xc4ce17b399107c22, 0xcb550fb4384d21d4},
-      {0xf6019da07f549b2b, 0x7e2a53a146606a49},
-      {0x99c102844f94e0fb, 0x2eda7444cbfc426e},
-      {0xc0314325637a1939, 0xfa911155fefb5309},
-      {0xf03d93eebc589f88, 0x793555ab7eba27cb},
-      {0x96267c7535b763b5, 0x4bc1558b2f3458df},
-      {0xbbb01b9283253ca2, 0x9eb1aaedfb016f17},
-      {0xea9c227723ee8bcb, 0x465e15a979c1cadd},
-      {0x92a1958a7675175f, 0x0bfacd89ec191eca},
-      {0xb749faed14125d36, 0xcef980ec671f667c},
-      {0xe51c79a85916f484, 0x82b7e12780e7401b},
-      {0x8f31cc0937ae58d2, 0xd1b2ecb8b0908811},
-      {0xb2fe3f0b8599ef07, 0x861fa7e6dcb4aa16},
-      {0xdfbdcece67006ac9, 0x67a791e093e1d49b},
-      {0x8bd6a141006042bd, 0xe0c8bb2c5c6d24e1},
-      {0xaecc49914078536d, 0x58fae9f773886e19},
-      {0xda7f5bf590966848, 0xaf39a475506a899f},
-      {0x888f99797a5e012d, 0x6d8406c952429604},
-      {0xaab37fd7d8f58178, 0xc8e5087ba6d33b84},
-      {0xd5605fcdcf32e1d6, 0xfb1e4a9a90880a65},
-      {0x855c3be0a17fcd26, 0x5cf2eea09a550680},
-      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
-      {0xd0601d8efc57b08b, 0xf13b94daf124da27},
-      {0x823c12795db6ce57, 0x76c53d08d6b70859},
-      {0xa2cb1717b52481ed, 0x54768c4b0c64ca6f},
-      {0xcb7ddcdda26da268, 0xa9942f5dcf7dfd0a},
-      {0xfe5d54150b090b02, 0xd3f93b35435d7c4d},
-      {0x9efa548d26e5a6e1, 0xc47bc5014a1a6db0},
-      {0xc6b8e9b0709f109a, 0x359ab6419ca1091c},
-      {0xf867241c8cc6d4c0, 0xc30163d203c94b63},
-      {0x9b407691d7fc44f8, 0x79e0de63425dcf1e},
-      {0xc21094364dfb5636, 0x985915fc12f542e5},
-      {0xf294b943e17a2bc4, 0x3e6f5b7b17b2939e},
-      {0x979cf3ca6cec5b5a, 0xa705992ceecf9c43},
-      {0xbd8430bd08277231, 0x50c6ff782a838354},
-      {0xece53cec4a314ebd, 0xa4f8bf5635246429},
-      {0x940f4613ae5ed136, 0x871b7795e136be9a},
-      {0xb913179899f68584, 0x28e2557b59846e40},
-      {0xe757dd7ec07426e5, 0x331aeada2fe589d0},
-      {0x9096ea6f3848984f, 0x3ff0d2c85def7622},
-      {0xb4bca50b065abe63, 0x0fed077a756b53aa},
-      {0xe1ebce4dc7f16dfb, 0xd3e8495912c62895},
-      {0x8d3360f09cf6e4bd, 0x64712dd7abbbd95d},
-      {0xb080392cc4349dec, 0xbd8d794d96aacfb4},
-      {0xdca04777f541c567, 0xecf0d7a0fc5583a1},
-      {0x89e42caaf9491b60, 0xf41686c49db57245},
-      {0xac5d37d5b79b6239, 0x311c2875c522ced6},
-      {0xd77485cb25823ac7, 0x7d633293366b828c},
-      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
-      {0xa8530886b54dbdeb, 0xd9f57f830283fdfd},
-      {0xd267caa862a12d66, 0xd072df63c324fd7c},
-      {0x8380dea93da4bc60, 0x4247cb9e59f71e6e},
-      {0xa46116538d0deb78, 0x52d9be85f074e609},
-      {0xcd795be870516656, 0x67902e276c921f8c},
-      {0x806bd9714632dff6, 0x00ba1cd8a3db53b7},
-      {0xa086cfcd97bf97f3, 0x80e8a40eccd228a5},
-      {0xc8a883c0fdaf7df0, 0x6122cd128006b2ce},
-      {0xfad2a4b13d1b5d6c, 0x796b805720085f82},
-      {0x9cc3a6eec6311a63, 0xcbe3303674053bb1},
-      {0xc3f490aa77bd60fc, 0xbedbfc4411068a9d},
-      {0xf4f1b4d515acb93b, 0xee92fb5515482d45},
-      {0x991711052d8bf3c5, 0x751bdd152d4d1c4b},
-      {0xbf5cd54678eef0b6, 0xd262d45a78a0635e},
-      {0xef340a98172aace4, 0x86fb897116c87c35},
-      {0x9580869f0e7aac0e, 0xd45d35e6ae3d4da1},
-      {0xbae0a846d2195712, 0x8974836059cca10a},
-      {0xe998d258869facd7, 0x2bd1a438703fc94c},
-      {0x91ff83775423cc06, 0x7b6306a34627ddd0},
-      {0xb67f6455292cbf08, 0x1a3bc84c17b1d543},
-      {0xe41f3d6a7377eeca, 0x20caba5f1d9e4a94},
-      {0x8e938662882af53e, 0x547eb47b7282ee9d},
-      {0xb23867fb2a35b28d, 0xe99e619a4f23aa44},
-      {0xdec681f9f4c31f31, 0x6405fa00e2ec94d5},
-      {0x8b3c113c38f9f37e, 0xde83bc408dd3dd05},
-      {0xae0b158b4738705e, 0x9624ab50b148d446},
-      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
-      {0x87f8a8d4cfa417c9, 0xe54ca5d70a80e5d7},
-      {0xa9f6d30a038d1dbc, 0x5e9fcf4ccd211f4d},
-      {0xd47487cc8470652b, 0x7647c32000696720},
-      {0x84c8d4dfd2c63f3b, 0x29ecd9f40041e074},
-      {0xa5fb0a17c777cf09, 0xf468107100525891},
-      {0xcf79cc9db955c2cc, 0x7182148d4066eeb5},
-      {0x81ac1fe293d599bf, 0xc6f14cd848405531},
-      {0xa21727db38cb002f, 0xb8ada00e5a506a7d},
-      {0xca9cf1d206fdc03b, 0xa6d90811f0e4851d},
-      {0xfd442e4688bd304a, 0x908f4a166d1da664},
-      {0x9e4a9cec15763e2e, 0x9a598e4e043287ff},
-      {0xc5dd44271ad3cdba, 0x40eff1e1853f29fe},
-      {0xf7549530e188c128, 0xd12bee59e68ef47d},
-      {0x9a94dd3e8cf578b9, 0x82bb74f8301958cf},
-      {0xc13a148e3032d6e7, 0xe36a52363c1faf02},
-      {0xf18899b1bc3f8ca1, 0xdc44e6c3cb279ac2},
-      {0x96f5600f15a7b7e5, 0x29ab103a5ef8c0ba},
-      {0xbcb2b812db11a5de, 0x7415d448f6b6f0e8},
-      {0xebdf661791d60f56, 0x111b495b3464ad22},
-      {0x936b9fcebb25c995, 0xcab10dd900beec35},
-      {0xb84687c269ef3bfb, 0x3d5d514f40eea743},
-      {0xe65829b3046b0afa, 0x0cb4a5a3112a5113},
-      {0x8ff71a0fe2c2e6dc, 0x47f0e785eaba72ac},
-      {0xb3f4e093db73a093, 0x59ed216765690f57},
-      {0xe0f218b8d25088b8, 0x306869c13ec3532d},
-      {0x8c974f7383725573, 0x1e414218c73a13fc},
-      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
-      {0xdbac6c247d62a583, 0xdf45f746b74abf3a},
-      {0x894bc396ce5da772, 0x6b8bba8c328eb784},
-      {0xab9eb47c81f5114f, 0x066ea92f3f326565},
-      {0xd686619ba27255a2, 0xc80a537b0efefebe},
-      {0x8613fd0145877585, 0xbd06742ce95f5f37},
-      {0xa798fc4196e952e7, 0x2c48113823b73705},
-      {0xd17f3b51fca3a7a0, 0xf75a15862ca504c6},
-      {0x82ef85133de648c4, 0x9a984d73dbe722fc},
-      {0xa3ab66580d5fdaf5, 0xc13e60d0d2e0ebbb},
-      {0xcc963fee10b7d1b3, 0x318df905079926a9},
-      {0xffbbcfe994e5c61f, 0xfdf17746497f7053},
-      {0x9fd561f1fd0f9bd3, 0xfeb6ea8bedefa634},
-      {0xc7caba6e7c5382c8, 0xfe64a52ee96b8fc1},
-      {0xf9bd690a1b68637b, 0x3dfdce7aa3c673b1},
-      {0x9c1661a651213e2d, 0x06bea10ca65c084f},
-      {0xc31bfa0fe5698db8, 0x486e494fcff30a63},
-      {0xf3e2f893dec3f126, 0x5a89dba3c3efccfb},
-      {0x986ddb5c6b3a76b7, 0xf89629465a75e01d},
-      {0xbe89523386091465, 0xf6bbb397f1135824},
-      {0xee2ba6c0678b597f, 0x746aa07ded582e2d},
-      {0x94db483840b717ef, 0xa8c2a44eb4571cdd},
-      {0xba121a4650e4ddeb, 0x92f34d62616ce414},
-      {0xe896a0d7e51e1566, 0x77b020baf9c81d18},
-      {0x915e2486ef32cd60, 0x0ace1474dc1d122f},
-      {0xb5b5ada8aaff80b8, 0x0d819992132456bb},
-      {0xe3231912d5bf60e6, 0x10e1fff697ed6c6a},
-      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
-      {0xb1736b96b6fd83b3, 0xbd308ff8a6b17cb3},
-      {0xddd0467c64bce4a0, 0xac7cb3f6d05ddbdf},
-      {0x8aa22c0dbef60ee4, 0x6bcdf07a423aa96c},
-      {0xad4ab7112eb3929d, 0x86c16c98d2c953c7},
-      {0xd89d64d57a607744, 0xe871c7bf077ba8b8},
-      {0x87625f056c7c4a8b, 0x11471cd764ad4973},
-      {0xa93af6c6c79b5d2d, 0xd598e40d3dd89bd0},
-      {0xd389b47879823479, 0x4aff1d108d4ec2c4},
-      {0x843610cb4bf160cb, 0xcedf722a585139bb},
-      {0xa54394fe1eedb8fe, 0xc2974eb4ee658829},
-      {0xce947a3da6a9273e, 0x733d226229feea33},
-      {0x811ccc668829b887, 0x0806357d5a3f5260},
-      {0xa163ff802a3426a8, 0xca07c2dcb0cf26f8},
-      {0xc9bcff6034c13052, 0xfc89b393dd02f0b6},
-      {0xfc2c3f3841f17c67, 0xbbac2078d443ace3},
-      {0x9d9ba7832936edc0, 0xd54b944b84aa4c0e},
-      {0xc5029163f384a931, 0x0a9e795e65d4df12},
-      {0xf64335bcf065d37d, 0x4d4617b5ff4a16d6},
-      {0x99ea0196163fa42e, 0x504bced1bf8e4e46},
-      {0xc06481fb9bcf8d39, 0xe45ec2862f71e1d7},
-      {0xf07da27a82c37088, 0x5d767327bb4e5a4d},
-      {0x964e858c91ba2655, 0x3a6a07f8d510f870},
-      {0xbbe226efb628afea, 0x890489f70a55368c},
-      {0xeadab0aba3b2dbe5, 0x2b45ac74ccea842f},
-      {0x92c8ae6b464fc96f, 0x3b0b8bc90012929e},
-      {0xb77ada0617e3bbcb, 0x09ce6ebb40173745},
-      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
-      {0x8f57fa54c2a9eab6, 0x9fa946824a12232e},
-      {0xb32df8e9f3546564, 0x47939822dc96abfa},
-      {0xdff9772470297ebd, 0x59787e2b93bc56f8},
-      {0x8bfbea76c619ef36, 0x57eb4edb3c55b65b},
-      {0xaefae51477a06b03, 0xede622920b6b23f2},
-      {0xdab99e59958885c4, 0xe95fab368e45ecee},
-      {0x88b402f7fd75539b, 0x11dbcb0218ebb415},
-      {0xaae103b5fcd2a881, 0xd652bdc29f26a11a},
-      {0xd59944a37c0752a2, 0x4be76d3346f04960},
-      {0x857fcae62d8493a5, 0x6f70a4400c562ddc},
-      {0xa6dfbd9fb8e5b88e, 0xcb4ccd500f6bb953},
-      {0xd097ad07a71f26b2, 0x7e2000a41346a7a8},
-      {0x825ecc24c873782f, 0x8ed400668c0c28c9},
-      {0xa2f67f2dfa90563b, 0x728900802f0f32fb},
-      {0xcbb41ef979346bca, 0x4f2b40a03ad2ffba},
-      {0xfea126b7d78186bc, 0xe2f610c84987bfa9},
-      {0x9f24b832e6b0f436, 0x0dd9ca7d2df4d7ca},
-      {0xc6ede63fa05d3143, 0x91503d1c79720dbc},
-      {0xf8a95fcf88747d94, 0x75a44c6397ce912b},
-      {0x9b69dbe1b548ce7c, 0xc986afbe3ee11abb},
-      {0xc24452da229b021b, 0xfbe85badce996169},
-      {0xf2d56790ab41c2a2, 0xfae27299423fb9c4},
-      {0x97c560ba6b0919a5, 0xdccd879fc967d41b},
-      {0xbdb6b8e905cb600f, 0x5400e987bbc1c921},
-      {0xed246723473e3813, 0x290123e9aab23b69},
-      {0x9436c0760c86e30b, 0xf9a0b6720aaf6522},
-      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
-      {0xe7958cb87392c2c2, 0xb60b1d1230b20e05},
-      {0x90bd77f3483bb9b9, 0xb1c6f22b5e6f48c3},
-      {0xb4ecd5f01a4aa828, 0x1e38aeb6360b1af4},
-      {0xe2280b6c20dd5232, 0x25c6da63c38de1b1},
-      {0x8d590723948a535f, 0x579c487e5a38ad0f},
-      {0xb0af48ec79ace837, 0x2d835a9df0c6d852},
-      {0xdcdb1b2798182244, 0xf8e431456cf88e66},
-      {0x8a08f0f8bf0f156b, 0x1b8e9ecb641b5900},
-      {0xac8b2d36eed2dac5, 0xe272467e3d222f40},
-      {0xd7adf884aa879177, 0x5b0ed81dcc6abb10},
-      {0x86ccbb52ea94baea, 0x98e947129fc2b4ea},
-      {0xa87fea27a539e9a5, 0x3f2398d747b36225},
-      {0xd29fe4b18e88640e, 0x8eec7f0d19a03aae},
-      {0x83a3eeeef9153e89, 0x1953cf68300424ad},
-      {0xa48ceaaab75a8e2b, 0x5fa8c3423c052dd8},
-      {0xcdb02555653131b6, 0x3792f412cb06794e},
-      {0x808e17555f3ebf11, 0xe2bbd88bbee40bd1},
-      {0xa0b19d2ab70e6ed6, 0x5b6aceaeae9d0ec5},
-      {0xc8de047564d20a8b, 0xf245825a5a445276},
-      {0xfb158592be068d2e, 0xeed6e2f0f0d56713},
-      {0x9ced737bb6c4183d, 0x55464dd69685606c},
-      {0xc428d05aa4751e4c, 0xaa97e14c3c26b887},
-      {0xf53304714d9265df, 0xd53dd99f4b3066a9},
-      {0x993fe2c6d07b7fab, 0xe546a8038efe402a},
-      {0xbf8fdb78849a5f96, 0xde98520472bdd034},
-      {0xef73d256a5c0f77c, 0x963e66858f6d4441},
-      {0x95a8637627989aad, 0xdde7001379a44aa9},
-      {0xbb127c53b17ec159, 0x5560c018580d5d53},
-      {0xe9d71b689dde71af, 0xaab8f01e6e10b4a7},
-      {0x9226712162ab070d, 0xcab3961304ca70e9},
-      {0xb6b00d69bb55c8d1, 0x3d607b97c5fd0d23},
-      {0xe45c10c42a2b3b05, 0x8cb89a7db77c506b},
-      {0x8eb98a7a9a5b04e3, 0x77f3608e92adb243},
-      {0xb267ed1940f1c61c, 0x55f038b237591ed4},
-      {0xdf01e85f912e37a3, 0x6b6c46dec52f6689},
-      {0x8b61313bbabce2c6, 0x2323ac4b3b3da016},
-      {0xae397d8aa96c1b77, 0xabec975e0a0d081b},
-      {0xd9c7dced53c72255, 0x96e7bd358c904a22},
-      {0x881cea14545c7575, 0x7e50d64177da2e55},
-      {0xaa242499697392d2, 0xdde50bd1d5d0b9ea},
-      {0xd4ad2dbfc3d07787, 0x955e4ec64b44e865},
-      {0x84ec3c97da624ab4, 0xbd5af13bef0b113f},
-      {0xa6274bbdd0fadd61, 0xecb1ad8aeacdd58f},
-      {0xcfb11ead453994ba, 0x67de18eda5814af3},
-      {0x81ceb32c4b43fcf4, 0x80eacf948770ced8},
-      {0xa2425ff75e14fc31, 0xa1258379a94d028e},
-      {0xcad2f7f5359a3b3e, 0x096ee45813a04331},
-      {0xfd87b5f28300ca0d, 0x8bca9d6e188853fd},
-      {0x9e74d1b791e07e48, 0x775ea264cf55347e},
-      {0xc612062576589dda, 0x95364afe032a819e},
-      {0xf79687aed3eec551, 0x3a83ddbd83f52205},
-      {0x9abe14cd44753b52, 0xc4926a9672793543},
-      {0xc16d9a0095928a27, 0x75b7053c0f178294},
-      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
-      {0x971da05074da7bee, 0xd3f6fc16ebca5e04},
-      {0xbce5086492111aea, 0x88f4bb1ca6bcf585},
-      {0xec1e4a7db69561a5, 0x2b31e9e3d06c32e6},
-      {0x9392ee8e921d5d07, 0x3aff322e62439fd0},
-      {0xb877aa3236a4b449, 0x09befeb9fad487c3},
-      {0xe69594bec44de15b, 0x4c2ebe687989a9b4},
-      {0x901d7cf73ab0acd9, 0x0f9d37014bf60a11},
-      {0xb424dc35095cd80f, 0x538484c19ef38c95},
-      {0xe12e13424bb40e13, 0x2865a5f206b06fba},
-      {0x8cbccc096f5088cb, 0xf93f87b7442e45d4},
-      {0xafebff0bcb24aafe, 0xf78f69a51539d749},
-      {0xdbe6fecebdedd5be, 0xb573440e5a884d1c},
-      {0x89705f4136b4a597, 0x31680a88f8953031},
-      {0xabcc77118461cefc, 0xfdc20d2b36ba7c3e},
-      {0xd6bf94d5e57a42bc, 0x3d32907604691b4d},
-      {0x8637bd05af6c69b5, 0xa63f9a49c2c1b110},
-      {0xa7c5ac471b478423, 0x0fcf80dc33721d54},
-      {0xd1b71758e219652b, 0xd3c36113404ea4a9},
-      {0x83126e978d4fdf3b, 0x645a1cac083126ea},
-      {0xa3d70a3d70a3d70a, 0x3d70a3d70a3d70a4},
-      {0xcccccccccccccccc, 0xcccccccccccccccd},
-      {0x8000000000000000, 0x0000000000000000},
-      {0xa000000000000000, 0x0000000000000000},
-      {0xc800000000000000, 0x0000000000000000},
-      {0xfa00000000000000, 0x0000000000000000},
-      {0x9c40000000000000, 0x0000000000000000},
-      {0xc350000000000000, 0x0000000000000000},
-      {0xf424000000000000, 0x0000000000000000},
-      {0x9896800000000000, 0x0000000000000000},
-      {0xbebc200000000000, 0x0000000000000000},
-      {0xee6b280000000000, 0x0000000000000000},
-      {0x9502f90000000000, 0x0000000000000000},
-      {0xba43b74000000000, 0x0000000000000000},
-      {0xe8d4a51000000000, 0x0000000000000000},
-      {0x9184e72a00000000, 0x0000000000000000},
-      {0xb5e620f480000000, 0x0000000000000000},
-      {0xe35fa931a0000000, 0x0000000000000000},
-      {0x8e1bc9bf04000000, 0x0000000000000000},
-      {0xb1a2bc2ec5000000, 0x0000000000000000},
-      {0xde0b6b3a76400000, 0x0000000000000000},
-      {0x8ac7230489e80000, 0x0000000000000000},
-      {0xad78ebc5ac620000, 0x0000000000000000},
-      {0xd8d726b7177a8000, 0x0000000000000000},
-      {0x878678326eac9000, 0x0000000000000000},
-      {0xa968163f0a57b400, 0x0000000000000000},
-      {0xd3c21bcecceda100, 0x0000000000000000},
-      {0x84595161401484a0, 0x0000000000000000},
-      {0xa56fa5b99019a5c8, 0x0000000000000000},
-      {0xcecb8f27f4200f3a, 0x0000000000000000},
-      {0x813f3978f8940984, 0x4000000000000000},
-      {0xa18f07d736b90be5, 0x5000000000000000},
-      {0xc9f2c9cd04674ede, 0xa400000000000000},
-      {0xfc6f7c4045812296, 0x4d00000000000000},
-      {0x9dc5ada82b70b59d, 0xf020000000000000},
-      {0xc5371912364ce305, 0x6c28000000000000},
-      {0xf684df56c3e01bc6, 0xc732000000000000},
-      {0x9a130b963a6c115c, 0x3c7f400000000000},
-      {0xc097ce7bc90715b3, 0x4b9f100000000000},
-      {0xf0bdc21abb48db20, 0x1e86d40000000000},
-      {0x96769950b50d88f4, 0x1314448000000000},
-      {0xbc143fa4e250eb31, 0x17d955a000000000},
-      {0xeb194f8e1ae525fd, 0x5dcfab0800000000},
-      {0x92efd1b8d0cf37be, 0x5aa1cae500000000},
-      {0xb7abc627050305ad, 0xf14a3d9e40000000},
-      {0xe596b7b0c643c719, 0x6d9ccd05d0000000},
-      {0x8f7e32ce7bea5c6f, 0xe4820023a2000000},
-      {0xb35dbf821ae4f38b, 0xdda2802c8a800000},
-      {0xe0352f62a19e306e, 0xd50b2037ad200000},
-      {0x8c213d9da502de45, 0x4526f422cc340000},
-      {0xaf298d050e4395d6, 0x9670b12b7f410000},
-      {0xdaf3f04651d47b4c, 0x3c0cdd765f114000},
-      {0x88d8762bf324cd0f, 0xa5880a69fb6ac800},
-      {0xab0e93b6efee0053, 0x8eea0d047a457a00},
-      {0xd5d238a4abe98068, 0x72a4904598d6d880},
-      {0x85a36366eb71f041, 0x47a6da2b7f864750},
-      {0xa70c3c40a64e6c51, 0x999090b65f67d924},
-      {0xd0cf4b50cfe20765, 0xfff4b4e3f741cf6d},
-      {0x82818f1281ed449f, 0xbff8f10e7a8921a5},
-      {0xa321f2d7226895c7, 0xaff72d52192b6a0e},
-      {0xcbea6f8ceb02bb39, 0x9bf4f8a69f764491},
-      {0xfee50b7025c36a08, 0x02f236d04753d5b5},
-      {0x9f4f2726179a2245, 0x01d762422c946591},
-      {0xc722f0ef9d80aad6, 0x424d3ad2b7b97ef6},
-      {0xf8ebad2b84e0d58b, 0xd2e0898765a7deb3},
-      {0x9b934c3b330c8577, 0x63cc55f49f88eb30},
-      {0xc2781f49ffcfa6d5, 0x3cbf6b71c76b25fc},
-      {0xf316271c7fc3908a, 0x8bef464e3945ef7b},
-      {0x97edd871cfda3a56, 0x97758bf0e3cbb5ad},
-      {0xbde94e8e43d0c8ec, 0x3d52eeed1cbea318},
-      {0xed63a231d4c4fb27, 0x4ca7aaa863ee4bde},
-      {0x945e455f24fb1cf8, 0x8fe8caa93e74ef6b},
-      {0xb975d6b6ee39e436, 0xb3e2fd538e122b45},
-      {0xe7d34c64a9c85d44, 0x60dbbca87196b617},
-      {0x90e40fbeea1d3a4a, 0xbc8955e946fe31ce},
-      {0xb51d13aea4a488dd, 0x6babab6398bdbe42},
-      {0xe264589a4dcdab14, 0xc696963c7eed2dd2},
-      {0x8d7eb76070a08aec, 0xfc1e1de5cf543ca3},
-      {0xb0de65388cc8ada8, 0x3b25a55f43294bcc},
-      {0xdd15fe86affad912, 0x49ef0eb713f39ebf},
-      {0x8a2dbf142dfcc7ab, 0x6e3569326c784338},
-      {0xacb92ed9397bf996, 0x49c2c37f07965405},
-      {0xd7e77a8f87daf7fb, 0xdc33745ec97be907},
-      {0x86f0ac99b4e8dafd, 0x69a028bb3ded71a4},
-      {0xa8acd7c0222311bc, 0xc40832ea0d68ce0d},
-      {0xd2d80db02aabd62b, 0xf50a3fa490c30191},
-      {0x83c7088e1aab65db, 0x792667c6da79e0fb},
-      {0xa4b8cab1a1563f52, 0x577001b891185939},
-      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f87},
-      {0x80b05e5ac60b6178, 0x544f8158315b05b5},
-      {0xa0dc75f1778e39d6, 0x696361ae3db1c722},
-      {0xc913936dd571c84c, 0x03bc3a19cd1e38ea},
-      {0xfb5878494ace3a5f, 0x04ab48a04065c724},
-      {0x9d174b2dcec0e47b, 0x62eb0d64283f9c77},
-      {0xc45d1df942711d9a, 0x3ba5d0bd324f8395},
-      {0xf5746577930d6500, 0xca8f44ec7ee3647a},
-      {0x9968bf6abbe85f20, 0x7e998b13cf4e1ecc},
-      {0xbfc2ef456ae276e8, 0x9e3fedd8c321a67f},
-      {0xefb3ab16c59b14a2, 0xc5cfe94ef3ea101f},
-      {0x95d04aee3b80ece5, 0xbba1f1d158724a13},
-      {0xbb445da9ca61281f, 0x2a8a6e45ae8edc98},
-      {0xea1575143cf97226, 0xf52d09d71a3293be},
-      {0x924d692ca61be758, 0x593c2626705f9c57},
-      {0xb6e0c377cfa2e12e, 0x6f8b2fb00c77836d},
-      {0xe498f455c38b997a, 0x0b6dfb9c0f956448},
-      {0x8edf98b59a373fec, 0x4724bd4189bd5ead},
-      {0xb2977ee300c50fe7, 0x58edec91ec2cb658},
-      {0xdf3d5e9bc0f653e1, 0x2f2967b66737e3ee},
-      {0x8b865b215899f46c, 0xbd79e0d20082ee75},
-      {0xae67f1e9aec07187, 0xecd8590680a3aa12},
-      {0xda01ee641a708de9, 0xe80e6f4820cc9496},
-      {0x884134fe908658b2, 0x3109058d147fdcde},
-      {0xaa51823e34a7eede, 0xbd4b46f0599fd416},
-      {0xd4e5e2cdc1d1ea96, 0x6c9e18ac7007c91b},
-      {0x850fadc09923329e, 0x03e2cf6bc604ddb1},
-      {0xa6539930bf6bff45, 0x84db8346b786151d},
-      {0xcfe87f7cef46ff16, 0xe612641865679a64},
-      {0x81f14fae158c5f6e, 0x4fcb7e8f3f60c07f},
-      {0xa26da3999aef7749, 0xe3be5e330f38f09e},
-      {0xcb090c8001ab551c, 0x5cadf5bfd3072cc6},
-      {0xfdcb4fa002162a63, 0x73d9732fc7c8f7f7},
-      {0x9e9f11c4014dda7e, 0x2867e7fddcdd9afb},
-      {0xc646d63501a1511d, 0xb281e1fd541501b9},
-      {0xf7d88bc24209a565, 0x1f225a7ca91a4227},
-      {0x9ae757596946075f, 0x3375788de9b06959},
-      {0xc1a12d2fc3978937, 0x0052d6b1641c83af},
-      {0xf209787bb47d6b84, 0xc0678c5dbd23a49b},
-      {0x9745eb4d50ce6332, 0xf840b7ba963646e1},
-      {0xbd176620a501fbff, 0xb650e5a93bc3d899},
-      {0xec5d3fa8ce427aff, 0xa3e51f138ab4cebf},
-      {0x93ba47c980e98cdf, 0xc66f336c36b10138},
-      {0xb8a8d9bbe123f017, 0xb80b0047445d4185},
-      {0xe6d3102ad96cec1d, 0xa60dc059157491e6},
-      {0x9043ea1ac7e41392, 0x87c89837ad68db30},
-      {0xb454e4a179dd1877, 0x29babe4598c311fc},
-      {0xe16a1dc9d8545e94, 0xf4296dd6fef3d67b},
-      {0x8ce2529e2734bb1d, 0x1899e4a65f58660d},
-      {0xb01ae745b101e9e4, 0x5ec05dcff72e7f90},
-      {0xdc21a1171d42645d, 0x76707543f4fa1f74},
-      {0x899504ae72497eba, 0x6a06494a791c53a9},
-      {0xabfa45da0edbde69, 0x0487db9d17636893},
-      {0xd6f8d7509292d603, 0x45a9d2845d3c42b7},
-      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b3},
-      {0xa7f26836f282b732, 0x8e6cac7768d7141f},
-      {0xd1ef0244af2364ff, 0x3207d795430cd927},
-      {0x8335616aed761f1f, 0x7f44e6bd49e807b9},
-      {0xa402b9c5a8d3a6e7, 0x5f16206c9c6209a7},
-      {0xcd036837130890a1, 0x36dba887c37a8c10},
-      {0x802221226be55a64, 0xc2494954da2c978a},
-      {0xa02aa96b06deb0fd, 0xf2db9baa10b7bd6d},
-      {0xc83553c5c8965d3d, 0x6f92829494e5acc8},
-      {0xfa42a8b73abbf48c, 0xcb772339ba1f17fa},
-      {0x9c69a97284b578d7, 0xff2a760414536efc},
-      {0xc38413cf25e2d70d, 0xfef5138519684abb},
-      {0xf46518c2ef5b8cd1, 0x7eb258665fc25d6a},
-      {0x98bf2f79d5993802, 0xef2f773ffbd97a62},
-      {0xbeeefb584aff8603, 0xaafb550ffacfd8fb},
-      {0xeeaaba2e5dbf6784, 0x95ba2a53f983cf39},
-      {0x952ab45cfa97a0b2, 0xdd945a747bf26184},
-      {0xba756174393d88df, 0x94f971119aeef9e5},
-      {0xe912b9d1478ceb17, 0x7a37cd5601aab85e},
-      {0x91abb422ccb812ee, 0xac62e055c10ab33b},
-      {0xb616a12b7fe617aa, 0x577b986b314d600a},
-      {0xe39c49765fdf9d94, 0xed5a7e85fda0b80c},
-      {0x8e41ade9fbebc27d, 0x14588f13be847308},
-      {0xb1d219647ae6b31c, 0x596eb2d8ae258fc9},
-      {0xde469fbd99a05fe3, 0x6fca5f8ed9aef3bc},
-      {0x8aec23d680043bee, 0x25de7bb9480d5855},
-      {0xada72ccc20054ae9, 0xaf561aa79a10ae6b},
-      {0xd910f7ff28069da4, 0x1b2ba1518094da05},
-      {0x87aa9aff79042286, 0x90fb44d2f05d0843},
-      {0xa99541bf57452b28, 0x353a1607ac744a54},
-      {0xd3fa922f2d1675f2, 0x42889b8997915ce9},
-      {0x847c9b5d7c2e09b7, 0x69956135febada12},
-      {0xa59bc234db398c25, 0x43fab9837e699096},
-      {0xcf02b2c21207ef2e, 0x94f967e45e03f4bc},
-      {0x8161afb94b44f57d, 0x1d1be0eebac278f6},
-      {0xa1ba1ba79e1632dc, 0x6462d92a69731733},
-      {0xca28a291859bbf93, 0x7d7b8f7503cfdcff},
-      {0xfcb2cb35e702af78, 0x5cda735244c3d43f},
-      {0x9defbf01b061adab, 0x3a0888136afa64a8},
-      {0xc56baec21c7a1916, 0x088aaa1845b8fdd1},
-      {0xf6c69a72a3989f5b, 0x8aad549e57273d46},
-      {0x9a3c2087a63f6399, 0x36ac54e2f678864c},
-      {0xc0cb28a98fcf3c7f, 0x84576a1bb416a7de},
-      {0xf0fdf2d3f3c30b9f, 0x656d44a2a11c51d6},
-      {0x969eb7c47859e743, 0x9f644ae5a4b1b326},
-      {0xbc4665b596706114, 0x873d5d9f0dde1fef},
-      {0xeb57ff22fc0c7959, 0xa90cb506d155a7eb},
-      {0x9316ff75dd87cbd8, 0x09a7f12442d588f3},
-      {0xb7dcbf5354e9bece, 0x0c11ed6d538aeb30},
-      {0xe5d3ef282a242e81, 0x8f1668c8a86da5fb},
-      {0x8fa475791a569d10, 0xf96e017d694487bd},
-      {0xb38d92d760ec4455, 0x37c981dcc395a9ad},
-      {0xe070f78d3927556a, 0x85bbe253f47b1418},
-      {0x8c469ab843b89562, 0x93956d7478ccec8f},
-      {0xaf58416654a6babb, 0x387ac8d1970027b3},
-      {0xdb2e51bfe9d0696a, 0x06997b05fcc0319f},
-      {0x88fcf317f22241e2, 0x441fece3bdf81f04},
-      {0xab3c2fddeeaad25a, 0xd527e81cad7626c4},
-      {0xd60b3bd56a5586f1, 0x8a71e223d8d3b075},
-      {0x85c7056562757456, 0xf6872d5667844e4a},
-      {0xa738c6bebb12d16c, 0xb428f8ac016561dc},
-      {0xd106f86e69d785c7, 0xe13336d701beba53},
-      {0x82a45b450226b39c, 0xecc0024661173474},
-      {0xa34d721642b06084, 0x27f002d7f95d0191},
-      {0xcc20ce9bd35c78a5, 0x31ec038df7b441f5},
-      {0xff290242c83396ce, 0x7e67047175a15272},
-      {0x9f79a169bd203e41, 0x0f0062c6e984d387},
-      {0xc75809c42c684dd1, 0x52c07b78a3e60869},
-      {0xf92e0c3537826145, 0xa7709a56ccdf8a83},
-      {0x9bbcc7a142b17ccb, 0x88a66076400bb692},
-      {0xc2abf989935ddbfe, 0x6acff893d00ea436},
-      {0xf356f7ebf83552fe, 0x0583f6b8c4124d44},
-      {0x98165af37b2153de, 0xc3727a337a8b704b},
-      {0xbe1bf1b059e9a8d6, 0x744f18c0592e4c5d},
-      {0xeda2ee1c7064130c, 0x1162def06f79df74},
-      {0x9485d4d1c63e8be7, 0x8addcb5645ac2ba9},
-      {0xb9a74a0637ce2ee1, 0x6d953e2bd7173693},
-      {0xe8111c87c5c1ba99, 0xc8fa8db6ccdd0438},
-      {0x910ab1d4db9914a0, 0x1d9c9892400a22a3},
-      {0xb54d5e4a127f59c8, 0x2503beb6d00cab4c},
-      {0xe2a0b5dc971f303a, 0x2e44ae64840fd61e},
-      {0x8da471a9de737e24, 0x5ceaecfed289e5d3},
-      {0xb10d8e1456105dad, 0x7425a83e872c5f48},
-      {0xdd50f1996b947518, 0xd12f124e28f7771a},
-      {0x8a5296ffe33cc92f, 0x82bd6b70d99aaa70},
-      {0xace73cbfdc0bfb7b, 0x636cc64d1001550c},
-      {0xd8210befd30efa5a, 0x3c47f7e05401aa4f},
-      {0x8714a775e3e95c78, 0x65acfaec34810a72},
-      {0xa8d9d1535ce3b396, 0x7f1839a741a14d0e},
-      {0xd31045a8341ca07c, 0x1ede48111209a051},
-      {0x83ea2b892091e44d, 0x934aed0aab460433},
-      {0xa4e4b66b68b65d60, 0xf81da84d56178540},
-      {0xce1de40642e3f4b9, 0x36251260ab9d668f},
-      {0x80d2ae83e9ce78f3, 0xc1d72b7c6b42601a},
-      {0xa1075a24e4421730, 0xb24cf65b8612f820},
-      {0xc94930ae1d529cfc, 0xdee033f26797b628},
-      {0xfb9b7cd9a4a7443c, 0x169840ef017da3b2},
-      {0x9d412e0806e88aa5, 0x8e1f289560ee864f},
-      {0xc491798a08a2ad4e, 0xf1a6f2bab92a27e3},
-      {0xf5b5d7ec8acb58a2, 0xae10af696774b1dc},
-      {0x9991a6f3d6bf1765, 0xacca6da1e0a8ef2a},
-      {0xbff610b0cc6edd3f, 0x17fd090a58d32af4},
-      {0xeff394dcff8a948e, 0xddfc4b4cef07f5b1},
-      {0x95f83d0a1fb69cd9, 0x4abdaf101564f98f},
-      {0xbb764c4ca7a4440f, 0x9d6d1ad41abe37f2},
-      {0xea53df5fd18d5513, 0x84c86189216dc5ee},
-      {0x92746b9be2f8552c, 0x32fd3cf5b4e49bb5},
-      {0xb7118682dbb66a77, 0x3fbc8c33221dc2a2},
-      {0xe4d5e82392a40515, 0x0fabaf3feaa5334b},
-      {0x8f05b1163ba6832d, 0x29cb4d87f2a7400f},
-      {0xb2c71d5bca9023f8, 0x743e20e9ef511013},
-      {0xdf78e4b2bd342cf6, 0x914da9246b255417},
-      {0x8bab8eefb6409c1a, 0x1ad089b6c2f7548f},
-      {0xae9672aba3d0c320, 0xa184ac2473b529b2},
-      {0xda3c0f568cc4f3e8, 0xc9e5d72d90a2741f},
-      {0x8865899617fb1871, 0x7e2fa67c7a658893},
-      {0xaa7eebfb9df9de8d, 0xddbb901b98feeab8},
-      {0xd51ea6fa85785631, 0x552a74227f3ea566},
-      {0x8533285c936b35de, 0xd53a88958f872760},
-      {0xa67ff273b8460356, 0x8a892abaf368f138},
-      {0xd01fef10a657842c, 0x2d2b7569b0432d86},
-      {0x8213f56a67f6b29b, 0x9c3b29620e29fc74},
-      {0xa298f2c501f45f42, 0x8349f3ba91b47b90},
-      {0xcb3f2f7642717713, 0x241c70a936219a74},
-      {0xfe0efb53d30dd4d7, 0xed238cd383aa0111},
-      {0x9ec95d1463e8a506, 0xf4363804324a40ab},
-      {0xc67bb4597ce2ce48, 0xb143c6053edcd0d6},
-      {0xf81aa16fdc1b81da, 0xdd94b7868e94050b},
-      {0x9b10a4e5e9913128, 0xca7cf2b4191c8327},
-      {0xc1d4ce1f63f57d72, 0xfd1c2f611f63a3f1},
-      {0xf24a01a73cf2dccf, 0xbc633b39673c8ced},
-      {0x976e41088617ca01, 0xd5be0503e085d814},
-      {0xbd49d14aa79dbc82, 0x4b2d8644d8a74e19},
-      {0xec9c459d51852ba2, 0xddf8e7d60ed1219f},
-      {0x93e1ab8252f33b45, 0xcabb90e5c942b504},
-      {0xb8da1662e7b00a17, 0x3d6a751f3b936244},
-      {0xe7109bfba19c0c9d, 0x0cc512670a783ad5},
-      {0x906a617d450187e2, 0x27fb2b80668b24c6},
-      {0xb484f9dc9641e9da, 0xb1f9f660802dedf7},
-      {0xe1a63853bbd26451, 0x5e7873f8a0396974},
-      {0x8d07e33455637eb2, 0xdb0b487b6423e1e9},
-      {0xb049dc016abc5e5f, 0x91ce1a9a3d2cda63},
-      {0xdc5c5301c56b75f7, 0x7641a140cc7810fc},
-      {0x89b9b3e11b6329ba, 0xa9e904c87fcb0a9e},
-      {0xac2820d9623bf429, 0x546345fa9fbdcd45},
-      {0xd732290fbacaf133, 0xa97c177947ad4096},
-      {0x867f59a9d4bed6c0, 0x49ed8eabcccc485e},
-      {0xa81f301449ee8c70, 0x5c68f256bfff5a75},
-      {0xd226fc195c6a2f8c, 0x73832eec6fff3112},
-      {0x83585d8fd9c25db7, 0xc831fd53c5ff7eac},
-      {0xa42e74f3d032f525, 0xba3e7ca8b77f5e56},
-      {0xcd3a1230c43fb26f, 0x28ce1bd2e55f35ec},
-      {0x80444b5e7aa7cf85, 0x7980d163cf5b81b4},
-      {0xa0555e361951c366, 0xd7e105bcc3326220},
-      {0xc86ab5c39fa63440, 0x8dd9472bf3fefaa8},
-      {0xfa856334878fc150, 0xb14f98f6f0feb952},
-      {0x9c935e00d4b9d8d2, 0x6ed1bf9a569f33d4},
-      {0xc3b8358109e84f07, 0x0a862f80ec4700c9},
-      {0xf4a642e14c6262c8, 0xcd27bb612758c0fb},
-      {0x98e7e9cccfbd7dbd, 0x8038d51cb897789d},
-      {0xbf21e44003acdd2c, 0xe0470a63e6bd56c4},
-      {0xeeea5d5004981478, 0x1858ccfce06cac75},
-      {0x95527a5202df0ccb, 0x0f37801e0c43ebc9},
-      {0xbaa718e68396cffd, 0xd30560258f54e6bb},
-      {0xe950df20247c83fd, 0x47c6b82ef32a206a},
-      {0x91d28b7416cdd27e, 0x4cdc331d57fa5442},
-      {0xb6472e511c81471d, 0xe0133fe4adf8e953},
-      {0xe3d8f9e563a198e5, 0x58180fddd97723a7},
-      {0x8e679c2f5e44ff8f, 0x570f09eaa7ea7649},
-      {0xb201833b35d63f73, 0x2cd2cc6551e513db},
-      {0xde81e40a034bcf4f, 0xf8077f7ea65e58d2},
-      {0x8b112e86420f6191, 0xfb04afaf27faf783},
-      {0xadd57a27d29339f6, 0x79c5db9af1f9b564},
-      {0xd94ad8b1c7380874, 0x18375281ae7822bd},
-      {0x87cec76f1c830548, 0x8f2293910d0b15b6},
-      {0xa9c2794ae3a3c69a, 0xb2eb3875504ddb23},
-      {0xd433179d9c8cb841, 0x5fa60692a46151ec},
-      {0x849feec281d7f328, 0xdbc7c41ba6bcd334},
-      {0xa5c7ea73224deff3, 0x12b9b522906c0801},
-      {0xcf39e50feae16bef, 0xd768226b34870a01},
-      {0x81842f29f2cce375, 0xe6a1158300d46641},
-      {0xa1e53af46f801c53, 0x60495ae3c1097fd1},
-      {0xca5e89b18b602368, 0x385bb19cb14bdfc5},
-      {0xfcf62c1dee382c42, 0x46729e03dd9ed7b6},
-      {0x9e19db92b4e31ba9, 0x6c07a2c26a8346d2},
-      {0xc5a05277621be293, 0xc7098b7305241886},
-      {0xf70867153aa2db38, 0xb8cbee4fc66d1ea8},
-      {0x9a65406d44a5c903, 0x737f74f1dc043329},
-      {0xc0fe908895cf3b44, 0x505f522e53053ff3},
-      {0xf13e34aabb430a15, 0x647726b9e7c68ff0},
-      {0x96c6e0eab509e64d, 0x5eca783430dc19f6},
-      {0xbc789925624c5fe0, 0xb67d16413d132073},
-      {0xeb96bf6ebadf77d8, 0xe41c5bd18c57e890},
-      {0x933e37a534cbaae7, 0x8e91b962f7b6f15a},
-      {0xb80dc58e81fe95a1, 0x723627bbb5a4adb1},
-      {0xe61136f2227e3b09, 0xcec3b1aaa30dd91d},
-      {0x8fcac257558ee4e6, 0x213a4f0aa5e8a7b2},
-      {0xb3bd72ed2af29e1f, 0xa988e2cd4f62d19e},
-      {0xe0accfa875af45a7, 0x93eb1b80a33b8606},
-      {0x8c6c01c9498d8b88, 0xbc72f130660533c4},
-      {0xaf87023b9bf0ee6a, 0xeb8fad7c7f8680b5},
-      {0xdb68c2ca82ed2a05, 0xa67398db9f6820e2},
-#else
-      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
-      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
-      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
-      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
-      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
-      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
-      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
-      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
-      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
-      {0x95a8637627989aad, 0xdde7001379a44aa9},
-      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
-      {0xc350000000000000, 0x0000000000000000},
-      {0x9dc5ada82b70b59d, 0xf020000000000000},
-      {0xfee50b7025c36a08, 0x02f236d04753d5b5},
-      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f87},
-      {0xa6539930bf6bff45, 0x84db8346b786151d},
-      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b3},
-      {0xd910f7ff28069da4, 0x1b2ba1518094da05},
-      {0xaf58416654a6babb, 0x387ac8d1970027b3},
-      {0x8da471a9de737e24, 0x5ceaecfed289e5d3},
-      {0xe4d5e82392a40515, 0x0fabaf3feaa5334b},
-      {0xb8da1662e7b00a17, 0x3d6a751f3b936244},
-      {0x95527a5202df0ccb, 0x0f37801e0c43ebc9},
-      {0xf13e34aabb430a15, 0x647726b9e7c68ff0}
-#endif
-    };
-
-#if FMT_USE_FULL_CACHE_DRAGONBOX
-    return pow10_significands[k - float_info<double>::min_k];
-#else
-    static constexpr const uint64_t powers_of_5_64[] = {
-        0x0000000000000001, 0x0000000000000005, 0x0000000000000019,
-        0x000000000000007d, 0x0000000000000271, 0x0000000000000c35,
-        0x0000000000003d09, 0x000000000001312d, 0x000000000005f5e1,
-        0x00000000001dcd65, 0x00000000009502f9, 0x0000000002e90edd,
-        0x000000000e8d4a51, 0x0000000048c27395, 0x000000016bcc41e9,
-        0x000000071afd498d, 0x0000002386f26fc1, 0x000000b1a2bc2ec5,
-        0x000003782dace9d9, 0x00001158e460913d, 0x000056bc75e2d631,
-        0x0001b1ae4d6e2ef5, 0x000878678326eac9, 0x002a5a058fc295ed,
-        0x00d3c21bcecceda1, 0x0422ca8b0a00a425, 0x14adf4b7320334b9};
-
-    static const int compression_ratio = 27;
-
-    // Compute base index.
-    int cache_index = (k - float_info<double>::min_k) / compression_ratio;
-    int kb = cache_index * compression_ratio + float_info<double>::min_k;
-    int offset = k - kb;
-
-    // Get base cache.
-    uint128_fallback base_cache = pow10_significands[cache_index];
-    if (offset == 0) return base_cache;
-
-    // Compute the required amount of bit-shift.
-    int alpha = floor_log2_pow10(kb + offset) - floor_log2_pow10(kb) - offset;
-    FMT_ASSERT(alpha > 0 && alpha < 64, "shifting error detected");
-
-    // Try to recover the real cache.
-    uint64_t pow5 = powers_of_5_64[offset];
-    uint128_fallback recovered_cache = umul128(base_cache.high(), pow5);
-    uint128_fallback middle_low = umul128(base_cache.low(), pow5);
-
-    recovered_cache += middle_low.high();
-
-    uint64_t high_to_middle = recovered_cache.high() << (64 - alpha);
-    uint64_t middle_to_low = recovered_cache.low() << (64 - alpha);
-
-    recovered_cache =
-        uint128_fallback{(recovered_cache.low() >> alpha) | high_to_middle,
-                         ((middle_low.low() >> alpha) | middle_to_low)};
-    FMT_ASSERT(recovered_cache.low() + 1 != 0, "");
-    return {recovered_cache.high(), recovered_cache.low() + 1};
-#endif
-  }
-
-  struct compute_mul_result {
-    carrier_uint result;
-    bool is_integer;
-  };
-  struct compute_mul_parity_result {
-    bool parity;
-    bool is_integer;
-  };
-
-  static auto compute_mul(carrier_uint u,
-                          const cache_entry_type& cache) noexcept
-      -> compute_mul_result {
-    auto r = umul192_upper128(u, cache);
-    return {r.high(), r.low() == 0};
-  }
-
-  static auto compute_delta(cache_entry_type const& cache, int beta) noexcept
-      -> uint32_t {
-    return static_cast<uint32_t>(cache.high() >> (64 - 1 - beta));
-  }
-
-  static auto compute_mul_parity(carrier_uint two_f,
-                                 const cache_entry_type& cache,
-                                 int beta) noexcept
-      -> compute_mul_parity_result {
-    FMT_ASSERT(beta >= 1, "");
-    FMT_ASSERT(beta < 64, "");
-
-    auto r = umul192_lower128(two_f, cache);
-    return {((r.high() >> (64 - beta)) & 1) != 0,
-            ((r.high() << beta) | (r.low() >> (64 - beta))) == 0};
-  }
-
-  static auto compute_left_endpoint_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta) noexcept -> carrier_uint {
-    return (cache.high() -
-            (cache.high() >> (num_significand_bits<double>() + 2))) >>
-           (64 - num_significand_bits<double>() - 1 - beta);
-  }
-
-  static auto compute_right_endpoint_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta) noexcept -> carrier_uint {
-    return (cache.high() +
-            (cache.high() >> (num_significand_bits<double>() + 1))) >>
-           (64 - num_significand_bits<double>() - 1 - beta);
-  }
-
-  static auto compute_round_up_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta) noexcept -> carrier_uint {
-    return ((cache.high() >> (64 - num_significand_bits<double>() - 2 - beta)) +
-            1) /
-           2;
-  }
-};
-
-FMT_FUNC auto get_cached_power(int k) noexcept -> uint128_fallback {
-  return cache_accessor<double>::get_cached_power(k);
-}
-
-// Various integer checks
-template <typename T>
-auto is_left_endpoint_integer_shorter_interval(int exponent) noexcept -> bool {
-  const int case_shorter_interval_left_endpoint_lower_threshold = 2;
-  const int case_shorter_interval_left_endpoint_upper_threshold = 3;
-  return exponent >= case_shorter_interval_left_endpoint_lower_threshold &&
-         exponent <= case_shorter_interval_left_endpoint_upper_threshold;
-}
-
-// Remove trailing zeros from n and return the number of zeros removed (float)
-FMT_INLINE int remove_trailing_zeros(uint32_t& n, int s = 0) noexcept {
-  FMT_ASSERT(n != 0, "");
-  // Modular inverse of 5 (mod 2^32): (mod_inv_5 * 5) mod 2^32 = 1.
-  constexpr uint32_t mod_inv_5 = 0xcccccccd;
-  constexpr uint32_t mod_inv_25 = 0xc28f5c29;  // = mod_inv_5 * mod_inv_5
-
-  while (true) {
-    auto q = rotr(n * mod_inv_25, 2);
-    if (q > max_value<uint32_t>() / 100) break;
-    n = q;
-    s += 2;
-  }
-  auto q = rotr(n * mod_inv_5, 1);
-  if (q <= max_value<uint32_t>() / 10) {
-    n = q;
-    s |= 1;
-  }
-  return s;
-}
-
-// Removes trailing zeros and returns the number of zeros removed (double)
-FMT_INLINE int remove_trailing_zeros(uint64_t& n) noexcept {
-  FMT_ASSERT(n != 0, "");
-
-  // This magic number is ceil(2^90 / 10^8).
-  constexpr uint64_t magic_number = 12379400392853802749ull;
-  auto nm = umul128(n, magic_number);
-
-  // Is n is divisible by 10^8?
-  if ((nm.high() & ((1ull << (90 - 64)) - 1)) == 0 && nm.low() < magic_number) {
-    // If yes, work with the quotient...
-    auto n32 = static_cast<uint32_t>(nm.high() >> (90 - 64));
-    // ... and use the 32 bit variant of the function
-    int s = remove_trailing_zeros(n32, 8);
-    n = n32;
-    return s;
-  }
-
-  // If n is not divisible by 10^8, work with n itself.
-  constexpr uint64_t mod_inv_5 = 0xcccccccccccccccd;
-  constexpr uint64_t mod_inv_25 = 0x8f5c28f5c28f5c29;  // mod_inv_5 * mod_inv_5
-
-  int s = 0;
-  while (true) {
-    auto q = rotr(n * mod_inv_25, 2);
-    if (q > max_value<uint64_t>() / 100) break;
-    n = q;
-    s += 2;
-  }
-  auto q = rotr(n * mod_inv_5, 1);
-  if (q <= max_value<uint64_t>() / 10) {
-    n = q;
-    s |= 1;
-  }
-
-  return s;
-}
-
-// The main algorithm for shorter interval case
-template <typename T>
-FMT_INLINE decimal_fp<T> shorter_interval_case(int exponent) noexcept {
-  decimal_fp<T> ret_value;
-  // Compute k and beta
-  const int minus_k = floor_log10_pow2_minus_log10_4_over_3(exponent);
-  const int beta = exponent + floor_log2_pow10(-minus_k);
-
-  // Compute xi and zi
-  using cache_entry_type = typename cache_accessor<T>::cache_entry_type;
-  const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);
-
-  auto xi = cache_accessor<T>::compute_left_endpoint_for_shorter_interval_case(
-      cache, beta);
-  auto zi = cache_accessor<T>::compute_right_endpoint_for_shorter_interval_case(
-      cache, beta);
-
-  // If the left endpoint is not an integer, increase it
-  if (!is_left_endpoint_integer_shorter_interval<T>(exponent)) ++xi;
-
-  // Try bigger divisor
-  ret_value.significand = zi / 10;
-
-  // If succeed, remove trailing zeros if necessary and return
-  if (ret_value.significand * 10 >= xi) {
-    ret_value.exponent = minus_k + 1;
-    ret_value.exponent += remove_trailing_zeros(ret_value.significand);
-    return ret_value;
-  }
-
-  // Otherwise, compute the round-up of y
-  ret_value.significand =
-      cache_accessor<T>::compute_round_up_for_shorter_interval_case(cache,
-                                                                    beta);
-  ret_value.exponent = minus_k;
-
-  // When tie occurs, choose one of them according to the rule
-  if (exponent >= float_info<T>::shorter_interval_tie_lower_threshold &&
-      exponent <= float_info<T>::shorter_interval_tie_upper_threshold) {
-    ret_value.significand = ret_value.significand % 2 == 0
-                                ? ret_value.significand
-                                : ret_value.significand - 1;
-  } else if (ret_value.significand < xi) {
-    ++ret_value.significand;
-  }
-  return ret_value;
-}
-
-template <typename T> auto to_decimal(T x) noexcept -> decimal_fp<T> {
-  // Step 1: integer promotion & Schubfach multiplier calculation.
-
-  using carrier_uint = typename float_info<T>::carrier_uint;
-  using cache_entry_type = typename cache_accessor<T>::cache_entry_type;
-  auto br = bit_cast<carrier_uint>(x);
-
-  // Extract significand bits and exponent bits.
-  const carrier_uint significand_mask =
-      (static_cast<carrier_uint>(1) << num_significand_bits<T>()) - 1;
-  carrier_uint significand = (br & significand_mask);
-  int exponent =
-      static_cast<int>((br & exponent_mask<T>()) >> num_significand_bits<T>());
-
-  if (exponent != 0) {  // Check if normal.
-    exponent -= exponent_bias<T>() + num_significand_bits<T>();
-
-    // Shorter interval case; proceed like Schubfach.
-    // In fact, when exponent == 1 and significand == 0, the interval is
-    // regular. However, it can be shown that the end-results are anyway same.
-    if (significand == 0) return shorter_interval_case<T>(exponent);
-
-    significand |= (static_cast<carrier_uint>(1) << num_significand_bits<T>());
-  } else {
-    // Subnormal case; the interval is always regular.
-    if (significand == 0) return {0, 0};
-    exponent =
-        std::numeric_limits<T>::min_exponent - num_significand_bits<T>() - 1;
-  }
-
-  const bool include_left_endpoint = (significand % 2 == 0);
-  const bool include_right_endpoint = include_left_endpoint;
-
-  // Compute k and beta.
-  const int minus_k = floor_log10_pow2(exponent) - float_info<T>::kappa;
-  const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);
-  const int beta = exponent + floor_log2_pow10(-minus_k);
-
-  // Compute zi and deltai.
-  // 10^kappa <= deltai < 10^(kappa + 1)
-  const uint32_t deltai = cache_accessor<T>::compute_delta(cache, beta);
-  const carrier_uint two_fc = significand << 1;
-
-  // For the case of binary32, the result of integer check is not correct for
-  // 29711844 * 2^-82
-  // = 6.1442653300000000008655037797566933477355632930994033813476... * 10^-18
-  // and 29711844 * 2^-81
-  // = 1.2288530660000000001731007559513386695471126586198806762695... * 10^-17,
-  // and they are the unique counterexamples. However, since 29711844 is even,
-  // this does not cause any problem for the endpoints calculations; it can only
-  // cause a problem when we need to perform integer check for the center.
-  // Fortunately, with these inputs, that branch is never executed, so we are
-  // fine.
-  const typename cache_accessor<T>::compute_mul_result z_mul =
-      cache_accessor<T>::compute_mul((two_fc | 1) << beta, cache);
-
-  // Step 2: Try larger divisor; remove trailing zeros if necessary.
-
-  // Using an upper bound on zi, we might be able to optimize the division
-  // better than the compiler; we are computing zi / big_divisor here.
-  decimal_fp<T> ret_value;
-  ret_value.significand = divide_by_10_to_kappa_plus_1(z_mul.result);
-  uint32_t r = static_cast<uint32_t>(z_mul.result - float_info<T>::big_divisor *
-                                                        ret_value.significand);
-
-  if (r < deltai) {
-    // Exclude the right endpoint if necessary.
-    if (r == 0 && (z_mul.is_integer & !include_right_endpoint)) {
-      --ret_value.significand;
-      r = float_info<T>::big_divisor;
-      goto small_divisor_case_label;
-    }
-  } else if (r > deltai) {
-    goto small_divisor_case_label;
-  } else {
-    // r == deltai; compare fractional parts.
-    const typename cache_accessor<T>::compute_mul_parity_result x_mul =
-        cache_accessor<T>::compute_mul_parity(two_fc - 1, cache, beta);
-
-    if (!(x_mul.parity | (x_mul.is_integer & include_left_endpoint)))
-      goto small_divisor_case_label;
-  }
-  ret_value.exponent = minus_k + float_info<T>::kappa + 1;
-
-  // We may need to remove trailing zeros.
-  ret_value.exponent += remove_trailing_zeros(ret_value.significand);
-  return ret_value;
-
-  // Step 3: Find the significand with the smaller divisor.
-
-small_divisor_case_label:
-  ret_value.significand *= 10;
-  ret_value.exponent = minus_k + float_info<T>::kappa;
-
-  uint32_t dist = r - (deltai / 2) + (float_info<T>::small_divisor / 2);
-  const bool approx_y_parity =
-      ((dist ^ (float_info<T>::small_divisor / 2)) & 1) != 0;
-
-  // Is dist divisible by 10^kappa?
-  const bool divisible_by_small_divisor =
-      check_divisibility_and_divide_by_pow10<float_info<T>::kappa>(dist);
-
-  // Add dist / 10^kappa to the significand.
-  ret_value.significand += dist;
-
-  if (!divisible_by_small_divisor) return ret_value;
-
-  // Check z^(f) >= epsilon^(f).
-  // We have either yi == zi - epsiloni or yi == (zi - epsiloni) - 1,
-  // where yi == zi - epsiloni if and only if z^(f) >= epsilon^(f).
-  // Since there are only 2 possibilities, we only need to care about the
-  // parity. Also, zi and r should have the same parity since the divisor
-  // is an even number.
-  const auto y_mul = cache_accessor<T>::compute_mul_parity(two_fc, cache, beta);
-
-  // If z^(f) >= epsilon^(f), we might have a tie when z^(f) == epsilon^(f),
-  // or equivalently, when y is an integer.
-  if (y_mul.parity != approx_y_parity)
-    --ret_value.significand;
-  else if (y_mul.is_integer & (ret_value.significand % 2 != 0))
-    --ret_value.significand;
-  return ret_value;
-}
-}  // namespace dragonbox
 }  // namespace detail
 
-template <> struct formatter<detail::bigint> {
-  FMT_CONSTEXPR auto parse(format_parse_context& ctx)
-      -> format_parse_context::iterator {
-    return ctx.begin();
-  }
-
-  auto format(const detail::bigint& n, format_context& ctx) const
-      -> format_context::iterator {
-    auto out = ctx.out();
-    bool first = true;
-    for (auto i = n.bigits_.size(); i > 0; --i) {
-      auto value = n.bigits_[i - 1u];
-      if (first) {
-        out = fmt::format_to(out, FMT_STRING("{:x}"), value);
-        first = false;
-        continue;
-      }
-      out = fmt::format_to(out, FMT_STRING("{:08x}"), value);
-    }
-    if (n.exp_ > 0)
-      out = fmt::format_to(out, FMT_STRING("p{}"),
-                           n.exp_ * detail::bigint::bigit_bits);
-    return out;
-  }
-};
-
 FMT_FUNC detail::utf8_to_utf16::utf8_to_utf16(string_view s) {
   for_each_codepoint(s, [this](uint32_t cp, string_view) {
-    if (cp == invalid_code_point) FMT_THROW(std::runtime_error("invalid utf8"));
+    if (cp == invalid_code_point) FMT_THROW("invalid utf8");
     if (cp <= 0xFFFF) {
       buffer_.push_back(static_cast<wchar_t>(cp));
     } else {
@@ -1406,23 +50,6 @@
   });
   buffer_.push_back(0);
 }
-
-FMT_FUNC void format_system_error(detail::buffer<char>& out, int error_code,
-                                  const char* message) noexcept {
-  FMT_TRY {
-    auto ec = std::error_code(error_code, std::generic_category());
-    write(std::back_inserter(out), std::system_error(ec, message).what());
-    return;
-  }
-  FMT_CATCH(...) {}
-  format_error_code(out, error_code, message);
-}
-
-FMT_FUNC void report_system_error(int error_code,
-                                  const char* message) noexcept {
-  report_error(format_system_error, error_code, message);
-}
-
 FMT_FUNC auto vformat(string_view fmt, format_args args) -> std::string {
   // Don't optimize the "{}" case to keep the binary size small and because it
   // can be better optimized in fmt::format anyway.
@@ -1430,55 +57,9 @@
   detail::vformat_to(buffer, fmt, args);
   return to_string(buffer);
 }
+FMT_FUNC void vprint(string_view fmt, format_args args) {}
 
 namespace detail {
-#if !defined(_WIN32) || defined(FMT_WINDOWS_NO_WCHAR)
-FMT_FUNC auto write_console(int, string_view) -> bool { return false; }
-#else
-using dword = conditional_t<sizeof(long) == 4, unsigned long, unsigned>;
-extern "C" __declspec(dllimport) int __stdcall WriteConsoleW(  //
-    void*, const void*, dword, dword*, void*);
-
-FMT_FUNC bool write_console(int fd, string_view text) {
-  auto u16 = utf8_to_utf16(text);
-  return WriteConsoleW(reinterpret_cast<void*>(_get_osfhandle(fd)), u16.c_str(),
-                       static_cast<dword>(u16.size()), nullptr, nullptr) != 0;
-}
-#endif
-
-#ifdef _WIN32
-// Print assuming legacy (non-Unicode) encoding.
-FMT_FUNC void vprint_mojibake(std::FILE* f, string_view fmt, format_args args) {
-  auto buffer = memory_buffer();
-  detail::vformat_to(buffer, fmt, args);
-  fwrite_fully(buffer.data(), buffer.size(), f);
-}
-#endif
-
-FMT_FUNC void print(std::FILE* f, string_view text) {
-#ifdef _WIN32
-  int fd = _fileno(f);
-  if (_isatty(fd)) {
-    std::fflush(f);
-    if (write_console(fd, text)) return;
-  }
-#endif
-  fwrite_fully(text.data(), text.size(), f);
-}
-}  // namespace detail
-
-FMT_FUNC void vprint(std::FILE* f, string_view fmt, format_args args) {
-  auto buffer = memory_buffer();
-  detail::vformat_to(buffer, fmt, args);
-  detail::print(f, {buffer.data(), buffer.size()});
-}
-
-FMT_FUNC void vprint(string_view fmt, format_args args) {
-  vprint(stdout, fmt, args);
-}
-
-namespace detail {
-
 struct singleton {
   unsigned char upper;
   unsigned char lower_count;
@@ -1514,7 +95,6 @@
   }
   return current;
 }
-
 // This code is generated by support/printable.py.
 FMT_FUNC auto is_printable(uint32_t cp) -> bool {
   static constexpr singleton singletons0[] = {
@@ -1667,7 +247,5 @@
 }
 
 }  // namespace detail
-
 FMT_END_NAMESPACE
-
 #endif  // FMT_FORMAT_INL_H_
diff --color -Naur fmt-original/include/fmt/os.h fmt-10.2.0/include/fmt/os.h
--- fmt-original/include/fmt/os.h	2025-07-16 22:36:59.479481573 +0200
+++ fmt-10.2.0/include/fmt/os.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,455 +0,0 @@
-// Formatting library for C++ - optional OS-specific functionality
-//
-// Copyright (c) 2012 - present, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_OS_H_
-#define FMT_OS_H_
-
-#include <cerrno>
-#include <cstddef>
-#include <cstdio>
-#include <system_error>  // std::system_error
-
-#include "format.h"
-
-#if defined __APPLE__ || defined(__FreeBSD__)
-#  if FMT_HAS_INCLUDE(<xlocale.h>)
-#    include <xlocale.h>  // for LC_NUMERIC_MASK on OS X
-#  endif
-#endif
-
-#ifndef FMT_USE_FCNTL
-// UWP doesn't provide _pipe.
-#  if FMT_HAS_INCLUDE("winapifamily.h")
-#    include <winapifamily.h>
-#  endif
-#  if (FMT_HAS_INCLUDE(<fcntl.h>) || defined(__APPLE__) || \
-       defined(__linux__)) &&                              \
-      (!defined(WINAPI_FAMILY) ||                          \
-       (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP))
-#    include <fcntl.h>  // for O_RDONLY
-#    define FMT_USE_FCNTL 1
-#  else
-#    define FMT_USE_FCNTL 0
-#  endif
-#endif
-
-#ifndef FMT_POSIX
-#  if defined(_WIN32) && !defined(__MINGW32__)
-// Fix warnings about deprecated symbols.
-#    define FMT_POSIX(call) _##call
-#  else
-#    define FMT_POSIX(call) call
-#  endif
-#endif
-
-// Calls to system functions are wrapped in FMT_SYSTEM for testability.
-#ifdef FMT_SYSTEM
-#  define FMT_HAS_SYSTEM
-#  define FMT_POSIX_CALL(call) FMT_SYSTEM(call)
-#else
-#  define FMT_SYSTEM(call) ::call
-#  ifdef _WIN32
-// Fix warnings about deprecated symbols.
-#    define FMT_POSIX_CALL(call) ::_##call
-#  else
-#    define FMT_POSIX_CALL(call) ::call
-#  endif
-#endif
-
-// Retries the expression while it evaluates to error_result and errno
-// equals to EINTR.
-#ifndef _WIN32
-#  define FMT_RETRY_VAL(result, expression, error_result) \
-    do {                                                  \
-      (result) = (expression);                            \
-    } while ((result) == (error_result) && errno == EINTR)
-#else
-#  define FMT_RETRY_VAL(result, expression, error_result) result = (expression)
-#endif
-
-#define FMT_RETRY(result, expression) FMT_RETRY_VAL(result, expression, -1)
-
-FMT_BEGIN_NAMESPACE
-FMT_BEGIN_EXPORT
-
-/**
-  \rst
-  A reference to a null-terminated string. It can be constructed from a C
-  string or ``std::string``.
-
-  You can use one of the following type aliases for common character types:
-
-  +---------------+-----------------------------+
-  | Type          | Definition                  |
-  +===============+=============================+
-  | cstring_view  | basic_cstring_view<char>    |
-  +---------------+-----------------------------+
-  | wcstring_view | basic_cstring_view<wchar_t> |
-  +---------------+-----------------------------+
-
-  This class is most useful as a parameter type to allow passing
-  different types of strings to a function, for example::
-
-    template <typename... Args>
-    std::string format(cstring_view format_str, const Args & ... args);
-
-    format("{}", 42);
-    format(std::string("{}"), 42);
-  \endrst
- */
-template <typename Char> class basic_cstring_view {
- private:
-  const Char* data_;
-
- public:
-  /** Constructs a string reference object from a C string. */
-  basic_cstring_view(const Char* s) : data_(s) {}
-
-  /**
-    \rst
-    Constructs a string reference from an ``std::string`` object.
-    \endrst
-   */
-  basic_cstring_view(const std::basic_string<Char>& s) : data_(s.c_str()) {}
-
-  /** Returns the pointer to a C string. */
-  auto c_str() const -> const Char* { return data_; }
-};
-
-using cstring_view = basic_cstring_view<char>;
-using wcstring_view = basic_cstring_view<wchar_t>;
-
-#ifdef _WIN32
-FMT_API const std::error_category& system_category() noexcept;
-
-namespace detail {
-FMT_API void format_windows_error(buffer<char>& out, int error_code,
-                                  const char* message) noexcept;
-}
-
-FMT_API std::system_error vwindows_error(int error_code, string_view format_str,
-                                         format_args args);
-
-/**
- \rst
- Constructs a :class:`std::system_error` object with the description
- of the form
-
- .. parsed-literal::
-   *<message>*: *<system-message>*
-
- where *<message>* is the formatted message and *<system-message>* is the
- system message corresponding to the error code.
- *error_code* is a Windows error code as given by ``GetLastError``.
- If *error_code* is not a valid error code such as -1, the system message
- will look like "error -1".
-
- **Example**::
-
-   // This throws a system_error with the description
-   //   cannot open file 'madeup': The system cannot find the file specified.
-   // or similar (system message may vary).
-   const char *filename = "madeup";
-   LPOFSTRUCT of = LPOFSTRUCT();
-   HFILE file = OpenFile(filename, &of, OF_READ);
-   if (file == HFILE_ERROR) {
-     throw fmt::windows_error(GetLastError(),
-                              "cannot open file '{}'", filename);
-   }
- \endrst
-*/
-template <typename... Args>
-std::system_error windows_error(int error_code, string_view message,
-                                const Args&... args) {
-  return vwindows_error(error_code, message, fmt::make_format_args(args...));
-}
-
-// Reports a Windows error without throwing an exception.
-// Can be used to report errors from destructors.
-FMT_API void report_windows_error(int error_code, const char* message) noexcept;
-#else
-inline auto system_category() noexcept -> const std::error_category& {
-  return std::system_category();
-}
-#endif  // _WIN32
-
-// std::system is not available on some platforms such as iOS (#2248).
-#ifdef __OSX__
-template <typename S, typename... Args, typename Char = char_t<S>>
-void say(const S& format_str, Args&&... args) {
-  std::system(format("say \"{}\"", format(format_str, args...)).c_str());
-}
-#endif
-
-// A buffered file.
-class buffered_file {
- private:
-  FILE* file_;
-
-  friend class file;
-
-  explicit buffered_file(FILE* f) : file_(f) {}
-
- public:
-  buffered_file(const buffered_file&) = delete;
-  void operator=(const buffered_file&) = delete;
-
-  // Constructs a buffered_file object which doesn't represent any file.
-  buffered_file() noexcept : file_(nullptr) {}
-
-  // Destroys the object closing the file it represents if any.
-  FMT_API ~buffered_file() noexcept;
-
- public:
-  buffered_file(buffered_file&& other) noexcept : file_(other.file_) {
-    other.file_ = nullptr;
-  }
-
-  auto operator=(buffered_file&& other) -> buffered_file& {
-    close();
-    file_ = other.file_;
-    other.file_ = nullptr;
-    return *this;
-  }
-
-  // Opens a file.
-  FMT_API buffered_file(cstring_view filename, cstring_view mode);
-
-  // Closes the file.
-  FMT_API void close();
-
-  // Returns the pointer to a FILE object representing this file.
-  auto get() const noexcept -> FILE* { return file_; }
-
-  FMT_API auto descriptor() const -> int;
-
-  void vprint(string_view format_str, format_args args) {
-    fmt::vprint(file_, format_str, args);
-  }
-
-  template <typename... Args>
-  inline void print(string_view format_str, const Args&... args) {
-    vprint(format_str, fmt::make_format_args(args...));
-  }
-};
-
-#if FMT_USE_FCNTL
-// A file. Closed file is represented by a file object with descriptor -1.
-// Methods that are not declared with noexcept may throw
-// fmt::system_error in case of failure. Note that some errors such as
-// closing the file multiple times will cause a crash on Windows rather
-// than an exception. You can get standard behavior by overriding the
-// invalid parameter handler with _set_invalid_parameter_handler.
-class FMT_API file {
- private:
-  int fd_;  // File descriptor.
-
-  // Constructs a file object with a given descriptor.
-  explicit file(int fd) : fd_(fd) {}
-
- public:
-  // Possible values for the oflag argument to the constructor.
-  enum {
-    RDONLY = FMT_POSIX(O_RDONLY),  // Open for reading only.
-    WRONLY = FMT_POSIX(O_WRONLY),  // Open for writing only.
-    RDWR = FMT_POSIX(O_RDWR),      // Open for reading and writing.
-    CREATE = FMT_POSIX(O_CREAT),   // Create if the file doesn't exist.
-    APPEND = FMT_POSIX(O_APPEND),  // Open in append mode.
-    TRUNC = FMT_POSIX(O_TRUNC)     // Truncate the content of the file.
-  };
-
-  // Constructs a file object which doesn't represent any file.
-  file() noexcept : fd_(-1) {}
-
-  // Opens a file and constructs a file object representing this file.
-  file(cstring_view path, int oflag);
-
- public:
-  file(const file&) = delete;
-  void operator=(const file&) = delete;
-
-  file(file&& other) noexcept : fd_(other.fd_) { other.fd_ = -1; }
-
-  // Move assignment is not noexcept because close may throw.
-  auto operator=(file&& other) -> file& {
-    close();
-    fd_ = other.fd_;
-    other.fd_ = -1;
-    return *this;
-  }
-
-  // Destroys the object closing the file it represents if any.
-  ~file() noexcept;
-
-  // Returns the file descriptor.
-  auto descriptor() const noexcept -> int { return fd_; }
-
-  // Closes the file.
-  void close();
-
-  // Returns the file size. The size has signed type for consistency with
-  // stat::st_size.
-  auto size() const -> long long;
-
-  // Attempts to read count bytes from the file into the specified buffer.
-  auto read(void* buffer, size_t count) -> size_t;
-
-  // Attempts to write count bytes from the specified buffer to the file.
-  auto write(const void* buffer, size_t count) -> size_t;
-
-  // Duplicates a file descriptor with the dup function and returns
-  // the duplicate as a file object.
-  static auto dup(int fd) -> file;
-
-  // Makes fd be the copy of this file descriptor, closing fd first if
-  // necessary.
-  void dup2(int fd);
-
-  // Makes fd be the copy of this file descriptor, closing fd first if
-  // necessary.
-  void dup2(int fd, std::error_code& ec) noexcept;
-
-  // Creates a pipe setting up read_end and write_end file objects for reading
-  // and writing respectively.
-  // DEPRECATED! Taking files as out parameters is deprecated.
-  static void pipe(file& read_end, file& write_end);
-
-  // Creates a buffered_file object associated with this file and detaches
-  // this file object from the file.
-  auto fdopen(const char* mode) -> buffered_file;
-
-#  if defined(_WIN32) && !defined(__MINGW32__)
-  // Opens a file and constructs a file object representing this file by
-  // wcstring_view filename. Windows only.
-  static file open_windows_file(wcstring_view path, int oflag);
-#  endif
-};
-
-// Returns the memory page size.
-auto getpagesize() -> long;
-
-namespace detail {
-
-struct buffer_size {
-  buffer_size() = default;
-  size_t value = 0;
-  auto operator=(size_t val) const -> buffer_size {
-    auto bs = buffer_size();
-    bs.value = val;
-    return bs;
-  }
-};
-
-struct ostream_params {
-  int oflag = file::WRONLY | file::CREATE | file::TRUNC;
-  size_t buffer_size = BUFSIZ > 32768 ? BUFSIZ : 32768;
-
-  ostream_params() {}
-
-  template <typename... T>
-  ostream_params(T... params, int new_oflag) : ostream_params(params...) {
-    oflag = new_oflag;
-  }
-
-  template <typename... T>
-  ostream_params(T... params, detail::buffer_size bs)
-      : ostream_params(params...) {
-    this->buffer_size = bs.value;
-  }
-
-// Intel has a bug that results in failure to deduce a constructor
-// for empty parameter packs.
-#  if defined(__INTEL_COMPILER) && __INTEL_COMPILER < 2000
-  ostream_params(int new_oflag) : oflag(new_oflag) {}
-  ostream_params(detail::buffer_size bs) : buffer_size(bs.value) {}
-#  endif
-};
-
-class file_buffer final : public buffer<char> {
-  file file_;
-
-  FMT_API void grow(size_t) override;
-
- public:
-  FMT_API file_buffer(cstring_view path, const ostream_params& params);
-  FMT_API file_buffer(file_buffer&& other);
-  FMT_API ~file_buffer();
-
-  void flush() {
-    if (size() == 0) return;
-    file_.write(data(), size() * sizeof(data()[0]));
-    clear();
-  }
-
-  void close() {
-    flush();
-    file_.close();
-  }
-};
-
-}  // namespace detail
-
-// Added {} below to work around default constructor error known to
-// occur in Xcode versions 7.2.1 and 8.2.1.
-constexpr detail::buffer_size buffer_size{};
-
-/** A fast output stream which is not thread-safe. */
-class FMT_API ostream {
- private:
-  FMT_MSC_WARNING(suppress : 4251)
-  detail::file_buffer buffer_;
-
-  ostream(cstring_view path, const detail::ostream_params& params)
-      : buffer_(path, params) {}
-
- public:
-  ostream(ostream&& other) : buffer_(std::move(other.buffer_)) {}
-
-  ~ostream();
-
-  void flush() { buffer_.flush(); }
-
-  template <typename... T>
-  friend auto output_file(cstring_view path, T... params) -> ostream;
-
-  void close() { buffer_.close(); }
-
-  /**
-    Formats ``args`` according to specifications in ``fmt`` and writes the
-    output to the file.
-   */
-  template <typename... T> void print(format_string<T...> fmt, T&&... args) {
-    vformat_to(std::back_inserter(buffer_), fmt,
-               fmt::make_format_args(args...));
-  }
-};
-
-/**
-  \rst
-  Opens a file for writing. Supported parameters passed in *params*:
-
-  * ``<integer>``: Flags passed to `open
-    <https://pubs.opengroup.org/onlinepubs/007904875/functions/open.html>`_
-    (``file::WRONLY | file::CREATE | file::TRUNC`` by default)
-  * ``buffer_size=<integer>``: Output buffer size
-
-  **Example**::
-
-    auto out = fmt::output_file("guide.txt");
-    out.print("Don't {}", "Panic");
-  \endrst
- */
-template <typename... T>
-inline auto output_file(cstring_view path, T... params) -> ostream {
-  return {path, detail::ostream_params(params...)};
-}
-#endif  // FMT_USE_FCNTL
-
-FMT_END_EXPORT
-FMT_END_NAMESPACE
-
-#endif  // FMT_OS_H_
diff --color -Naur fmt-original/include/fmt/ostream.h fmt-10.2.0/include/fmt/ostream.h
--- fmt-original/include/fmt/ostream.h	2025-07-16 22:36:59.480844622 +0200
+++ fmt-10.2.0/include/fmt/ostream.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,245 +0,0 @@
-// Formatting library for C++ - std::ostream support
-//
-// Copyright (c) 2012 - present, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_OSTREAM_H_
-#define FMT_OSTREAM_H_
-
-#include <fstream>  // std::filebuf
-
-#ifdef _WIN32
-#  ifdef __GLIBCXX__
-#    include <ext/stdio_filebuf.h>
-#    include <ext/stdio_sync_filebuf.h>
-#  endif
-#  include <io.h>
-#endif
-
-#include "format.h"
-
-FMT_BEGIN_NAMESPACE
-namespace detail {
-
-template <typename Streambuf> class formatbuf : public Streambuf {
- private:
-  using char_type = typename Streambuf::char_type;
-  using streamsize = decltype(std::declval<Streambuf>().sputn(nullptr, 0));
-  using int_type = typename Streambuf::int_type;
-  using traits_type = typename Streambuf::traits_type;
-
-  buffer<char_type>& buffer_;
-
- public:
-  explicit formatbuf(buffer<char_type>& buf) : buffer_(buf) {}
-
- protected:
-  // The put area is always empty. This makes the implementation simpler and has
-  // the advantage that the streambuf and the buffer are always in sync and
-  // sputc never writes into uninitialized memory. A disadvantage is that each
-  // call to sputc always results in a (virtual) call to overflow. There is no
-  // disadvantage here for sputn since this always results in a call to xsputn.
-
-  auto overflow(int_type ch) -> int_type override {
-    if (!traits_type::eq_int_type(ch, traits_type::eof()))
-      buffer_.push_back(static_cast<char_type>(ch));
-    return ch;
-  }
-
-  auto xsputn(const char_type* s, streamsize count) -> streamsize override {
-    buffer_.append(s, s + count);
-    return count;
-  }
-};
-
-// Generate a unique explicit instantion in every translation unit using a tag
-// type in an anonymous namespace.
-namespace {
-struct file_access_tag {};
-}  // namespace
-template <typename Tag, typename BufType, FILE* BufType::*FileMemberPtr>
-class file_access {
-  friend auto get_file(BufType& obj) -> FILE* { return obj.*FileMemberPtr; }
-};
-
-#if FMT_MSC_VERSION
-template class file_access<file_access_tag, std::filebuf,
-                           &std::filebuf::_Myfile>;
-auto get_file(std::filebuf&) -> FILE*;
-#endif
-
-inline auto write_ostream_unicode(std::ostream& os, fmt::string_view data)
-    -> bool {
-  FILE* f = nullptr;
-#if FMT_MSC_VERSION
-  if (auto* buf = dynamic_cast<std::filebuf*>(os.rdbuf()))
-    f = get_file(*buf);
-  else
-    return false;
-#elif defined(_WIN32) && defined(__GLIBCXX__)
-  auto* rdbuf = os.rdbuf();
-  if (auto* sfbuf = dynamic_cast<__gnu_cxx::stdio_sync_filebuf<char>*>(rdbuf))
-    f = sfbuf->file();
-  else if (auto* fbuf = dynamic_cast<__gnu_cxx::stdio_filebuf<char>*>(rdbuf))
-    f = fbuf->file();
-  else
-    return false;
-#else
-  ignore_unused(os, data, f);
-#endif
-#ifdef _WIN32
-  if (f) {
-    int fd = _fileno(f);
-    if (_isatty(fd)) {
-      os.flush();
-      return write_console(fd, data);
-    }
-  }
-#endif
-  return false;
-}
-inline auto write_ostream_unicode(std::wostream&,
-                                  fmt::basic_string_view<wchar_t>) -> bool {
-  return false;
-}
-
-// Write the content of buf to os.
-// It is a separate function rather than a part of vprint to simplify testing.
-template <typename Char>
-void write_buffer(std::basic_ostream<Char>& os, buffer<Char>& buf) {
-  const Char* buf_data = buf.data();
-  using unsigned_streamsize = std::make_unsigned<std::streamsize>::type;
-  unsigned_streamsize size = buf.size();
-  unsigned_streamsize max_size = to_unsigned(max_value<std::streamsize>());
-  do {
-    unsigned_streamsize n = size <= max_size ? size : max_size;
-    os.write(buf_data, static_cast<std::streamsize>(n));
-    buf_data += n;
-    size -= n;
-  } while (size != 0);
-}
-
-template <typename Char, typename T>
-void format_value(buffer<Char>& buf, const T& value) {
-  auto&& format_buf = formatbuf<std::basic_streambuf<Char>>(buf);
-  auto&& output = std::basic_ostream<Char>(&format_buf);
-#if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)
-  output.imbue(std::locale::classic());  // The default is always unlocalized.
-#endif
-  output << value;
-  output.exceptions(std::ios_base::failbit | std::ios_base::badbit);
-}
-
-template <typename T> struct streamed_view {
-  const T& value;
-};
-
-}  // namespace detail
-
-// Formats an object of type T that has an overloaded ostream operator<<.
-template <typename Char>
-struct basic_ostream_formatter : formatter<basic_string_view<Char>, Char> {
-  void set_debug_format() = delete;
-
-  template <typename T, typename OutputIt>
-  auto format(const T& value, basic_format_context<OutputIt, Char>& ctx) const
-      -> OutputIt {
-    auto buffer = basic_memory_buffer<Char>();
-    detail::format_value(buffer, value);
-    return formatter<basic_string_view<Char>, Char>::format(
-        {buffer.data(), buffer.size()}, ctx);
-  }
-};
-
-using ostream_formatter = basic_ostream_formatter<char>;
-
-template <typename T, typename Char>
-struct formatter<detail::streamed_view<T>, Char>
-    : basic_ostream_formatter<Char> {
-  template <typename OutputIt>
-  auto format(detail::streamed_view<T> view,
-              basic_format_context<OutputIt, Char>& ctx) const -> OutputIt {
-    return basic_ostream_formatter<Char>::format(view.value, ctx);
-  }
-};
-
-/**
-  \rst
-  Returns a view that formats `value` via an ostream ``operator<<``.
-
-  **Example**::
-
-    fmt::print("Current thread id: {}\n",
-               fmt::streamed(std::this_thread::get_id()));
-  \endrst
- */
-template <typename T>
-constexpr auto streamed(const T& value) -> detail::streamed_view<T> {
-  return {value};
-}
-
-namespace detail {
-
-inline void vprint_directly(std::ostream& os, string_view format_str,
-                            format_args args) {
-  auto buffer = memory_buffer();
-  detail::vformat_to(buffer, format_str, args);
-  detail::write_buffer(os, buffer);
-}
-
-}  // namespace detail
-
-FMT_EXPORT template <typename Char>
-void vprint(std::basic_ostream<Char>& os,
-            basic_string_view<type_identity_t<Char>> format_str,
-            basic_format_args<buffer_context<type_identity_t<Char>>> args) {
-  auto buffer = basic_memory_buffer<Char>();
-  detail::vformat_to(buffer, format_str, args);
-  if (detail::write_ostream_unicode(os, {buffer.data(), buffer.size()})) return;
-  detail::write_buffer(os, buffer);
-}
-
-/**
-  \rst
-  Prints formatted data to the stream *os*.
-
-  **Example**::
-
-    fmt::print(cerr, "Don't {}!", "panic");
-  \endrst
- */
-FMT_EXPORT template <typename... T>
-void print(std::ostream& os, format_string<T...> fmt, T&&... args) {
-  const auto& vargs = fmt::make_format_args(args...);
-  if (detail::is_utf8())
-    vprint(os, fmt, vargs);
-  else
-    detail::vprint_directly(os, fmt, vargs);
-}
-
-FMT_EXPORT
-template <typename... Args>
-void print(std::wostream& os,
-           basic_format_string<wchar_t, type_identity_t<Args>...> fmt,
-           Args&&... args) {
-  vprint(os, fmt, fmt::make_format_args<buffer_context<wchar_t>>(args...));
-}
-
-FMT_EXPORT template <typename... T>
-void println(std::ostream& os, format_string<T...> fmt, T&&... args) {
-  fmt::print(os, "{}\n", fmt::format(fmt, std::forward<T>(args)...));
-}
-
-FMT_EXPORT
-template <typename... Args>
-void println(std::wostream& os,
-             basic_format_string<wchar_t, type_identity_t<Args>...> fmt,
-             Args&&... args) {
-  print(os, L"{}\n", fmt::format(fmt, std::forward<Args>(args)...));
-}
-
-FMT_END_NAMESPACE
-
-#endif  // FMT_OSTREAM_H_
diff --color -Naur fmt-original/include/fmt/printf.h fmt-10.2.0/include/fmt/printf.h
--- fmt-original/include/fmt/printf.h	2025-07-16 22:36:59.481424664 +0200
+++ fmt-10.2.0/include/fmt/printf.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,675 +0,0 @@
-// Formatting library for C++ - legacy printf implementation
-//
-// Copyright (c) 2012 - 2016, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_PRINTF_H_
-#define FMT_PRINTF_H_
-
-#include <algorithm>  // std::max
-#include <limits>     // std::numeric_limits
-
-#include "format.h"
-
-FMT_BEGIN_NAMESPACE
-FMT_BEGIN_EXPORT
-
-template <typename T> struct printf_formatter {
-  printf_formatter() = delete;
-};
-
-template <typename Char> class basic_printf_context {
- private:
-  detail::buffer_appender<Char> out_;
-  basic_format_args<basic_printf_context> args_;
-
-  static_assert(std::is_same<Char, char>::value ||
-                    std::is_same<Char, wchar_t>::value,
-                "Unsupported code unit type.");
-
- public:
-  using char_type = Char;
-  using parse_context_type = basic_format_parse_context<Char>;
-  template <typename T> using formatter_type = printf_formatter<T>;
-
-  /**
-    \rst
-    Constructs a ``printf_context`` object. References to the arguments are
-    stored in the context object so make sure they have appropriate lifetimes.
-    \endrst
-   */
-  basic_printf_context(detail::buffer_appender<Char> out,
-                       basic_format_args<basic_printf_context> args)
-      : out_(out), args_(args) {}
-
-  auto out() -> detail::buffer_appender<Char> { return out_; }
-  void advance_to(detail::buffer_appender<Char>) {}
-
-  auto locale() -> detail::locale_ref { return {}; }
-
-  auto arg(int id) const -> basic_format_arg<basic_printf_context> {
-    return args_.get(id);
-  }
-
-  FMT_CONSTEXPR void on_error(const char* message) {
-    detail::error_handler().on_error(message);
-  }
-};
-
-namespace detail {
-
-// Checks if a value fits in int - used to avoid warnings about comparing
-// signed and unsigned integers.
-template <bool IsSigned> struct int_checker {
-  template <typename T> static auto fits_in_int(T value) -> bool {
-    unsigned max = max_value<int>();
-    return value <= max;
-  }
-  static auto fits_in_int(bool) -> bool { return true; }
-};
-
-template <> struct int_checker<true> {
-  template <typename T> static auto fits_in_int(T value) -> bool {
-    return value >= (std::numeric_limits<int>::min)() &&
-           value <= max_value<int>();
-  }
-  static auto fits_in_int(int) -> bool { return true; }
-};
-
-struct printf_precision_handler {
-  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-  auto operator()(T value) -> int {
-    if (!int_checker<std::numeric_limits<T>::is_signed>::fits_in_int(value))
-      throw_format_error("number is too big");
-    return (std::max)(static_cast<int>(value), 0);
-  }
-
-  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
-  auto operator()(T) -> int {
-    throw_format_error("precision is not integer");
-    return 0;
-  }
-};
-
-// An argument visitor that returns true iff arg is a zero integer.
-struct is_zero_int {
-  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-  auto operator()(T value) -> bool {
-    return value == 0;
-  }
-
-  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
-  auto operator()(T) -> bool {
-    return false;
-  }
-};
-
-template <typename T> struct make_unsigned_or_bool : std::make_unsigned<T> {};
-
-template <> struct make_unsigned_or_bool<bool> {
-  using type = bool;
-};
-
-template <typename T, typename Context> class arg_converter {
- private:
-  using char_type = typename Context::char_type;
-
-  basic_format_arg<Context>& arg_;
-  char_type type_;
-
- public:
-  arg_converter(basic_format_arg<Context>& arg, char_type type)
-      : arg_(arg), type_(type) {}
-
-  void operator()(bool value) {
-    if (type_ != 's') operator()<bool>(value);
-  }
-
-  template <typename U, FMT_ENABLE_IF(std::is_integral<U>::value)>
-  void operator()(U value) {
-    bool is_signed = type_ == 'd' || type_ == 'i';
-    using target_type = conditional_t<std::is_same<T, void>::value, U, T>;
-    if (const_check(sizeof(target_type) <= sizeof(int))) {
-      // Extra casts are used to silence warnings.
-      if (is_signed) {
-        auto n = static_cast<int>(static_cast<target_type>(value));
-        arg_ = detail::make_arg<Context>(n);
-      } else {
-        using unsigned_type = typename make_unsigned_or_bool<target_type>::type;
-        auto n = static_cast<unsigned>(static_cast<unsigned_type>(value));
-        arg_ = detail::make_arg<Context>(n);
-      }
-    } else {
-      if (is_signed) {
-        // glibc's printf doesn't sign extend arguments of smaller types:
-        //   std::printf("%lld", -42);  // prints "4294967254"
-        // but we don't have to do the same because it's a UB.
-        auto n = static_cast<long long>(value);
-        arg_ = detail::make_arg<Context>(n);
-      } else {
-        auto n = static_cast<typename make_unsigned_or_bool<U>::type>(value);
-        arg_ = detail::make_arg<Context>(n);
-      }
-    }
-  }
-
-  template <typename U, FMT_ENABLE_IF(!std::is_integral<U>::value)>
-  void operator()(U) {}  // No conversion needed for non-integral types.
-};
-
-// Converts an integer argument to T for printf, if T is an integral type.
-// If T is void, the argument is converted to corresponding signed or unsigned
-// type depending on the type specifier: 'd' and 'i' - signed, other -
-// unsigned).
-template <typename T, typename Context, typename Char>
-void convert_arg(basic_format_arg<Context>& arg, Char type) {
-  visit_format_arg(arg_converter<T, Context>(arg, type), arg);
-}
-
-// Converts an integer argument to char for printf.
-template <typename Context> class char_converter {
- private:
-  basic_format_arg<Context>& arg_;
-
- public:
-  explicit char_converter(basic_format_arg<Context>& arg) : arg_(arg) {}
-
-  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-  void operator()(T value) {
-    auto c = static_cast<typename Context::char_type>(value);
-    arg_ = detail::make_arg<Context>(c);
-  }
-
-  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
-  void operator()(T) {}  // No conversion needed for non-integral types.
-};
-
-// An argument visitor that return a pointer to a C string if argument is a
-// string or null otherwise.
-template <typename Char> struct get_cstring {
-  template <typename T> auto operator()(T) -> const Char* { return nullptr; }
-  auto operator()(const Char* s) -> const Char* { return s; }
-};
-
-// Checks if an argument is a valid printf width specifier and sets
-// left alignment if it is negative.
-template <typename Char> class printf_width_handler {
- private:
-  format_specs<Char>& specs_;
-
- public:
-  explicit printf_width_handler(format_specs<Char>& specs) : specs_(specs) {}
-
-  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-  auto operator()(T value) -> unsigned {
-    auto width = static_cast<uint32_or_64_or_128_t<T>>(value);
-    if (detail::is_negative(value)) {
-      specs_.align = align::left;
-      width = 0 - width;
-    }
-    unsigned int_max = max_value<int>();
-    if (width > int_max) throw_format_error("number is too big");
-    return static_cast<unsigned>(width);
-  }
-
-  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
-  auto operator()(T) -> unsigned {
-    throw_format_error("width is not integer");
-    return 0;
-  }
-};
-
-// Workaround for a bug with the XL compiler when initializing
-// printf_arg_formatter's base class.
-template <typename Char>
-auto make_arg_formatter(buffer_appender<Char> iter, format_specs<Char>& s)
-    -> arg_formatter<Char> {
-  return {iter, s, locale_ref()};
-}
-
-// The ``printf`` argument formatter.
-template <typename Char>
-class printf_arg_formatter : public arg_formatter<Char> {
- private:
-  using base = arg_formatter<Char>;
-  using context_type = basic_printf_context<Char>;
-
-  context_type& context_;
-
-  void write_null_pointer(bool is_string = false) {
-    auto s = this->specs;
-    s.type = presentation_type::none;
-    write_bytes(this->out, is_string ? "(null)" : "(nil)", s);
-  }
-
- public:
-  printf_arg_formatter(buffer_appender<Char> iter, format_specs<Char>& s,
-                       context_type& ctx)
-      : base(make_arg_formatter(iter, s)), context_(ctx) {}
-
-  void operator()(monostate value) { base::operator()(value); }
-
-  template <typename T, FMT_ENABLE_IF(detail::is_integral<T>::value)>
-  void operator()(T value) {
-    // MSVC2013 fails to compile separate overloads for bool and Char so use
-    // std::is_same instead.
-    if (!std::is_same<T, Char>::value) {
-      base::operator()(value);
-      return;
-    }
-    format_specs<Char> fmt_specs = this->specs;
-    if (fmt_specs.type != presentation_type::none &&
-        fmt_specs.type != presentation_type::chr) {
-      return (*this)(static_cast<int>(value));
-    }
-    fmt_specs.sign = sign::none;
-    fmt_specs.alt = false;
-    fmt_specs.fill[0] = ' ';  // Ignore '0' flag for char types.
-    // align::numeric needs to be overwritten here since the '0' flag is
-    // ignored for non-numeric types
-    if (fmt_specs.align == align::none || fmt_specs.align == align::numeric)
-      fmt_specs.align = align::right;
-    write<Char>(this->out, static_cast<Char>(value), fmt_specs);
-  }
-
-  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
-  void operator()(T value) {
-    base::operator()(value);
-  }
-
-  /** Formats a null-terminated C string. */
-  void operator()(const char* value) {
-    if (value)
-      base::operator()(value);
-    else
-      write_null_pointer(this->specs.type != presentation_type::pointer);
-  }
-
-  /** Formats a null-terminated wide C string. */
-  void operator()(const wchar_t* value) {
-    if (value)
-      base::operator()(value);
-    else
-      write_null_pointer(this->specs.type != presentation_type::pointer);
-  }
-
-  void operator()(basic_string_view<Char> value) { base::operator()(value); }
-
-  /** Formats a pointer. */
-  void operator()(const void* value) {
-    if (value)
-      base::operator()(value);
-    else
-      write_null_pointer();
-  }
-
-  /** Formats an argument of a custom (user-defined) type. */
-  void operator()(typename basic_format_arg<context_type>::handle handle) {
-    auto parse_ctx = basic_format_parse_context<Char>({});
-    handle.format(parse_ctx, context_);
-  }
-};
-
-template <typename Char>
-void parse_flags(format_specs<Char>& specs, const Char*& it, const Char* end) {
-  for (; it != end; ++it) {
-    switch (*it) {
-    case '-':
-      specs.align = align::left;
-      break;
-    case '+':
-      specs.sign = sign::plus;
-      break;
-    case '0':
-      specs.fill[0] = '0';
-      break;
-    case ' ':
-      if (specs.sign != sign::plus) specs.sign = sign::space;
-      break;
-    case '#':
-      specs.alt = true;
-      break;
-    default:
-      return;
-    }
-  }
-}
-
-template <typename Char, typename GetArg>
-auto parse_header(const Char*& it, const Char* end, format_specs<Char>& specs,
-                  GetArg get_arg) -> int {
-  int arg_index = -1;
-  Char c = *it;
-  if (c >= '0' && c <= '9') {
-    // Parse an argument index (if followed by '$') or a width possibly
-    // preceded with '0' flag(s).
-    int value = parse_nonnegative_int(it, end, -1);
-    if (it != end && *it == '$') {  // value is an argument index
-      ++it;
-      arg_index = value != -1 ? value : max_value<int>();
-    } else {
-      if (c == '0') specs.fill[0] = '0';
-      if (value != 0) {
-        // Nonzero value means that we parsed width and don't need to
-        // parse it or flags again, so return now.
-        if (value == -1) throw_format_error("number is too big");
-        specs.width = value;
-        return arg_index;
-      }
-    }
-  }
-  parse_flags(specs, it, end);
-  // Parse width.
-  if (it != end) {
-    if (*it >= '0' && *it <= '9') {
-      specs.width = parse_nonnegative_int(it, end, -1);
-      if (specs.width == -1) throw_format_error("number is too big");
-    } else if (*it == '*') {
-      ++it;
-      specs.width = static_cast<int>(visit_format_arg(
-          detail::printf_width_handler<Char>(specs), get_arg(-1)));
-    }
-  }
-  return arg_index;
-}
-
-inline auto parse_printf_presentation_type(char c, type t)
-    -> presentation_type {
-  using pt = presentation_type;
-  constexpr auto integral_set = sint_set | uint_set | bool_set | char_set;
-  switch (c) {
-  case 'd':
-    return in(t, integral_set) ? pt::dec : pt::none;
-  case 'o':
-    return in(t, integral_set) ? pt::oct : pt::none;
-  case 'x':
-    return in(t, integral_set) ? pt::hex_lower : pt::none;
-  case 'X':
-    return in(t, integral_set) ? pt::hex_upper : pt::none;
-  case 'a':
-    return in(t, float_set) ? pt::hexfloat_lower : pt::none;
-  case 'A':
-    return in(t, float_set) ? pt::hexfloat_upper : pt::none;
-  case 'e':
-    return in(t, float_set) ? pt::exp_lower : pt::none;
-  case 'E':
-    return in(t, float_set) ? pt::exp_upper : pt::none;
-  case 'f':
-    return in(t, float_set) ? pt::fixed_lower : pt::none;
-  case 'F':
-    return in(t, float_set) ? pt::fixed_upper : pt::none;
-  case 'g':
-    return in(t, float_set) ? pt::general_lower : pt::none;
-  case 'G':
-    return in(t, float_set) ? pt::general_upper : pt::none;
-  case 'c':
-    return in(t, integral_set) ? pt::chr : pt::none;
-  case 's':
-    return in(t, string_set | cstring_set) ? pt::string : pt::none;
-  case 'p':
-    return in(t, pointer_set | cstring_set) ? pt::pointer : pt::none;
-  default:
-    return pt::none;
-  }
-}
-
-template <typename Char, typename Context>
-void vprintf(buffer<Char>& buf, basic_string_view<Char> format,
-             basic_format_args<Context> args) {
-  using iterator = buffer_appender<Char>;
-  auto out = iterator(buf);
-  auto context = basic_printf_context<Char>(out, args);
-  auto parse_ctx = basic_format_parse_context<Char>(format);
-
-  // Returns the argument with specified index or, if arg_index is -1, the next
-  // argument.
-  auto get_arg = [&](int arg_index) {
-    if (arg_index < 0)
-      arg_index = parse_ctx.next_arg_id();
-    else
-      parse_ctx.check_arg_id(--arg_index);
-    return detail::get_arg(context, arg_index);
-  };
-
-  const Char* start = parse_ctx.begin();
-  const Char* end = parse_ctx.end();
-  auto it = start;
-  while (it != end) {
-    if (!find<false, Char>(it, end, '%', it)) {
-      it = end;  // find leaves it == nullptr if it doesn't find '%'.
-      break;
-    }
-    Char c = *it++;
-    if (it != end && *it == c) {
-      write(out, basic_string_view<Char>(start, to_unsigned(it - start)));
-      start = ++it;
-      continue;
-    }
-    write(out, basic_string_view<Char>(start, to_unsigned(it - 1 - start)));
-
-    auto specs = format_specs<Char>();
-    specs.align = align::right;
-
-    // Parse argument index, flags and width.
-    int arg_index = parse_header(it, end, specs, get_arg);
-    if (arg_index == 0) throw_format_error("argument not found");
-
-    // Parse precision.
-    if (it != end && *it == '.') {
-      ++it;
-      c = it != end ? *it : 0;
-      if ('0' <= c && c <= '9') {
-        specs.precision = parse_nonnegative_int(it, end, 0);
-      } else if (c == '*') {
-        ++it;
-        specs.precision = static_cast<int>(
-            visit_format_arg(printf_precision_handler(), get_arg(-1)));
-      } else {
-        specs.precision = 0;
-      }
-    }
-
-    auto arg = get_arg(arg_index);
-    // For d, i, o, u, x, and X conversion specifiers, if a precision is
-    // specified, the '0' flag is ignored
-    if (specs.precision >= 0 && arg.is_integral()) {
-      // Ignore '0' for non-numeric types or if '-' present.
-      specs.fill[0] = ' ';
-    }
-    if (specs.precision >= 0 && arg.type() == type::cstring_type) {
-      auto str = visit_format_arg(get_cstring<Char>(), arg);
-      auto str_end = str + specs.precision;
-      auto nul = std::find(str, str_end, Char());
-      auto sv = basic_string_view<Char>(
-          str, to_unsigned(nul != str_end ? nul - str : specs.precision));
-      arg = make_arg<basic_printf_context<Char>>(sv);
-    }
-    if (specs.alt && visit_format_arg(is_zero_int(), arg)) specs.alt = false;
-    if (specs.fill[0] == '0') {
-      if (arg.is_arithmetic() && specs.align != align::left)
-        specs.align = align::numeric;
-      else
-        specs.fill[0] = ' ';  // Ignore '0' flag for non-numeric types or if '-'
-                              // flag is also present.
-    }
-
-    // Parse length and convert the argument to the required type.
-    c = it != end ? *it++ : 0;
-    Char t = it != end ? *it : 0;
-    switch (c) {
-    case 'h':
-      if (t == 'h') {
-        ++it;
-        t = it != end ? *it : 0;
-        convert_arg<signed char>(arg, t);
-      } else {
-        convert_arg<short>(arg, t);
-      }
-      break;
-    case 'l':
-      if (t == 'l') {
-        ++it;
-        t = it != end ? *it : 0;
-        convert_arg<long long>(arg, t);
-      } else {
-        convert_arg<long>(arg, t);
-      }
-      break;
-    case 'j':
-      convert_arg<intmax_t>(arg, t);
-      break;
-    case 'z':
-      convert_arg<size_t>(arg, t);
-      break;
-    case 't':
-      convert_arg<std::ptrdiff_t>(arg, t);
-      break;
-    case 'L':
-      // printf produces garbage when 'L' is omitted for long double, no
-      // need to do the same.
-      break;
-    default:
-      --it;
-      convert_arg<void>(arg, c);
-    }
-
-    // Parse type.
-    if (it == end) throw_format_error("invalid format string");
-    char type = static_cast<char>(*it++);
-    if (arg.is_integral()) {
-      // Normalize type.
-      switch (type) {
-      case 'i':
-      case 'u':
-        type = 'd';
-        break;
-      case 'c':
-        visit_format_arg(char_converter<basic_printf_context<Char>>(arg), arg);
-        break;
-      }
-    }
-    specs.type = parse_printf_presentation_type(type, arg.type());
-    if (specs.type == presentation_type::none)
-      throw_format_error("invalid format specifier");
-
-    start = it;
-
-    // Format argument.
-    visit_format_arg(printf_arg_formatter<Char>(out, specs, context), arg);
-  }
-  write(out, basic_string_view<Char>(start, to_unsigned(it - start)));
-}
-}  // namespace detail
-
-using printf_context = basic_printf_context<char>;
-using wprintf_context = basic_printf_context<wchar_t>;
-
-using printf_args = basic_format_args<printf_context>;
-using wprintf_args = basic_format_args<wprintf_context>;
-
-/**
-  \rst
-  Constructs an `~fmt::format_arg_store` object that contains references to
-  arguments and can be implicitly converted to `~fmt::printf_args`.
-  \endrst
- */
-template <typename... T>
-inline auto make_printf_args(const T&... args)
-    -> format_arg_store<printf_context, T...> {
-  return {args...};
-}
-
-// DEPRECATED!
-template <typename... T>
-inline auto make_wprintf_args(const T&... args)
-    -> format_arg_store<wprintf_context, T...> {
-  return {args...};
-}
-
-template <typename Char>
-inline auto vsprintf(
-    basic_string_view<Char> fmt,
-    basic_format_args<basic_printf_context<type_identity_t<Char>>> args)
-    -> std::basic_string<Char> {
-  auto buf = basic_memory_buffer<Char>();
-  detail::vprintf(buf, fmt, args);
-  return to_string(buf);
-}
-
-/**
-  \rst
-  Formats arguments and returns the result as a string.
-
-  **Example**::
-
-    std::string message = fmt::sprintf("The answer is %d", 42);
-  \endrst
-*/
-template <typename S, typename... T,
-          typename Char = enable_if_t<detail::is_string<S>::value, char_t<S>>>
-inline auto sprintf(const S& fmt, const T&... args) -> std::basic_string<Char> {
-  return vsprintf(detail::to_string_view(fmt),
-                  fmt::make_format_args<basic_printf_context<Char>>(args...));
-}
-
-template <typename Char>
-inline auto vfprintf(
-    std::FILE* f, basic_string_view<Char> fmt,
-    basic_format_args<basic_printf_context<type_identity_t<Char>>> args)
-    -> int {
-  auto buf = basic_memory_buffer<Char>();
-  detail::vprintf(buf, fmt, args);
-  size_t size = buf.size();
-  return std::fwrite(buf.data(), sizeof(Char), size, f) < size
-             ? -1
-             : static_cast<int>(size);
-}
-
-/**
-  \rst
-  Prints formatted data to the file *f*.
-
-  **Example**::
-
-    fmt::fprintf(stderr, "Don't %s!", "panic");
-  \endrst
- */
-template <typename S, typename... T, typename Char = char_t<S>>
-inline auto fprintf(std::FILE* f, const S& fmt, const T&... args) -> int {
-  return vfprintf(f, detail::to_string_view(fmt),
-                  fmt::make_format_args<basic_printf_context<Char>>(args...));
-}
-
-template <typename Char>
-FMT_DEPRECATED inline auto vprintf(
-    basic_string_view<Char> fmt,
-    basic_format_args<basic_printf_context<type_identity_t<Char>>> args)
-    -> int {
-  return vfprintf(stdout, fmt, args);
-}
-
-/**
-  \rst
-  Prints formatted data to ``stdout``.
-
-  **Example**::
-
-    fmt::printf("Elapsed time: %.2f seconds", 1.23);
-  \endrst
- */
-template <typename... T>
-inline auto printf(string_view fmt, const T&... args) -> int {
-  return vfprintf(stdout, fmt, make_printf_args(args...));
-}
-template <typename... T>
-FMT_DEPRECATED inline auto printf(basic_string_view<wchar_t> fmt,
-                                  const T&... args) -> int {
-  return vfprintf(stdout, fmt, make_wprintf_args(args...));
-}
-
-FMT_END_EXPORT
-FMT_END_NAMESPACE
-
-#endif  // FMT_PRINTF_H_
diff --color -Naur fmt-original/include/fmt/ranges.h fmt-10.2.0/include/fmt/ranges.h
--- fmt-original/include/fmt/ranges.h	2025-07-16 22:36:59.482004707 +0200
+++ fmt-10.2.0/include/fmt/ranges.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,738 +0,0 @@
-// Formatting library for C++ - range and tuple support
-//
-// Copyright (c) 2012 - present, Victor Zverovich and {fmt} contributors
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_RANGES_H_
-#define FMT_RANGES_H_
-
-#include <initializer_list>
-#include <tuple>
-#include <type_traits>
-
-#include "format.h"
-
-FMT_BEGIN_NAMESPACE
-
-namespace detail {
-
-template <typename Range, typename OutputIt>
-auto copy(const Range& range, OutputIt out) -> OutputIt {
-  for (auto it = range.begin(), end = range.end(); it != end; ++it)
-    *out++ = *it;
-  return out;
-}
-
-template <typename OutputIt>
-auto copy(const char* str, OutputIt out) -> OutputIt {
-  while (*str) *out++ = *str++;
-  return out;
-}
-
-template <typename OutputIt> auto copy(char ch, OutputIt out) -> OutputIt {
-  *out++ = ch;
-  return out;
-}
-
-template <typename OutputIt> auto copy(wchar_t ch, OutputIt out) -> OutputIt {
-  *out++ = ch;
-  return out;
-}
-
-// Returns true if T has a std::string-like interface, like std::string_view.
-template <typename T> class is_std_string_like {
-  template <typename U>
-  static auto check(U* p)
-      -> decltype((void)p->find('a'), p->length(), (void)p->data(), int());
-  template <typename> static void check(...);
-
- public:
-  static constexpr const bool value =
-      is_string<T>::value ||
-      std::is_convertible<T, std_string_view<char>>::value ||
-      !std::is_void<decltype(check<T>(nullptr))>::value;
-};
-
-template <typename Char>
-struct is_std_string_like<fmt::basic_string_view<Char>> : std::true_type {};
-
-template <typename T> class is_map {
-  template <typename U> static auto check(U*) -> typename U::mapped_type;
-  template <typename> static void check(...);
-
- public:
-#ifdef FMT_FORMAT_MAP_AS_LIST  // DEPRECATED!
-  static constexpr const bool value = false;
-#else
-  static constexpr const bool value =
-      !std::is_void<decltype(check<T>(nullptr))>::value;
-#endif
-};
-
-template <typename T> class is_set {
-  template <typename U> static auto check(U*) -> typename U::key_type;
-  template <typename> static void check(...);
-
- public:
-#ifdef FMT_FORMAT_SET_AS_LIST  // DEPRECATED!
-  static constexpr const bool value = false;
-#else
-  static constexpr const bool value =
-      !std::is_void<decltype(check<T>(nullptr))>::value && !is_map<T>::value;
-#endif
-};
-
-template <typename... Ts> struct conditional_helper {};
-
-template <typename T, typename _ = void> struct is_range_ : std::false_type {};
-
-#if !FMT_MSC_VERSION || FMT_MSC_VERSION > 1800
-
-#  define FMT_DECLTYPE_RETURN(val)  \
-    ->decltype(val) { return val; } \
-    static_assert(                  \
-        true, "")  // This makes it so that a semicolon is required after the
-                   // macro, which helps clang-format handle the formatting.
-
-// C array overload
-template <typename T, std::size_t N>
-auto range_begin(const T (&arr)[N]) -> const T* {
-  return arr;
-}
-template <typename T, std::size_t N>
-auto range_end(const T (&arr)[N]) -> const T* {
-  return arr + N;
-}
-
-template <typename T, typename Enable = void>
-struct has_member_fn_begin_end_t : std::false_type {};
-
-template <typename T>
-struct has_member_fn_begin_end_t<T, void_t<decltype(std::declval<T>().begin()),
-                                           decltype(std::declval<T>().end())>>
-    : std::true_type {};
-
-// Member function overload
-template <typename T>
-auto range_begin(T&& rng) FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).begin());
-template <typename T>
-auto range_end(T&& rng) FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).end());
-
-// ADL overload. Only participates in overload resolution if member functions
-// are not found.
-template <typename T>
-auto range_begin(T&& rng)
-    -> enable_if_t<!has_member_fn_begin_end_t<T&&>::value,
-                   decltype(begin(static_cast<T&&>(rng)))> {
-  return begin(static_cast<T&&>(rng));
-}
-template <typename T>
-auto range_end(T&& rng) -> enable_if_t<!has_member_fn_begin_end_t<T&&>::value,
-                                       decltype(end(static_cast<T&&>(rng)))> {
-  return end(static_cast<T&&>(rng));
-}
-
-template <typename T, typename Enable = void>
-struct has_const_begin_end : std::false_type {};
-template <typename T, typename Enable = void>
-struct has_mutable_begin_end : std::false_type {};
-
-template <typename T>
-struct has_const_begin_end<
-    T,
-    void_t<
-        decltype(detail::range_begin(std::declval<const remove_cvref_t<T>&>())),
-        decltype(detail::range_end(std::declval<const remove_cvref_t<T>&>()))>>
-    : std::true_type {};
-
-template <typename T>
-struct has_mutable_begin_end<
-    T, void_t<decltype(detail::range_begin(std::declval<T>())),
-              decltype(detail::range_end(std::declval<T>())),
-              // the extra int here is because older versions of MSVC don't
-              // SFINAE properly unless there are distinct types
-              int>> : std::true_type {};
-
-template <typename T>
-struct is_range_<T, void>
-    : std::integral_constant<bool, (has_const_begin_end<T>::value ||
-                                    has_mutable_begin_end<T>::value)> {};
-#  undef FMT_DECLTYPE_RETURN
-#endif
-
-// tuple_size and tuple_element check.
-template <typename T> class is_tuple_like_ {
-  template <typename U>
-  static auto check(U* p) -> decltype(std::tuple_size<U>::value, int());
-  template <typename> static void check(...);
-
- public:
-  static constexpr const bool value =
-      !std::is_void<decltype(check<T>(nullptr))>::value;
-};
-
-// Check for integer_sequence
-#if defined(__cpp_lib_integer_sequence) || FMT_MSC_VERSION >= 1900
-template <typename T, T... N>
-using integer_sequence = std::integer_sequence<T, N...>;
-template <size_t... N> using index_sequence = std::index_sequence<N...>;
-template <size_t N> using make_index_sequence = std::make_index_sequence<N>;
-#else
-template <typename T, T... N> struct integer_sequence {
-  using value_type = T;
-
-  static FMT_CONSTEXPR auto size() -> size_t { return sizeof...(N); }
-};
-
-template <size_t... N> using index_sequence = integer_sequence<size_t, N...>;
-
-template <typename T, size_t N, T... Ns>
-struct make_integer_sequence : make_integer_sequence<T, N - 1, N - 1, Ns...> {};
-template <typename T, T... Ns>
-struct make_integer_sequence<T, 0, Ns...> : integer_sequence<T, Ns...> {};
-
-template <size_t N>
-using make_index_sequence = make_integer_sequence<size_t, N>;
-#endif
-
-template <typename T>
-using tuple_index_sequence = make_index_sequence<std::tuple_size<T>::value>;
-
-template <typename T, typename C, bool = is_tuple_like_<T>::value>
-class is_tuple_formattable_ {
- public:
-  static constexpr const bool value = false;
-};
-template <typename T, typename C> class is_tuple_formattable_<T, C, true> {
-  template <std::size_t... Is>
-  static auto check2(index_sequence<Is...>,
-                     integer_sequence<bool, (Is == Is)...>) -> std::true_type;
-  static auto check2(...) -> std::false_type;
-  template <std::size_t... Is>
-  static auto check(index_sequence<Is...>) -> decltype(check2(
-      index_sequence<Is...>{},
-      integer_sequence<bool,
-                       (is_formattable<typename std::tuple_element<Is, T>::type,
-                                       C>::value)...>{}));
-
- public:
-  static constexpr const bool value =
-      decltype(check(tuple_index_sequence<T>{}))::value;
-};
-
-template <typename Tuple, typename F, size_t... Is>
-FMT_CONSTEXPR void for_each(index_sequence<Is...>, Tuple&& t, F&& f) {
-  using std::get;
-  // Using a free function get<Is>(Tuple) now.
-  const int unused[] = {0, ((void)f(get<Is>(t)), 0)...};
-  ignore_unused(unused);
-}
-
-template <typename Tuple, typename F>
-FMT_CONSTEXPR void for_each(Tuple&& t, F&& f) {
-  for_each(tuple_index_sequence<remove_cvref_t<Tuple>>(),
-           std::forward<Tuple>(t), std::forward<F>(f));
-}
-
-template <typename Tuple1, typename Tuple2, typename F, size_t... Is>
-void for_each2(index_sequence<Is...>, Tuple1&& t1, Tuple2&& t2, F&& f) {
-  using std::get;
-  const int unused[] = {0, ((void)f(get<Is>(t1), get<Is>(t2)), 0)...};
-  ignore_unused(unused);
-}
-
-template <typename Tuple1, typename Tuple2, typename F>
-void for_each2(Tuple1&& t1, Tuple2&& t2, F&& f) {
-  for_each2(tuple_index_sequence<remove_cvref_t<Tuple1>>(),
-            std::forward<Tuple1>(t1), std::forward<Tuple2>(t2),
-            std::forward<F>(f));
-}
-
-namespace tuple {
-// Workaround a bug in MSVC 2019 (v140).
-template <typename Char, typename... T>
-using result_t = std::tuple<formatter<remove_cvref_t<T>, Char>...>;
-
-using std::get;
-template <typename Tuple, typename Char, std::size_t... Is>
-auto get_formatters(index_sequence<Is...>)
-    -> result_t<Char, decltype(get<Is>(std::declval<Tuple>()))...>;
-}  // namespace tuple
-
-#if FMT_MSC_VERSION && FMT_MSC_VERSION < 1920
-// Older MSVC doesn't get the reference type correctly for arrays.
-template <typename R> struct range_reference_type_impl {
-  using type = decltype(*detail::range_begin(std::declval<R&>()));
-};
-
-template <typename T, std::size_t N> struct range_reference_type_impl<T[N]> {
-  using type = T&;
-};
-
-template <typename T>
-using range_reference_type = typename range_reference_type_impl<T>::type;
-#else
-template <typename Range>
-using range_reference_type =
-    decltype(*detail::range_begin(std::declval<Range&>()));
-#endif
-
-// We don't use the Range's value_type for anything, but we do need the Range's
-// reference type, with cv-ref stripped.
-template <typename Range>
-using uncvref_type = remove_cvref_t<range_reference_type<Range>>;
-
-template <typename Formatter>
-FMT_CONSTEXPR auto maybe_set_debug_format(Formatter& f, bool set)
-    -> decltype(f.set_debug_format(set)) {
-  f.set_debug_format(set);
-}
-template <typename Formatter>
-FMT_CONSTEXPR void maybe_set_debug_format(Formatter&, ...) {}
-
-// These are not generic lambdas for compatibility with C++11.
-template <typename ParseContext> struct parse_empty_specs {
-  template <typename Formatter> FMT_CONSTEXPR void operator()(Formatter& f) {
-    f.parse(ctx);
-    detail::maybe_set_debug_format(f, true);
-  }
-  ParseContext& ctx;
-};
-template <typename FormatContext> struct format_tuple_element {
-  using char_type = typename FormatContext::char_type;
-
-  template <typename T>
-  void operator()(const formatter<T, char_type>& f, const T& v) {
-    if (i > 0)
-      ctx.advance_to(detail::copy_str<char_type>(separator, ctx.out()));
-    ctx.advance_to(f.format(v, ctx));
-    ++i;
-  }
-
-  int i;
-  FormatContext& ctx;
-  basic_string_view<char_type> separator;
-};
-
-}  // namespace detail
-
-template <typename T> struct is_tuple_like {
-  static constexpr const bool value =
-      detail::is_tuple_like_<T>::value && !detail::is_range_<T>::value;
-};
-
-template <typename T, typename C> struct is_tuple_formattable {
-  static constexpr const bool value =
-      detail::is_tuple_formattable_<T, C>::value;
-};
-
-template <typename Tuple, typename Char>
-struct formatter<Tuple, Char,
-                 enable_if_t<fmt::is_tuple_like<Tuple>::value &&
-                             fmt::is_tuple_formattable<Tuple, Char>::value>> {
- private:
-  decltype(detail::tuple::get_formatters<Tuple, Char>(
-      detail::tuple_index_sequence<Tuple>())) formatters_;
-
-  basic_string_view<Char> separator_ = detail::string_literal<Char, ',', ' '>{};
-  basic_string_view<Char> opening_bracket_ =
-      detail::string_literal<Char, '('>{};
-  basic_string_view<Char> closing_bracket_ =
-      detail::string_literal<Char, ')'>{};
-
- public:
-  FMT_CONSTEXPR formatter() {}
-
-  FMT_CONSTEXPR void set_separator(basic_string_view<Char> sep) {
-    separator_ = sep;
-  }
-
-  FMT_CONSTEXPR void set_brackets(basic_string_view<Char> open,
-                                  basic_string_view<Char> close) {
-    opening_bracket_ = open;
-    closing_bracket_ = close;
-  }
-
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    auto it = ctx.begin();
-    if (it != ctx.end() && *it != '}')
-      FMT_THROW(format_error("invalid format specifier"));
-    detail::for_each(formatters_, detail::parse_empty_specs<ParseContext>{ctx});
-    return it;
-  }
-
-  template <typename FormatContext>
-  auto format(const Tuple& value, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    ctx.advance_to(detail::copy_str<Char>(opening_bracket_, ctx.out()));
-    detail::for_each2(
-        formatters_, value,
-        detail::format_tuple_element<FormatContext>{0, ctx, separator_});
-    return detail::copy_str<Char>(closing_bracket_, ctx.out());
-  }
-};
-
-template <typename T, typename Char> struct is_range {
-  static constexpr const bool value =
-      detail::is_range_<T>::value && !detail::is_std_string_like<T>::value &&
-      !std::is_convertible<T, std::basic_string<Char>>::value &&
-      !std::is_convertible<T, detail::std_string_view<Char>>::value;
-};
-
-namespace detail {
-template <typename Context> struct range_mapper {
-  using mapper = arg_mapper<Context>;
-
-  template <typename T,
-            FMT_ENABLE_IF(has_formatter<remove_cvref_t<T>, Context>::value)>
-  static auto map(T&& value) -> T&& {
-    return static_cast<T&&>(value);
-  }
-  template <typename T,
-            FMT_ENABLE_IF(!has_formatter<remove_cvref_t<T>, Context>::value)>
-  static auto map(T&& value)
-      -> decltype(mapper().map(static_cast<T&&>(value))) {
-    return mapper().map(static_cast<T&&>(value));
-  }
-};
-
-template <typename Char, typename Element>
-using range_formatter_type =
-    formatter<remove_cvref_t<decltype(range_mapper<buffer_context<Char>>{}.map(
-                  std::declval<Element>()))>,
-              Char>;
-
-template <typename R>
-using maybe_const_range =
-    conditional_t<has_const_begin_end<R>::value, const R, R>;
-
-// Workaround a bug in MSVC 2015 and earlier.
-#if !FMT_MSC_VERSION || FMT_MSC_VERSION >= 1910
-template <typename R, typename Char>
-struct is_formattable_delayed
-    : is_formattable<uncvref_type<maybe_const_range<R>>, Char> {};
-#endif
-}  // namespace detail
-
-template <typename...> struct conjunction : std::true_type {};
-template <typename P> struct conjunction<P> : P {};
-template <typename P1, typename... Pn>
-struct conjunction<P1, Pn...>
-    : conditional_t<bool(P1::value), conjunction<Pn...>, P1> {};
-
-template <typename T, typename Char, typename Enable = void>
-struct range_formatter;
-
-template <typename T, typename Char>
-struct range_formatter<
-    T, Char,
-    enable_if_t<conjunction<std::is_same<T, remove_cvref_t<T>>,
-                            is_formattable<T, Char>>::value>> {
- private:
-  detail::range_formatter_type<Char, T> underlying_;
-  basic_string_view<Char> separator_ = detail::string_literal<Char, ',', ' '>{};
-  basic_string_view<Char> opening_bracket_ =
-      detail::string_literal<Char, '['>{};
-  basic_string_view<Char> closing_bracket_ =
-      detail::string_literal<Char, ']'>{};
-
- public:
-  FMT_CONSTEXPR range_formatter() {}
-
-  FMT_CONSTEXPR auto underlying() -> detail::range_formatter_type<Char, T>& {
-    return underlying_;
-  }
-
-  FMT_CONSTEXPR void set_separator(basic_string_view<Char> sep) {
-    separator_ = sep;
-  }
-
-  FMT_CONSTEXPR void set_brackets(basic_string_view<Char> open,
-                                  basic_string_view<Char> close) {
-    opening_bracket_ = open;
-    closing_bracket_ = close;
-  }
-
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    auto it = ctx.begin();
-    auto end = ctx.end();
-
-    if (it != end && *it == 'n') {
-      set_brackets({}, {});
-      ++it;
-    }
-
-    if (it != end && *it != '}') {
-      if (*it != ':') FMT_THROW(format_error("invalid format specifier"));
-      ++it;
-    } else {
-      detail::maybe_set_debug_format(underlying_, true);
-    }
-
-    ctx.advance_to(it);
-    return underlying_.parse(ctx);
-  }
-
-  template <typename R, typename FormatContext>
-  auto format(R&& range, FormatContext& ctx) const -> decltype(ctx.out()) {
-    detail::range_mapper<buffer_context<Char>> mapper;
-    auto out = ctx.out();
-    out = detail::copy_str<Char>(opening_bracket_, out);
-    int i = 0;
-    auto it = detail::range_begin(range);
-    auto end = detail::range_end(range);
-    for (; it != end; ++it) {
-      if (i > 0) out = detail::copy_str<Char>(separator_, out);
-      ctx.advance_to(out);
-      auto&& item = *it;
-      out = underlying_.format(mapper.map(item), ctx);
-      ++i;
-    }
-    out = detail::copy_str<Char>(closing_bracket_, out);
-    return out;
-  }
-};
-
-enum class range_format { disabled, map, set, sequence, string, debug_string };
-
-namespace detail {
-template <typename T>
-struct range_format_kind_
-    : std::integral_constant<range_format,
-                             std::is_same<uncvref_type<T>, T>::value
-                                 ? range_format::disabled
-                             : is_map<T>::value ? range_format::map
-                             : is_set<T>::value ? range_format::set
-                                                : range_format::sequence> {};
-
-template <range_format K, typename R, typename Char, typename Enable = void>
-struct range_default_formatter;
-
-template <range_format K>
-using range_format_constant = std::integral_constant<range_format, K>;
-
-template <range_format K, typename R, typename Char>
-struct range_default_formatter<
-    K, R, Char,
-    enable_if_t<(K == range_format::sequence || K == range_format::map ||
-                 K == range_format::set)>> {
-  using range_type = detail::maybe_const_range<R>;
-  range_formatter<detail::uncvref_type<range_type>, Char> underlying_;
-
-  FMT_CONSTEXPR range_default_formatter() { init(range_format_constant<K>()); }
-
-  FMT_CONSTEXPR void init(range_format_constant<range_format::set>) {
-    underlying_.set_brackets(detail::string_literal<Char, '{'>{},
-                             detail::string_literal<Char, '}'>{});
-  }
-
-  FMT_CONSTEXPR void init(range_format_constant<range_format::map>) {
-    underlying_.set_brackets(detail::string_literal<Char, '{'>{},
-                             detail::string_literal<Char, '}'>{});
-    underlying_.underlying().set_brackets({}, {});
-    underlying_.underlying().set_separator(
-        detail::string_literal<Char, ':', ' '>{});
-  }
-
-  FMT_CONSTEXPR void init(range_format_constant<range_format::sequence>) {}
-
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return underlying_.parse(ctx);
-  }
-
-  template <typename FormatContext>
-  auto format(range_type& range, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    return underlying_.format(range, ctx);
-  }
-};
-}  // namespace detail
-
-template <typename T, typename Char, typename Enable = void>
-struct range_format_kind
-    : conditional_t<
-          is_range<T, Char>::value, detail::range_format_kind_<T>,
-          std::integral_constant<range_format, range_format::disabled>> {};
-
-template <typename R, typename Char>
-struct formatter<
-    R, Char,
-    enable_if_t<conjunction<bool_constant<range_format_kind<R, Char>::value !=
-                                          range_format::disabled>
-// Workaround a bug in MSVC 2015 and earlier.
-#if !FMT_MSC_VERSION || FMT_MSC_VERSION >= 1910
-                            ,
-                            detail::is_formattable_delayed<R, Char>
-#endif
-                            >::value>>
-    : detail::range_default_formatter<range_format_kind<R, Char>::value, R,
-                                      Char> {
-};
-
-template <typename Char, typename... T> struct tuple_join_view : detail::view {
-  const std::tuple<T...>& tuple;
-  basic_string_view<Char> sep;
-
-  tuple_join_view(const std::tuple<T...>& t, basic_string_view<Char> s)
-      : tuple(t), sep{s} {}
-};
-
-// Define FMT_TUPLE_JOIN_SPECIFIERS to enable experimental format specifiers
-// support in tuple_join. It is disabled by default because of issues with
-// the dynamic width and precision.
-#ifndef FMT_TUPLE_JOIN_SPECIFIERS
-#  define FMT_TUPLE_JOIN_SPECIFIERS 0
-#endif
-
-template <typename Char, typename... T>
-struct formatter<tuple_join_view<Char, T...>, Char> {
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return do_parse(ctx, std::integral_constant<size_t, sizeof...(T)>());
-  }
-
-  template <typename FormatContext>
-  auto format(const tuple_join_view<Char, T...>& value,
-              FormatContext& ctx) const -> typename FormatContext::iterator {
-    return do_format(value, ctx,
-                     std::integral_constant<size_t, sizeof...(T)>());
-  }
-
- private:
-  std::tuple<formatter<typename std::decay<T>::type, Char>...> formatters_;
-
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto do_parse(ParseContext& ctx,
-                              std::integral_constant<size_t, 0>)
-      -> decltype(ctx.begin()) {
-    return ctx.begin();
-  }
-
-  template <typename ParseContext, size_t N>
-  FMT_CONSTEXPR auto do_parse(ParseContext& ctx,
-                              std::integral_constant<size_t, N>)
-      -> decltype(ctx.begin()) {
-    auto end = ctx.begin();
-#if FMT_TUPLE_JOIN_SPECIFIERS
-    end = std::get<sizeof...(T) - N>(formatters_).parse(ctx);
-    if (N > 1) {
-      auto end1 = do_parse(ctx, std::integral_constant<size_t, N - 1>());
-      if (end != end1)
-        FMT_THROW(format_error("incompatible format specs for tuple elements"));
-    }
-#endif
-    return end;
-  }
-
-  template <typename FormatContext>
-  auto do_format(const tuple_join_view<Char, T...>&, FormatContext& ctx,
-                 std::integral_constant<size_t, 0>) const ->
-      typename FormatContext::iterator {
-    return ctx.out();
-  }
-
-  template <typename FormatContext, size_t N>
-  auto do_format(const tuple_join_view<Char, T...>& value, FormatContext& ctx,
-                 std::integral_constant<size_t, N>) const ->
-      typename FormatContext::iterator {
-    auto out = std::get<sizeof...(T) - N>(formatters_)
-                   .format(std::get<sizeof...(T) - N>(value.tuple), ctx);
-    if (N > 1) {
-      out = std::copy(value.sep.begin(), value.sep.end(), out);
-      ctx.advance_to(out);
-      return do_format(value, ctx, std::integral_constant<size_t, N - 1>());
-    }
-    return out;
-  }
-};
-
-namespace detail {
-// Check if T has an interface like a container adaptor (e.g. std::stack,
-// std::queue, std::priority_queue).
-template <typename T> class is_container_adaptor_like {
-  template <typename U> static auto check(U* p) -> typename U::container_type;
-  template <typename> static void check(...);
-
- public:
-  static constexpr const bool value =
-      !std::is_void<decltype(check<T>(nullptr))>::value;
-};
-
-template <typename Container> struct all {
-  const Container& c;
-  auto begin() const -> typename Container::const_iterator { return c.begin(); }
-  auto end() const -> typename Container::const_iterator { return c.end(); }
-};
-}  // namespace detail
-
-template <typename T, typename Char>
-struct formatter<
-    T, Char,
-    enable_if_t<conjunction<detail::is_container_adaptor_like<T>,
-                            bool_constant<range_format_kind<T, Char>::value ==
-                                          range_format::disabled>>::value>>
-    : formatter<detail::all<typename T::container_type>, Char> {
-  using all = detail::all<typename T::container_type>;
-  template <typename FormatContext>
-  auto format(const T& t, FormatContext& ctx) const -> decltype(ctx.out()) {
-    struct getter : T {
-      static auto get(const T& t) -> all {
-        return {t.*(&getter::c)};  // Access c through the derived class.
-      }
-    };
-    return formatter<all>::format(getter::get(t), ctx);
-  }
-};
-
-FMT_BEGIN_EXPORT
-
-/**
-  \rst
-  Returns an object that formats `tuple` with elements separated by `sep`.
-
-  **Example**::
-
-    std::tuple<int, char> t = {1, 'a'};
-    fmt::print("{}", fmt::join(t, ", "));
-    // Output: "1, a"
-  \endrst
- */
-template <typename... T>
-FMT_CONSTEXPR auto join(const std::tuple<T...>& tuple, string_view sep)
-    -> tuple_join_view<char, T...> {
-  return {tuple, sep};
-}
-
-template <typename... T>
-FMT_CONSTEXPR auto join(const std::tuple<T...>& tuple,
-                        basic_string_view<wchar_t> sep)
-    -> tuple_join_view<wchar_t, T...> {
-  return {tuple, sep};
-}
-
-/**
-  \rst
-  Returns an object that formats `initializer_list` with elements separated by
-  `sep`.
-
-  **Example**::
-
-    fmt::print("{}", fmt::join({1, 2, 3}, ", "));
-    // Output: "1, 2, 3"
-  \endrst
- */
-template <typename T>
-auto join(std::initializer_list<T> list, string_view sep)
-    -> join_view<const T*, const T*> {
-  return join(std::begin(list), std::end(list), sep);
-}
-
-FMT_END_EXPORT
-FMT_END_NAMESPACE
-
-#endif  // FMT_RANGES_H_
diff --color -Naur fmt-original/include/fmt/std.h fmt-10.2.0/include/fmt/std.h
--- fmt-original/include/fmt/std.h	2025-07-16 22:36:59.482252858 +0200
+++ fmt-10.2.0/include/fmt/std.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,537 +0,0 @@
-// Formatting library for C++ - formatters for standard library types
-//
-// Copyright (c) 2012 - present, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_STD_H_
-#define FMT_STD_H_
-
-#include <atomic>
-#include <bitset>
-#include <cstdlib>
-#include <exception>
-#include <memory>
-#include <thread>
-#include <type_traits>
-#include <typeinfo>
-#include <utility>
-#include <vector>
-
-#include "format.h"
-#include "ostream.h"
-
-#if FMT_HAS_INCLUDE(<version>)
-#  include <version>
-#endif
-// Checking FMT_CPLUSPLUS for warning suppression in MSVC.
-#if FMT_CPLUSPLUS >= 201703L
-#  if FMT_HAS_INCLUDE(<filesystem>)
-#    include <filesystem>
-#  endif
-#  if FMT_HAS_INCLUDE(<variant>)
-#    include <variant>
-#  endif
-#  if FMT_HAS_INCLUDE(<optional>)
-#    include <optional>
-#  endif
-#endif
-
-#if FMT_CPLUSPLUS > 201703L && FMT_HAS_INCLUDE(<source_location>)
-#  include <source_location>
-#endif
-
-// GCC 4 does not support FMT_HAS_INCLUDE.
-#if FMT_HAS_INCLUDE(<cxxabi.h>) || defined(__GLIBCXX__)
-#  include <cxxabi.h>
-// Android NDK with gabi++ library on some architectures does not implement
-// abi::__cxa_demangle().
-#  ifndef __GABIXX_CXXABI_H__
-#    define FMT_HAS_ABI_CXA_DEMANGLE
-#  endif
-#endif
-
-// Check if typeid is available.
-#ifndef FMT_USE_TYPEID
-// __RTTI is for EDG compilers. In MSVC typeid is available without RTTI.
-#  if defined(__GXX_RTTI) || FMT_HAS_FEATURE(cxx_rtti) || FMT_MSC_VERSION || \
-      defined(__INTEL_RTTI__) || defined(__RTTI)
-#    define FMT_USE_TYPEID 1
-#  else
-#    define FMT_USE_TYPEID 0
-#  endif
-#endif
-
-// For older Xcode versions, __cpp_lib_xxx flags are inaccurately defined.
-#ifndef FMT_CPP_LIB_FILESYSTEM
-#  ifdef __cpp_lib_filesystem
-#    define FMT_CPP_LIB_FILESYSTEM __cpp_lib_filesystem
-#  else
-#    define FMT_CPP_LIB_FILESYSTEM 0
-#  endif
-#endif
-
-#ifndef FMT_CPP_LIB_VARIANT
-#  ifdef __cpp_lib_variant
-#    define FMT_CPP_LIB_VARIANT __cpp_lib_variant
-#  else
-#    define FMT_CPP_LIB_VARIANT 0
-#  endif
-#endif
-
-#if FMT_CPP_LIB_FILESYSTEM
-FMT_BEGIN_NAMESPACE
-
-namespace detail {
-
-template <typename Char, typename PathChar>
-auto get_path_string(const std::filesystem::path& p,
-                     const std::basic_string<PathChar>& native) {
-  if constexpr (std::is_same_v<Char, char> && std::is_same_v<PathChar, wchar_t>)
-    return to_utf8<wchar_t>(native, to_utf8_error_policy::replace);
-  else
-    return p.string<Char>();
-}
-
-template <typename Char, typename PathChar>
-void write_escaped_path(basic_memory_buffer<Char>& quoted,
-                        const std::filesystem::path& p,
-                        const std::basic_string<PathChar>& native) {
-  if constexpr (std::is_same_v<Char, char> &&
-                std::is_same_v<PathChar, wchar_t>) {
-    auto buf = basic_memory_buffer<wchar_t>();
-    write_escaped_string<wchar_t>(std::back_inserter(buf), native);
-    bool valid = to_utf8<wchar_t>::convert(quoted, {buf.data(), buf.size()});
-    FMT_ASSERT(valid, "invalid utf16");
-  } else if constexpr (std::is_same_v<Char, PathChar>) {
-    write_escaped_string<std::filesystem::path::value_type>(
-        std::back_inserter(quoted), native);
-  } else {
-    write_escaped_string<Char>(std::back_inserter(quoted), p.string<Char>());
-  }
-}
-
-}  // namespace detail
-
-FMT_EXPORT
-template <typename Char> struct formatter<std::filesystem::path, Char> {
- private:
-  format_specs<Char> specs_;
-  detail::arg_ref<Char> width_ref_;
-  bool debug_ = false;
-  char path_type_ = 0;
-
- public:
-  FMT_CONSTEXPR void set_debug_format(bool set = true) { debug_ = set; }
-
-  template <typename ParseContext> FMT_CONSTEXPR auto parse(ParseContext& ctx) {
-    auto it = ctx.begin(), end = ctx.end();
-    if (it == end) return it;
-
-    it = detail::parse_align(it, end, specs_);
-    if (it == end) return it;
-
-    it = detail::parse_dynamic_spec(it, end, specs_.width, width_ref_, ctx);
-    if (it != end && *it == '?') {
-      debug_ = true;
-      ++it;
-    }
-    if (it != end && (*it == 'g')) path_type_ = *it++;
-    return it;
-  }
-
-  template <typename FormatContext>
-  auto format(const std::filesystem::path& p, FormatContext& ctx) const {
-    auto specs = specs_;
-#  ifdef _WIN32
-    auto path_string = !path_type_ ? p.native() : p.generic_wstring();
-#  else
-    auto path_string = !path_type_ ? p.native() : p.generic_string();
-#  endif
-
-    detail::handle_dynamic_spec<detail::width_checker>(specs.width, width_ref_,
-                                                       ctx);
-    if (!debug_) {
-      auto s = detail::get_path_string<Char>(p, path_string);
-      return detail::write(ctx.out(), basic_string_view<Char>(s), specs);
-    }
-    auto quoted = basic_memory_buffer<Char>();
-    detail::write_escaped_path(quoted, p, path_string);
-    return detail::write(ctx.out(),
-                         basic_string_view<Char>(quoted.data(), quoted.size()),
-                         specs);
-  }
-};
-FMT_END_NAMESPACE
-#endif  // FMT_CPP_LIB_FILESYSTEM
-
-FMT_BEGIN_NAMESPACE
-FMT_EXPORT
-template <std::size_t N, typename Char>
-struct formatter<std::bitset<N>, Char> : nested_formatter<string_view> {
- private:
-  // Functor because C++11 doesn't support generic lambdas.
-  struct writer {
-    const std::bitset<N>& bs;
-
-    template <typename OutputIt>
-    FMT_CONSTEXPR auto operator()(OutputIt out) -> OutputIt {
-      for (auto pos = N; pos > 0; --pos) {
-        out = detail::write<Char>(out, bs[pos - 1] ? Char('1') : Char('0'));
-      }
-
-      return out;
-    }
-  };
-
- public:
-  template <typename FormatContext>
-  auto format(const std::bitset<N>& bs, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    return write_padded(ctx, writer{bs});
-  }
-};
-
-FMT_EXPORT
-template <typename Char>
-struct formatter<std::thread::id, Char> : basic_ostream_formatter<Char> {};
-FMT_END_NAMESPACE
-
-#ifdef __cpp_lib_optional
-FMT_BEGIN_NAMESPACE
-FMT_EXPORT
-template <typename T, typename Char>
-struct formatter<std::optional<T>, Char,
-                 std::enable_if_t<is_formattable<T, Char>::value>> {
- private:
-  formatter<T, Char> underlying_;
-  static constexpr basic_string_view<Char> optional =
-      detail::string_literal<Char, 'o', 'p', 't', 'i', 'o', 'n', 'a', 'l',
-                             '('>{};
-  static constexpr basic_string_view<Char> none =
-      detail::string_literal<Char, 'n', 'o', 'n', 'e'>{};
-
-  template <class U>
-  FMT_CONSTEXPR static auto maybe_set_debug_format(U& u, bool set)
-      -> decltype(u.set_debug_format(set)) {
-    u.set_debug_format(set);
-  }
-
-  template <class U>
-  FMT_CONSTEXPR static void maybe_set_debug_format(U&, ...) {}
-
- public:
-  template <typename ParseContext> FMT_CONSTEXPR auto parse(ParseContext& ctx) {
-    maybe_set_debug_format(underlying_, true);
-    return underlying_.parse(ctx);
-  }
-
-  template <typename FormatContext>
-  auto format(const std::optional<T>& opt, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    if (!opt) return detail::write<Char>(ctx.out(), none);
-
-    auto out = ctx.out();
-    out = detail::write<Char>(out, optional);
-    ctx.advance_to(out);
-    out = underlying_.format(*opt, ctx);
-    return detail::write(out, ')');
-  }
-};
-FMT_END_NAMESPACE
-#endif  // __cpp_lib_optional
-
-#ifdef __cpp_lib_source_location
-FMT_BEGIN_NAMESPACE
-FMT_EXPORT
-template <> struct formatter<std::source_location> {
-  template <typename ParseContext> FMT_CONSTEXPR auto parse(ParseContext& ctx) {
-    return ctx.begin();
-  }
-
-  template <typename FormatContext>
-  auto format(const std::source_location& loc, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    auto out = ctx.out();
-    out = detail::write(out, loc.file_name());
-    out = detail::write(out, ':');
-    out = detail::write<char>(out, loc.line());
-    out = detail::write(out, ':');
-    out = detail::write<char>(out, loc.column());
-    out = detail::write(out, ": ");
-    out = detail::write(out, loc.function_name());
-    return out;
-  }
-};
-FMT_END_NAMESPACE
-#endif
-
-#if FMT_CPP_LIB_VARIANT
-FMT_BEGIN_NAMESPACE
-namespace detail {
-
-template <typename T>
-using variant_index_sequence =
-    std::make_index_sequence<std::variant_size<T>::value>;
-
-template <typename> struct is_variant_like_ : std::false_type {};
-template <typename... Types>
-struct is_variant_like_<std::variant<Types...>> : std::true_type {};
-
-// formattable element check.
-template <typename T, typename C> class is_variant_formattable_ {
-  template <std::size_t... Is>
-  static std::conjunction<
-      is_formattable<std::variant_alternative_t<Is, T>, C>...>
-      check(std::index_sequence<Is...>);
-
- public:
-  static constexpr const bool value =
-      decltype(check(variant_index_sequence<T>{}))::value;
-};
-
-template <typename Char, typename OutputIt, typename T>
-auto write_variant_alternative(OutputIt out, const T& v) -> OutputIt {
-  if constexpr (is_string<T>::value)
-    return write_escaped_string<Char>(out, detail::to_string_view(v));
-  else if constexpr (std::is_same_v<T, Char>)
-    return write_escaped_char(out, v);
-  else
-    return write<Char>(out, v);
-}
-
-}  // namespace detail
-
-template <typename T> struct is_variant_like {
-  static constexpr const bool value = detail::is_variant_like_<T>::value;
-};
-
-template <typename T, typename C> struct is_variant_formattable {
-  static constexpr const bool value =
-      detail::is_variant_formattable_<T, C>::value;
-};
-
-FMT_EXPORT
-template <typename Char> struct formatter<std::monostate, Char> {
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return ctx.begin();
-  }
-
-  template <typename FormatContext>
-  auto format(const std::monostate&, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    return detail::write<Char>(ctx.out(), "monostate");
-  }
-};
-
-FMT_EXPORT
-template <typename Variant, typename Char>
-struct formatter<
-    Variant, Char,
-    std::enable_if_t<std::conjunction_v<
-        is_variant_like<Variant>, is_variant_formattable<Variant, Char>>>> {
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return ctx.begin();
-  }
-
-  template <typename FormatContext>
-  auto format(const Variant& value, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    auto out = ctx.out();
-
-    out = detail::write<Char>(out, "variant(");
-    FMT_TRY {
-      std::visit(
-          [&](const auto& v) {
-            out = detail::write_variant_alternative<Char>(out, v);
-          },
-          value);
-    }
-    FMT_CATCH(const std::bad_variant_access&) {
-      detail::write<Char>(out, "valueless by exception");
-    }
-    *out++ = ')';
-    return out;
-  }
-};
-FMT_END_NAMESPACE
-#endif  // FMT_CPP_LIB_VARIANT
-
-FMT_BEGIN_NAMESPACE
-FMT_EXPORT
-template <typename Char> struct formatter<std::error_code, Char> {
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return ctx.begin();
-  }
-
-  template <typename FormatContext>
-  FMT_CONSTEXPR auto format(const std::error_code& ec, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    auto out = ctx.out();
-    out = detail::write_bytes(out, ec.category().name(), format_specs<Char>());
-    out = detail::write<Char>(out, Char(':'));
-    out = detail::write<Char>(out, ec.value());
-    return out;
-  }
-};
-
-FMT_EXPORT
-template <typename T, typename Char>
-struct formatter<
-    T, Char,  // DEPRECATED! Mixing code unit types.
-    typename std::enable_if<std::is_base_of<std::exception, T>::value>::type> {
- private:
-  bool with_typename_ = false;
-
- public:
-  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
-      -> decltype(ctx.begin()) {
-    auto it = ctx.begin();
-    auto end = ctx.end();
-    if (it == end || *it == '}') return it;
-    if (*it == 't') {
-      ++it;
-      with_typename_ = FMT_USE_TYPEID != 0;
-    }
-    return it;
-  }
-
-  template <typename OutputIt>
-  auto format(const std::exception& ex,
-              basic_format_context<OutputIt, Char>& ctx) const -> OutputIt {
-    format_specs<Char> spec;
-    auto out = ctx.out();
-    if (!with_typename_)
-      return detail::write_bytes(out, string_view(ex.what()), spec);
-
-#if FMT_USE_TYPEID
-    const std::type_info& ti = typeid(ex);
-#  ifdef FMT_HAS_ABI_CXA_DEMANGLE
-    int status = 0;
-    std::size_t size = 0;
-    std::unique_ptr<char, void (*)(void*)> demangled_name_ptr(
-        abi::__cxa_demangle(ti.name(), nullptr, &size, &status), &std::free);
-
-    string_view demangled_name_view;
-    if (demangled_name_ptr) {
-      demangled_name_view = demangled_name_ptr.get();
-
-      // Normalization of stdlib inline namespace names.
-      // libc++ inline namespaces.
-      //  std::__1::*       -> std::*
-      //  std::__1::__fs::* -> std::*
-      // libstdc++ inline namespaces.
-      //  std::__cxx11::*             -> std::*
-      //  std::filesystem::__cxx11::* -> std::filesystem::*
-      if (demangled_name_view.starts_with("std::")) {
-        char* begin = demangled_name_ptr.get();
-        char* to = begin + 5;  // std::
-        for (char *from = to, *end = begin + demangled_name_view.size();
-             from < end;) {
-          // This is safe, because demangled_name is NUL-terminated.
-          if (from[0] == '_' && from[1] == '_') {
-            char* next = from + 1;
-            while (next < end && *next != ':') next++;
-            if (next[0] == ':' && next[1] == ':') {
-              from = next + 2;
-              continue;
-            }
-          }
-          *to++ = *from++;
-        }
-        demangled_name_view = {begin, detail::to_unsigned(to - begin)};
-      }
-    } else {
-      demangled_name_view = string_view(ti.name());
-    }
-    out = detail::write_bytes(out, demangled_name_view, spec);
-#  elif FMT_MSC_VERSION
-    string_view demangled_name_view(ti.name());
-    if (demangled_name_view.starts_with("class "))
-      demangled_name_view.remove_prefix(6);
-    else if (demangled_name_view.starts_with("struct "))
-      demangled_name_view.remove_prefix(7);
-    out = detail::write_bytes(out, demangled_name_view, spec);
-#  else
-    out = detail::write_bytes(out, string_view(ti.name()), spec);
-#  endif
-    *out++ = ':';
-    *out++ = ' ';
-    return detail::write_bytes(out, string_view(ex.what()), spec);
-#endif
-  }
-};
-
-namespace detail {
-
-template <typename T, typename Enable = void>
-struct has_flip : std::false_type {};
-
-template <typename T>
-struct has_flip<T, void_t<decltype(std::declval<T>().flip())>>
-    : std::true_type {};
-
-template <typename T> struct is_bit_reference_like {
-  static constexpr const bool value =
-      std::is_convertible<T, bool>::value &&
-      std::is_nothrow_assignable<T, bool>::value && has_flip<T>::value;
-};
-
-#ifdef _LIBCPP_VERSION
-
-// Workaround for libc++ incompatibility with C++ standard.
-// According to the Standard, `bitset::operator[] const` returns bool.
-template <typename C>
-struct is_bit_reference_like<std::__bit_const_reference<C>> {
-  static constexpr const bool value = true;
-};
-
-#endif
-
-}  // namespace detail
-
-// We can't use std::vector<bool, Allocator>::reference and
-// std::bitset<N>::reference because the compiler can't deduce Allocator and N
-// in partial specialization.
-FMT_EXPORT
-template <typename BitRef, typename Char>
-struct formatter<BitRef, Char,
-                 enable_if_t<detail::is_bit_reference_like<BitRef>::value>>
-    : formatter<bool, Char> {
-  template <typename FormatContext>
-  FMT_CONSTEXPR auto format(const BitRef& v, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    return formatter<bool, Char>::format(v, ctx);
-  }
-};
-
-FMT_EXPORT
-template <typename T, typename Char>
-struct formatter<std::atomic<T>, Char,
-                 enable_if_t<is_formattable<T, Char>::value>>
-    : formatter<T, Char> {
-  template <typename FormatContext>
-  auto format(const std::atomic<T>& v, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    return formatter<T, Char>::format(v.load(), ctx);
-  }
-};
-
-#ifdef __cpp_lib_atomic_flag_test
-FMT_EXPORT
-template <typename Char>
-struct formatter<std::atomic_flag, Char> : formatter<bool, Char> {
-  template <typename FormatContext>
-  auto format(const std::atomic_flag& v, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    return formatter<bool, Char>::format(v.test(), ctx);
-  }
-};
-#endif  // __cpp_lib_atomic_flag_test
-
-FMT_END_NAMESPACE
-#endif  // FMT_STD_H_
diff --color -Naur fmt-original/include/fmt/xchar.h fmt-10.2.0/include/fmt/xchar.h
--- fmt-original/include/fmt/xchar.h	2025-07-16 22:36:59.482485364 +0200
+++ fmt-10.2.0/include/fmt/xchar.h	2025-07-16 22:36:52.875486392 +0200
@@ -12,31 +12,12 @@
 
 #include "format.h"
 
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
-#  include <locale>
-#endif
-
 FMT_BEGIN_NAMESPACE
 namespace detail {
 
 template <typename T>
 using is_exotic_char = bool_constant<!std::is_same<T, char>::value>;
 
-inline auto write_loc(std::back_insert_iterator<detail::buffer<wchar_t>> out,
-                      loc_value value, const format_specs<wchar_t>& specs,
-                      locale_ref loc) -> bool {
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
-  auto& numpunct =
-      std::use_facet<std::numpunct<wchar_t>>(loc.get<std::locale>());
-  auto separator = std::wstring();
-  auto grouping = numpunct.grouping();
-  if (!grouping.empty()) separator = std::wstring(1, numpunct.thousands_sep());
-  return value.visit(loc_writer<wchar_t>{out, specs, separator, grouping, {}});
-#endif
-  return false;
-}
-}  // namespace detail
-
 FMT_BEGIN_EXPORT
 
 using wstring_view = basic_string_view<wchar_t>;
